{"ACM/算法/BFS-广度优先搜索":{"slug":"ACM/算法/BFS-广度优先搜索","filePath":"ACM/算法/BFS 广度优先搜索.md","title":"BFS 广度优先搜索","links":["tags/搜索","tags/递归与递推","ACM/算法/深度优先搜索-DFS","C++/STL/Queue-队列"],"tags":["搜索","递归与递推"],"content":"搜索 递归与递推\nBFS 广度优先搜索\n\n\n在前面我们介绍过深度优先搜索 DFS，深搜的核心思想是一条路走到底，直到得到符合的结果或者超出边界情况结束\n\n\n而广度优先搜索则是从起始位置出发，每一次向外增加一圈，或执行完一大个操作之后再将计数变量增加\n\n\n广搜一般适用于求最短路径，求最少操作次数的这些操作，因为广搜本身便是向外扩散式的一种搜索\n\n\n广搜一般使用STL中的Queue 队列作为承接模板，通过其先进先出的特点实现广搜\n例题：洛谷P1135 奇怪的电梯\nsigned main()\n{\n    int n, a, b;\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    vector&lt;int&gt; to,path;\n    to = vector&lt;int&gt;(n + 1);\n    path = vector&lt;int&gt;(n + 1, -1);\n    for (size_t i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; to[i];\n    }\n    // 输入数据\n    queue&lt;int&gt; bfs; //建立一个bfs的queue队列\n    int ans = 0;\n    bfs.push(a); //将第一个元素存入队列中\n    path[a] = 0; //第一个路径初始\n    while (!bfs.empty()) { //如果队列非空，就说明仍然有可以进行下去的操作\n        int up = bfs.front() + to[bfs.front()]; //第一种可能，往上坐电梯\n        int down = bfs.front() - to[bfs.front()]; //第二种可能，往下坐电梯\n        if (up &gt; 0 &amp;&amp; up &lt;= n &amp;&amp; path[up] == -1) { //如果往上做的电梯能到达(即存在这个楼层)，且这个楼层没有被达到过\n            path[up] = path[bfs.front()] + 1; // 这个楼层的标识数 = 过来的楼层的标识数 + 1\n            bfs.push(up); //把这个楼层加入到队列里，表示接下来会对这个楼层操作\n        }\n        if (down &gt; 0 &amp;&amp; down &lt;= n &amp;&amp; path[down] == -1) { //同上\n            path[down] = path[bfs.front()] + 1;\n            bfs.push(down);\n        }\n        bfs.pop(); //原始楼层操作完毕，弹出队列\n    }\n    cout &lt;&lt; path[b]; //输出目标楼层的情况\n    return 0;\n}\n\n显然，BFS对这种求最短是一个不错的解法，但有的时候还得考虑DP或其他时间复杂度更低的方法\n"},"ACM/算法/Boyer-Moore-投票算法":{"slug":"ACM/算法/Boyer-Moore-投票算法","filePath":"ACM/算法/Boyer-Moore 投票算法.md","title":"Boyer-Moore 投票算法","links":["tags/模拟","tags/模板"],"tags":["模拟","模板"],"content":"模拟 模板\nBoyer-Moore 投票算法\n\n背景：数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素，若不存在，输出 -1\n\n\n\n一般我们习惯想到的方法是利用unordered_map 来存储每个数出现的次数，当发现有数字超过一半的时候，输出该数字，没有则在最后输出 -1\n\n\n上述方法时间复杂度和空间复杂度均为 O(n) ,而接下来介绍的算法，可以让空间复杂度降低到 O(1)\n\n\nBoyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等\n\n如果数组为空，则数组不存在主要元素\n如果数组剩下元素，则该元素可能为主要元素\n\n\n\n主要步骤：\n\n\n维护一个候选主要元素 candidate 和该元素出现次数 count ,初始时 candidate 可以为任意值，count = 0\n\n\n遍历数组 nums 的所有元素，遍历到元素 a_i 时进行如下操作：\n\n\n如果 count = 0 ,则将 a_i 的值赋给 candidate ；否则不更新 candidate 的值\n\n\n如果 candidate = a_i ，则将 count++.否则 count- -\n\n\n遍历结束后,如果存在主要元素，则为 candidate ,否则其可以为数组中的任意元素\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n在 Boyer-Moore 投票算法中，遇到相同的数则将 count 加 1，遇到不同的数则将 count 减 1\n根据主要元素的定义，主要元素的出现次数大于其他元素的出现次数之和，因此在遍历过程中，主要元素和其他元素两两抵消，最后一定剩下至少一个主要元素，此时 candidate 为主要元素，且 count \\geq 1\n\n\n\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; nums(n);\n    int candidate = 0, counts = 0;\n    for (auto &amp;&amp;i : nums) {\n        cin &gt;&gt; i;\n        if (counts == 0) candidate = i;\n        if (candidate == i)\n            counts++;\n        else\n            counts--;\n    }\n    int res = 0;\n    for (auto &amp;&amp;i : nums) {\n        if (i == candidate) {\n            res++;\n        }\n    }\n    cout &lt;&lt; (res &gt; nums.size() / 2 ? candidate : -1);\n    return 0;\n}"},"ACM/算法/DP-动态规划/区间DP":{"slug":"ACM/算法/DP-动态规划/区间DP","filePath":"ACM/算法/DP 动态规划/区间DP.md","title":"区间DP","links":[],"tags":[],"content":"引入\n\n给定一堆长度为 n 的石子，每个石子有其重量 a_i ,你需要做的是不断的合并相邻石子，每次合并i,j两堆石子需要付出 a_i + a_j的代价，你必须不断合并直到所有石子均被合并完成。你需要知道你付出的最小代价是多少\n\n特点\n\n区间dp的特点我们一般认为有以下\n\n在某一个序列上的一个区间进行操作,如(合并)\n可以利用子区间的最优解来构造全局的最优解\n\n\n\ndp含义以及状态转移\n状态定义：\n\n区间状态，我们定义dp[\\,i \\,][\\,j\\,]表示从位置 i 到位置 j 的最优解(最小代价，最大收益等)\n对于每一个 dp[\\,i\\,][\\,j\\,] 我们都应该保证其状态能从子区间转移而来\n\n状态转移：\n\n区间划分：为了计算dp[\\,i\\,][\\,j\\,],我们往往需要一个中间值 k \\in [\\,i,j\\,)\n\nk将区间[\\,i,j\\,]划分为两个区间 [\\,i,k\\,] 和 [\\,k+1,j\\,]\n我们通过合并这两个子区间的代价来进行选择\n为了能够知道所有状态的最优解,k应该遍历[\\,i,j\\,)\n\n\n递推式\n\ndp[\\,i\\,][\\,j\\,] = \\underset{i\\le k &lt; j }\\min{\\{dp[\\,i\\,][\\,k\\,] + dp[\\,k+1\\,][\\,i\\,] + \\mathrm{cost}(i,k,j)\\}}\n\n其中 \\mathrm{cost}{(i,j,k)} 为合并两个子区间所产生的代价\n\ndp计算思路\n\n一般区间dp有三层for循环，第一层枚举长度 len ,第二次找区间起始点 i ，第三层遍历所有中间点 k\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n区间dp的复杂度为 O(n^3)\n\n\n\n一般模板代码\n我们以引入问题为例进行分析\nvector&lt;vector&lt;int&gt;&gt; dp(N,vector&lt;int&gt;(N));\n// 我们认为序列长度有n\nfor(int i = 1 ; i &lt;= n ; i++)｛\n\tdp[i][i] = 0;\n｝\n// 预处理,根据题目含义做出预处理数组(前缀和，或合并代价)(此处为合并石子，即石子的前缀和，用于计算区间代价)\nvector&lt;int&gt; vv(N);\nfor(int i = 1; i &lt;= n; i++) {\n\tvv[i] = vv[i-1] + v[i];\n}\n \n//进行区间dp，枚举所有长度n\nfor(int len = 2;len &lt;= n; len++){            //第一层，枚举长度\n\tfor(int i = 1; i + len - 1 &lt;= n; i++){   //第二层，枚举起点\n\t\tint j = i + len - 1;                 //计算终点\n\t\tdp[i][j] = INT_MAX;                 \n\t\tfor(int k = i; k &lt; j ;k++{\n\t\t\tdp[i][j] = min(dp[i][j],dp[i][k] + dp[k+1][j] + (vv[j] - vv[i-1]);       // 区间dp转移，遍历所有中间节点，取最小值\n\t\t}\n\t}\n}\n \ncout &lt;&lt; dp[1][n];         //答案即为从1-n的区间最优解\n "},"ACM/算法/DP-动态规划/背包DP":{"slug":"ACM/算法/DP-动态规划/背包DP","filePath":"ACM/算法/DP 动态规划/背包DP.md","title":"背包DP","links":["tags/背包问题","tags/动态规划"],"tags":["背包问题","动态规划"],"content":"背包问题 动态规划\n背包DP\n\n两个特点：\n\n\n一个物体有 大小 + 价值\n有一个背包只能容纳某一个特定大小\n\n\n\n要求：找最大价值\n\n\n一般性转移方程——&gt; 设背包大小为 N,有 Y 个物品 , 物品价值为 val_i 物品大小为 size_j\n\n\n设dp[i][j] 表示任取 0\\to i 个物品在j时间下取得的\\sum a_k的最大值\n\n\n初始化见下：\n\n\nvector&lt;vector&lt;int&gt;&gt; dp(Y,vector&lt;int&gt;(N+1,0)); \n//对[0]行的初始\nfor (size_t i = size[0]; i &lt;= N; i++) {\n    dp[0][i] = val[0];\n}\n//对[0]列的初始\n//在背包初始大小为0的情况，只有 size = 0 的物品可以被装下\nfor(size_t j = 0; j &lt;= Y ; j++){\n    dp[i][0] = 0;\n}\n\n\n现在我们来推递推方程：\n\n\n对于一个 dp[i][j] 而言表示的是在 j 背包大小下取得 前i个val 的最大值\n\n\n从 dp[i-1][j] 到 dp[i][j] 有两种情况\n\nj &lt; size_i  =⇒   dp[i][j] = dp[i-1][j] 即当前容量装不下 size_i这个物品，只能与前一个的价值相同 = ⇒ 即增加的val = 0\nj &gt; size_i ：\n装 size_i :  dp[i][j] = dp[i][j - size[i]]+val[i]   .1\n不装size_i:   dp[i][j] = dp[i-1][j]\n\n\n\n对 .1 的解释： 选择装下大小为 size_i 价值为 val_i 的物品，那对dp从[i-1][j] 到的 [i][j] 而言:\n\ni 表示选取的范围 那显然 i-1 \\to i\nj 表示背包容量大小 ： 既然我们选取了这个物品 i , 那我们就看对于没有该物品时候的背包大小所表示的价值 + 这个物品 i 的价值即：j\\to j-size_i\ndp[i][j]本质是最大价值，则我们需要加上所选物品的价值 即： dp[i][j-size[i]] + val[i]\n\n\n\n在选择 j &gt; size_i 的两种情况下选择较大的一方表示最大价值\n\n\n即完整递推表达式为：\n\n\ndp[i][j] =\n\\left\\{\n\\begin{aligned}\n&amp;dp[i-1][j] &amp; j &lt; size[i] \\\\\n&amp;\\max(dp[i-1][j],dp[i][j-size[i]]+val[i]) &amp; j \\geq size{[i]} \\\\\n\\end{aligned}\n\\right.\n代码表示见下\nfor (size_t i = 1; i &lt; m; i++) {\n    for (size_t j = 1; j &lt;= t; j++) {\n        if (j &lt; size[i])\n            dp[i][j] = dp[i - 1][j];\n        else\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - size[i]] + val[i]);\n    }\n}"},"ACM/算法/Ranges库":{"slug":"ACM/算法/Ranges库","filePath":"ACM/算法/Ranges库.md","title":"Ranges库","links":["tags/语法"],"tags":["语法"],"content":"语法\n\nrange::find(v,‘1’);\n\n在容器 v 内查找传入的第二个参数，返回值是第一个找到的参数的迭代器，如果没找到，则返回v.end()\n\n\nrange::minmax(v)\n\n以一个pair形式返回容器中的最大值和最小值\n\n\n\n\t//常用接收形式\n\tauto [s1,s2] = ranges::minmax(v)\n\nranges::max_element(v)\n\n如果不进行二次传参，则返回范围内最大的一个元素的迭代器\n如果进行二次传参，则可以创建一个映射关系，返回映射关系下最大的那个元素的迭代器，例如：\n\n\n\n\tvector&lt;string&gt; v = {&quot;12&quot;,&quot;12345&quot;,&quot;1234&quot;};\n    auto s1 = ranges::max_element(v,\n\t{},     //comp比较函数，一般默认即可 \n    [](const string &amp;s) { return s.size(); }); //自定义映射函数，一般使用lambda进行编写\n    cout &lt;&lt; *s1;\n\nranges::sort(v)\n\n与std::sort()用法几乎一致，但是ranges::sort()仅仅需要传入数组名即可排序\nranges::sort(v,comp,porj)\n\nporj：\n\nporj投影函数，旨在简化传入参数的复杂情况，它可以将元素映射为其他属性或值。\n若不传入proj，则会对元素本身进行排列\n例：ranges::sort(v, {}, string::size);\n在上面的例子中，v容器内的字符串被转换成为了string::size,sort对size进行排列\n传入的函数也可以是一个lambda形式的函数\nranges::sort(v, {}, [](const string &amp;s) { return s.size() % 3; });\n例2:\n\n\n\n\n\n\n\n\tstruct Person {\n\tstd::string name;\n\tint age;\n\t};\n\t\nint main() {\n\tstd::vector&lt;Person&gt; people = {{&quot;Alice&quot;, 30}, {&quot;Bob&quot;, 25}, {&quot;Charlie&quot;, 35}};\t\n\tstd::ranges::sort(people, {}, &amp;Person::age);  // 按 age 属性排序\n\tfor (const auto&amp; person : people) {\n\tstd::cout &lt;&lt; person.name &lt;&lt; &quot; &quot;;  // 输出: Bob Alice Charlie\n    }\n}\n\n在这个例子中调用了Person::age将容器内的元素转化为age进行比较\n\n\nviews::take / views::drop\n\n这是view命名空间下的函数，作用是取前n个(take) 去前n个(drop)\n语法规则：auto vi_1 = v | view::take(n)\n\n其中：v 是容器 ， n 是取的值， vi_1是一个视图\n视图可以采用范围for的迭代方式，如果要对视图进行操作，可以使用两种解决方案：\n\n使用.begin() + index操作视图\n使用 to&lt;vector&gt;操作\n\nvector&lt;int&gt; v = vw | ranges::to&lt;vector&gt;();\n\n\n\n\n\n\n\n\n\nint main()\n{\n\tvector&lt;int&gt; a = {1,2,3,4,5};\n\tauto a1 = a | views::take(2);\n\tfor(auto &amp;&amp; i : a1)\n\t{\n\t\tcout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\t}\n\t// 输出 1 2\n\tcout &lt;&lt; endl;\n\tauto a2 = a | views::drop(2);\n\tfor(auto &amp;&amp; i : a2)\n\t{\n\t\tcout &lt; i &lt;&lt; &quot; &quot;;\n\t}\n\t// 输出 3 4 5 6\n\tcout &lt;&lt; endl;\n\tauto vi = a2 | ranges::to&lt;vector&gt;();\n\tfor(auto &amp;&amp; i : a2)\n\t{\n\t\tcout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\t}\n\t//输出同 a2\n}"},"ACM/算法/Readme":{"slug":"ACM/算法/Readme","filePath":"ACM/算法/Readme.md","title":"Readme","links":[],"tags":[],"content":"如何优雅地食用这个 C++ 语法笔记仓库？\n\n确保你拥有 git 并掌握一定的git知识\n确保你使用的笔记软件是 obsidian\n确保你会使用github的基础功能\n\n\n准备工作完毕，现在开始食用吧\n同步更新使用如下\n\nfork这个仓库\n到你fork好的仓库里，用git克隆下来这个仓库\n用 obsidian 打开这个仓库如下的路径：\nD:\\Code film\\C++\\memo\\C++语法(新)\n定期用git同步fork的仓库即可\n\n\n非同步更新如下：\n\n\n使用git克隆这个仓库\ngit clone github.com/imicola/Questions-and-Impressions.git\n\n\n用 obsidian 打开这个仓库如下的路径：\nD:\\Code film\\C++\\memo\\C++语法(新)\n\n\n如果想获取更新，可以用以下方法：\n\n\n添加上游仓库\n首先需要在你的本地 Git 仓库中添加一个指向原始仓库的远程仓库链接。假设你已经克隆了仓库到本地，并且当前目录已经在仓库内。你可以通过以下命令添加：\ngit remote add upstream github.com/imicola/Questions-and-Impressions.git\n\n\n这样做之后，你就有了两个远程仓库：origin（指向你 fork 的仓库）和 upstream（指向原始仓库）。\n\n获取上游仓库的更新\n接下来，使用 git fetch 命令来获取上游仓库的所有更新，但不会自动合并或修改你当前的工作目录。\n\ngit fetch upstream\n\n\n切换到主分支\n确保你在你的主分支上（对于大多数仓库来说，这个分支叫做 main 或者 master）。如果没有在该分支上，请切换过去：\ngit checkout main  # 或者 git checkout master\n\n\n合并上游仓库的更新\n使用 git merge 命令将上游仓库的更新合并到你的本地主分支：\ngit merge upstream/main  # 如果主分支名为main；若为master则替换为upstream/master\n\n\n这一步会将上游仓库的最新更改合并到你的本地仓库中。\n通过定期重复步骤 2 到 4，你可以确保你的本地仓库与原始仓库保持同步。"},"ACM/算法/stringstream":{"slug":"ACM/算法/stringstream","filePath":"ACM/算法/stringstream.md","title":"stringstream","links":["tags/语法","tags/字符串"],"tags":["语法","字符串"],"content":"语法 字符串\nC++针对字符串的读写有一套专门的方法，即stringstream\n语法规则：\n\nstringstream ss(str)\nstr是你想进行操作的字符串\n场景：\n读取字符串中的数据：你可以通过 stringstream 从字符串中提取整数、浮动数、字符等。\n将数据写入字符串：可以将不同类型的数据输出到一个字符串中。\n\nmain(){\n\t//读入\n\tstd::stringstream ss(str);\n    int num1, num2;\n    ss &gt;&gt; num1 &gt;&gt; num2;  // 从stringstream读取数据\n    std::cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot;, num2: &quot; &lt;&lt; num2 &lt;&lt; std::endl;\n    //写出\n    int x = 10, y = 20;\n    std::stringstream ss2;\n    ss2 &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y;  // 将数字写入stringstream\n    std::string result = ss2.str();  // 获取格式化后的字符串\n    std::cout &lt;&lt; &quot;Formatted string: &quot; &lt;&lt; result &lt;&lt; std::endl;\n}\n\n一般而言，我们习惯使用getline来将整个字符串读入，然后直接stringstream ss(s)\n\nmain(){\n\tstring s;\n\tgetline(cin,s);\n\tstd::stringstream ss(s);\n\tint p;\n\t//假设读入的都是数字\n\twhile(ss &gt;&gt; p){\n\t/* code */\n\t}\n}"},"ACM/算法/二分":{"slug":"ACM/算法/二分","filePath":"ACM/算法/二分.md","title":"二分","links":["tags/二分"],"tags":["二分"],"content":"二分\n二分\n二分是一个经典思想，包含二分查找和二分答案\n1 二分查找\n\n在一串升序排列的数字中，找到某一个数字 k\n\n思路： 维护一个左右边界 l,r，其中初始时,  l = \\min(a_n)|_n , r= \\max(a_n)|_n (即最大值和最小值的下标)\n进行循环，直到 l &gt; r,在每个循环做如下操作\n\n维护一个mid, 其为mid = (l + r + 1)/2\n判断a_{mid} = k 是否成立\n\n如果a_{mid} &lt; k 则让 l = mid + 1；\n如果a_{mid} &gt; k 则让 r = mid - 1;\n\n\n跳出循环，此时mid即为数k的下标\n\n2 二分答案\n二分答案是在优化循环时常用的思路，当我们发现一般循环思路难以在规定时间下解决问题的时候可以考虑进行二分答案\n思路如下:\n\n假设得到的答案为 \\omega ，设立 l,r 作为答案 \\omega 的范围\n进行循环：每次将 \\omega 赋值为 (l + r + 1)/2\n通过得到的 \\omega 在题意下推理\n\n如果\\omega符合题意，说明仍然存在范围，可以继续缩小\\omega\n如果不符合题意，说明已经超出范围，需要扩大范围\n\n\n循环结束，此时 \\omega 为最优解\n\n最大连号数问题\n\n例：\n有n个房间，每个房间只能容纳一个人，当两个及以上房间都有人时称为房间连号，连号数等于这一段同时有人的房间的数量，现在有k个人要被分配到房间里，请你找出最佳分配方式使得最大连号数最小,我们保证 k \\leq n\n\n思路：\n\n使用二分答案查找一个数 m ，对于每个猜测的m，我们需要验证是否存在一种分配方式，使得所有连号数不超过m，并且恰好分配k个人\n验证思路：\n\n对于每个候选的m，计算在最大连号数不超过m的情况下，最多可以安排多少人。这通过将房间分成多个段，每个段最多m人，段之间至少有一个空房间来实现。如果这种安排下的人数大于等于k，则m是可行的\n具体思路：\n\n确定 mid = (l + r)/2 ,这里的mid我们将其当作可以放下的最大连号数\n进入循环：\n\nc1 = n/(mid + 1) 表示在这个最大连号数下房间可以被分成几块\n\n因为两个连号房间之间得隔着一个空房间，所以是mid + 1\n\n\nc2 = n - c1*(mid+1) 表示在n个房间中分完了后剩下的部分\n计算在 mid 条件下能放下的人数ans\n比较 ans 与题目人数 k\n\n\n若 ans \\geq k 说明可以放下的人数超过题目人数，可以缩减人数范围\n若 ans &lt; k 则说明要扩大人数范围\n\n\n\n\n\nvoid solve() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    int l = 0, r = k,ans = 0;\n    while (l &lt;= r)\n    {\n        int mid = (l + r) / 2;\n        auto check = [&amp;]() -&gt; bool {\n            int ans1 = 0;\n            int c1 = n / (mid + 1);\n            int c2 = n - c1 * (mid+1);\n            ans1 += c1 * mid + c2;\n            return ans1 &gt;= k;\n        };\n        if(check()){\n            ans = mid;\n            r = mid - 1;\n        }\n        else\n        {\n            l = mid + 1;\n        }\n        \n    }\n    cout &lt;&lt; ans;\n}"},"ACM/算法/二进制":{"slug":"ACM/算法/二进制","filePath":"ACM/算法/二进制.md","title":"二进制","links":["tags/数学","tags/二进制","tags/位运算"],"tags":["数学","二进制","位运算"],"content":"数学 二进制 位运算\n快速获取某一个数的二进制\n法一: 从原理上获取\n\n一个数的二进制的计算可以通过将这个数反复整除2且取模2来获得其位数，直到这个数变为0\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n \nstd::string decimalToBinary(int n) {\n    if (n == 0) return &quot;0&quot;;\n    std::string binary;\n    while (n &gt; 0) {\n        binary = (n % 2 == 0 ? &quot;0&quot; : &quot;1&quot;) + binary;\n        n /= 2;\n    }\n    return binary;\n}\n \nint main() {\n    int number;\n    std::cout &lt;&lt; &quot;请输入一个十进制数: &quot;;\n    std::cin &gt;&gt; number;\n    std::string binaryForm = decimalToBinary(number);\n    std::cout &lt;&lt; &quot;该数字的二进制表示为: &quot; &lt;&lt; binaryForm &lt;&lt; std::endl;\n    return 0;\n}\n法二: 位运算\n\n&amp;(与运算) ： 考虑两个数 a,b ,当 a \\&amp; b 时，实际上是其二进制位的比较，当 a,b 某一个相同的二进制为都为 1 时，运算结果的该二进制位也为 1 ，否则为 0 .\n考虑任意一个 int 类型的正整数 k ，当 k \\&amp; 1 时，实际上得出的数是 k 第0位二进制位的结果\n考虑 k &gt;&gt; x ,这个过程将 k 二进制位向右移动 x 位。此时结合上一条，我们便可以将 k 的每一位表示出来\n\n#include &lt;bits/stdc++.h&gt;\n \nstd::vector&lt;int&gt; decimalToBinary(int n)\n{\n    std::vector&lt;int&gt; bit_2;\n    for (int i = 31; i &gt;= 0; i--) {\n        bit_2.emplace_back((n &gt;&gt; i) &amp; 1);\n    }\n    while (!*bit_2.begin()) bit_2.erase(bit_2.begin());\n    return bit_2;\n}\n \nint main()\n{\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; ans = decimalToBinary(n);\n    for (auto &amp;&amp;i : ans) {\n        std::cout &lt;&lt; i;\n    }\n}\n快速获取一个数二进制有多少个0或1\n放进函数里不断向右一位与 1 进行与运算，计数即可\n#include &lt;bits/stdc++.h&gt;\n \nint count_2bit(int n, bool x)\n{\n    int cnt = 0;\n    while (n &gt; 0) {\n        if ((n &amp; 1) == x) {\n            cnt++;\n        }\n        n &gt;&gt;= 1;\n    }\n    return cnt;\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int n;\n    std::cin &gt;&gt; n;\n    int onecount = count_2bit(n, 1);\n    int zerocount = count_2bit(n, 0);\n    std::cout &lt;&lt; &quot;count one = &quot; &lt;&lt; onecount &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;count zero = &quot; &lt;&lt; zerocount &lt;&lt; std::endl;\n    return 0;\n}\n获取二进制最低位 1 / 0 在第几位\n最低位 1\n要快速找到一个数的二进制表示中最低位的1的位置，可以通过以下步骤：\n\n\n找到最低位1：计算 n &amp; -n，这会得到一个仅保留n最低位1的掩码。\n\n\n位置确定：通过计算掩码的二进制位数或使用计数尾部零的函数（如__builtin_ctz）得到位置。\n\n\n#include &lt;bits/stdc++.h&gt;\n \nint get_2_low0(int n)\n{\n    if (n == 0) return -1;\n    int mask = (n) &amp; -(n);\n    int res = __builtin_ctz(mask);\n    return res;\n}\n \nint main()\n{\n    int n;\n    std::cin &gt;&gt; n;\n    std::cout &lt;&lt; get_2_low0(n) &lt;&lt; std::endl; // 输出0\n    return 0;\n}\n最低位0\n和取1类似，只需要取 ~n &amp; -~n 即可然后找保留1的位置即可\n#include &lt;bits/stdc++.h&gt;\n \nint get_2_low0(int n)\n{\n    int mask = (~n) &amp; -(~n);\n    int res = __builtin_ctz(mask);\n    if (pow(2, res) &gt; n) return -1;\n    return res;\n}\n \nint main()\n{\n    int n;\n    std::cin &gt;&gt; n;\n    std::cout &lt;&lt; get_2_low0(n) &lt;&lt; std::endl;\n    return 0;\n}\n某些特殊二进制数判断\n判断数k是不是2的幂次\n思路：如果k为2的幂次，则k的二进制构造为：k_2 = 1\\overbrace{0\\cdots0 }^{n},则(k-1)_2 = \\overbrace{1\\cdots1}^{n-1} 使用 k\\, \\&amp;\\, (k-1)检查是否为0即可\n\nbool is_power_of2 = k &amp; ( k - 1 ) == 0\n\n判断数k是不是二进制全1数\n\n结合上一个判断\n\nbool is1num = k&amp;(k+1) == 0\n\n\n\n某些特殊数下的特殊性质\n当k为2^n时\n\n若p &lt; k :\n\np \\oplus k = p+k\np\\ \\&amp;\\ k = 0\np\\ \\mid \\ k = 0\np\\mod k = p\\,\\&amp;(k-1)\n\n\nk\\ \\&amp; \\ (k-1) = 0\n\n当k = 2^n - 1时\n\n若p \\leq k时\n\np \\oplus k = p-k\np\\,\\&amp;\\, k=p\\%(k+1)\n\n\n"},"ACM/算法/位运算":{"slug":"ACM/算法/位运算","filePath":"ACM/算法/位运算.md","title":"位运算","links":["tags/位运算","tags/二进制","tags/数学"],"tags":["位运算","二进制","数学"],"content":"位运算 二进制 数学\n两数之间的运算符\n\n两数的运算符有 「与，或，异或」三种运算方式，它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算运算符数学符号解释与&amp;\\And,and只有两个对应位都为 1 时才为 1或|\\mid,or只要两个对应位中有一个 1 时就为 1异或^\\oplus,xor只有两个对应位不同时才为 1\n一些总结经验：\n\n\n对或(|)运算而言，有如下性质：\n\na \\mid b = b \\mid a\n\\left( a \\mid b \\right) \\mid c = \\left( b \\mid c \\right) \\mid a\na \\mid 0 = a\na \\mid a = a\n若 a\\leq b，则 a \\mid c \\leq b \\mid c（对无符号数成立)\na \\mid b \\leq \\max(a,b)\n\n\n\n对异或 \\oplus 有如下性质：\n\na \\oplus b = a + b - 2(a \\&amp; b)\na \\oplus b = x \\Rightarrow a = b \\oplus x\n\n\n"},"ACM/算法/分数背包问题-(Fractional-Knapsack-Problem)":{"slug":"ACM/算法/分数背包问题-(Fractional-Knapsack-Problem)","filePath":"ACM/算法/分数背包问题 (Fractional Knapsack Problem).md","title":"分数背包问题 (Fractional Knapsack Problem)","links":["tags/贪心","tags/背包问题"],"tags":["贪心","背包问题"],"content":"贪心 背包问题\n分数背包问题 (Fractional Knapsack Problem)\n\n代表题目：洛谷P2240[部分背包问题][www.luogu.com.cn/problem/P2240]\n部分背包问题，本质甚至不是动态规划，而是贪心,这个题名出的非常具有迷惑性\n特点：\n\n有一个容量为T 的背包\n有N组物品，每组物品分别有以下两个特性：\n\n价值：这堆物品所代表的价值\n重量：这堆物品的重量\n\n\n与经典的0/1背包不同的是，分数背包允许将物品划分为重量为 1 的单位物品\n策略：先计算每一堆物品的单位价值，再根据单位价值装填背包。\n对P2240代码如下：\n\n\n   //#pragma GCC optimize(3)\n   #include &lt;bits/stdc++.h&gt;\n   //#define int LL\n   #define endl &#039;\\n&#039;\n   #define size_t int\n   #define all(v) v.begin(), v.end()\n   using namespace std;\n   typedef long long LL;\n   typedef vector&lt;int&gt; vint; \n   typedef vector&lt;vint&gt; vvint;\n   typedef vector&lt;string&gt; vstr;\n   typedef pair&lt;int, int&gt; pii;\n   typedef vector&lt;pii&gt; vpii;\n   \n   bool cmp(pair&lt;double, int&gt; a, pair&lt;double, int&gt; b)\n   {\n       if (a.first == b.first) return a.second &gt; b.second;\n       return a.first &gt; b.first;\n   }\n   signed main()\n   {\n       //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n       int n, t;\n       cin &gt;&gt; n &gt;&gt; t;\n       vector&lt;pair&lt;double, int&gt;&gt; coin(n);\n       for (auto &amp;&amp;[val, wei] : coin) {\n           double m, v;\n           cin &gt;&gt; m &gt;&gt; v;\n           val = (v / m);\n           wei = m;\n       }\n       sort(all(coin), cmp);\n       double ans = 0;\n       for (size_t i = 0; i &lt; n; i++) {\n           if (t &gt;= coin[i].second) {\n               ans += coin[i].second * coin[i].first;\n               t -= coin[i].second;\n           }\n           else {\n               ans += coin[i].first * t;\n               break;\n           }\n       }\n       printf(&quot;%.2f&quot;, ans);\n       return 0;\n   }\n\n不难发现这其实是一种贪心而非背包问题\n"},"ACM/算法/前缀和与差分":{"slug":"ACM/算法/前缀和与差分","filePath":"ACM/算法/前缀和与差分.md","title":"前缀和与差分","links":["tags/数学","tags/前缀和与差分"],"tags":["数学","前缀和与差分"],"content":"数学 前缀和与差分\n前缀和与差分\n1.1 一维数组的前缀和\n\n对数列 A [1,2,3,4,5] ,求数列B,使B_i = \\sum_{k=0}^{i}A_k\n\n\n思路： 因为B[0] = A[0]  且有递推式 B_i = B_{i-1}+A_i构造递推式\n\nint main()\n{\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    vector&lt;int&gt; A = {1, 2, 3, 4, 5, 6};\n    vector&lt;int&gt; B(A.size());\n    B[0] = A[0];\n    for (size_t i = 1; i &lt; A.size(); i++) {\n        B[i] = B[i - 1] + A[i];\n    }\n    for (auto &amp;&amp;i : B) cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    //输出: 1 3 6 10 15 21\n    return 0;\n}\n\n于传统代码相比，将时间复杂度从O(n^2)降低到O(n)且空间复杂度仍然是O(n)\n\n1.2 二维数组的前缀和\n对一个二维数组A:\nA=\n\\left[\n\\begin{matrix}\n1 &amp; 2 &amp; 3 &amp;4\\\\\n5 &amp; 6 &amp; 7 &amp;8 \\\\\n9 &amp; 10 &amp;11 &amp;12  \\\\\n\\end{matrix}\n\\right]\n二维数组前缀和定义：存在二维数组S，有：\nS_{i,j} = \\sum_{k_1=0}^{i}\\sum_{k_2=0}^{j}A_{k_1,k_2}\n类比一维的情形，S_{i,j}应该可以基于S_{i-1,j}或 S_{i,j-1} 计算，从而避免重复计算前面若干项的和。但是，如果直接将S_{i-1,j}和 S_{i,j-1} 相加，再加上 A_{i,j}，会导致重复计算 S_{i-1,j-1} 这一重叠部分的前缀和，所以还需要再将这部分减掉。这就是 容斥原理。由此得到如下递推关系：\nS_{i,j} = A_{i,j} + S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1}\n简单代码实现:\nint main()\n{\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    //在构建A的时候可以将A整体向右下移一个单位防止负数下标的出现\n    vector&lt;vector&lt;int&gt;&gt; A = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 2, 3, 4},\n        {0, 5, 6, 7, 8},\n        {0, 9, 10, 11, 12},\n    };\n    vector&lt;vector&lt;int&gt;&gt; S(A.size(), vector&lt;int&gt;(A[0].size()));\n    S[1][1] = A[1][1];\n    for (size_t i = 1; i &lt; A.size(); i++) {\n        for (size_t j = 1; j &lt; A[0].size(); j++) {\n            if (i == j &amp;&amp; i == 1) continue;\n            S[i][j] = A[i][j] + S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1];\n        }\n    }\n    for (auto &amp;&amp;i : S) {\n        for (auto &amp;&amp;j : i) {\n            cout &lt;&lt; j &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n    /*输出：\n    0 0 0 0 0\n    0 1 3 6 10\n    0 6 14 24 36\n    0 15 33 54 78\n    */\n    return 0;\n}\n\n例：洛谷 P1387 最大正方形\n最大正方形\n题目描述\n在一个 n\\times m 的只包含 0 和 1 的矩阵里找出一个不包含 0 的最大正方形，输出边长。\n输入格式\n输入文件第一行为两个整数 n,m(1\\leq n,m\\leq 100)，接下来 n 行，每行 m 个数字，用空格隔开，0 或 1。\n输出格式\n一个整数，最大正方形的边长。\n样例 #1\n样例输入 #1\n4 4\n0 1 1 1\n1 1 1 0\n0 1 1 0\n1 1 0 1\n样例输出 #1\n2\n\n\n解决思路：\n\n\n先使用二维前缀和数组将输入数组A的A_{1,1}\\to A_{i,j}的和表示出来\n\n\n设立边长l从1开始找最小正方形，其过程如下：\n\n\n设立i,j作为假设正方形的右下角点,找的正方形为以l为边长，底点为(i,j)的一个正方形\n\n\n显然i,j均从l开始，到m,n结束\n\n\nb[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l作为判断标准(why)\n\n\n\n\n\n\nb[i][j]是从(1,1) \\to (i,j)的前项和，我们需要求 (i-l,j-l) \\to (i,j) 的和\n![[Pasted image 20250123215240.png]]\n![[Pasted image 20250123215327.png]]\n\n\n\n不难发现：我们想求的是黄色部分的前缀和并判断其是否等于l^2\n\n\n我们可以发现求黄色部分就是将b(i,j)减去图一蓝色的部分，可以减去两矩形的面积b(i-l,j),b(i,j-l),但显然会多减去图二绿色部分的区域，所以我们需要利用容斥定理加上b(i-l,j-l)的面积\n\n\n所以我们便得到了黄色部分的递推表达式:\nlocans = b_{i,j} - b_{i-l,j}-b_{i,j-l}+b_{i-l，j-l}\n\n\n\n\n现在判断locans与l^2的关系即可\n完成一次查找之后就可以让 l 增加,显然 l \\in [1,\\min(n,m)]\n示例代码：\n\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint a[103][103];\nint b[103][103];  // 前缀和数组，相当于上文的 sum[]\n \nint main() {\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n \n  for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n      cin &gt;&gt; a[i][j];\n      b[i][j] =\n          b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1] + a[i][j];  // 求前缀和\n    }\n  }\n \n  int ans = 0;\n \n  int l = 1;\n  while (l &lt;= min(n, m)) {  // 判断条件\n    for (int i = l; i &lt;= n; i++) {\n      for (int j = l; j &lt;= m; j++) {\n        if (b[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l) {\n          ans = max(ans, l);  // 在这里统计答案\n        }\n      }\n    }\n    l++;\n  }\n \n  cout &lt;&lt; ans &lt;&lt; endl;\n  return 0;\n}\n\n\n                  \n                  Tip\n                  \n                \n\n\n上面进行的操作便是在前缀和中寻找某一区域的和的操作，利用这个思想，我们可以寻找任意大小的区域和，可以从容斥定理入手，进行区域和的计算\n\n\n\n树上前缀和\n\n一维数组树上前缀和\n\n在求解一维数组之前我们要进行一次前缀和操作\n对数组A的[l,r]区间，其区间和如下：\n\n\n\nsum[l,r]=S[r]−S[l−1]\n时间复杂度：构造前缀和数组O(n),查询区间和O(1)\n\n二维数组树上前缀和\n\n与一维数组树上前缀和一样，二维树上前缀和也需要提前做好前缀和工作\n快速求任意子矩阵的和\n\n\n\n\\text{sum}([x_1, y_1], [x_2, y_2]) = S[x_2][y_2] - S[x_1-1][y_2] - S[x_2][y_1-1] + S[x_1-1][y_1-1]\n\n其中：\n\nS[x_1][y_2]：从 [1,1]到[x_1,y_1]的矩形和；\nS[x_2][y_2]：从 [1,1] 到 [x_2,y_2] 的矩形和；\n−S[x_1−1][y_2]：减去上方多余的矩形；\n−S[x2][y1−1]: 减去左侧多余的矩形；\n+S[x1−1][y1−1]：加回左上角重复减去的部分。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n要注意的是在减去左边和上边的矩形的时候，下标都为S[x_1 - 1][y_2]和 S[x_2][y_1-1]\n\n\n\n差分\n\n\n指找数组范围内某一两项的差\n\n\n定义：diff[i] = a_i - a_{i-1} 特别的：i = 1时，diff[1] = a_1\n\n\n差分和原数组的关系 性质：\n\n我们将差分数组做一次前项和得到的即为原数组\n显然：我们对前缀和数组做一次差分得到的就是原数组\n差分计算数组动态变化\n\n\n\n对数组A的[l,r]区间同时加k有：\n\n\n\tdiff[l] += k\n\tdiff[r+1] -= k\n此时再进行一次前缀和，即可完成原始数组的复原\nfor(int i = 1; i &lt;= diff.size() ; i++){\n    sum[i] = sum[i-1] + d[i];\n}"},"ACM/算法/单调栈":{"slug":"ACM/算法/单调栈","filePath":"ACM/算法/单调栈.md","title":"单调栈","links":["tags/模板","tags/栈"],"tags":["模板","栈"],"content":"模板 栈\n单调栈\n\n何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。\n将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。\n\n\n如上：一个 {0,11,45,81}的单调栈，如果要插入元素 14\n\n必须将{0,11} 弹出栈，再放入 元素 14\ninsert x;\nwhile (!sta.empty() &amp;&amp; sta.top() &lt;= x) {\n    sta.pop();\n}\nsta.push(x);\n\n\n                  \n                  TIP\n                  \n                \n\n\n有的人会问，那被弹出去的元素呢？其实，在大部分单调栈问题中，我们更关注在一次弹出后的栈的状态，即在放入当前元素前栈的各个属性，比如：\n\n栈顶 \\to  能告诉我们比这个元素大(小)的元素是什么\n栈的大小 \\to 能告诉我们在这个元素前有几个比当前元素大(小)的元素\n\n\n\n\n例题：\n\n洛谷P5788 单调栈(模板)\n\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    vint n(t);\n    for (size_t i = 0; i &lt; t; i++) {\n        cin &gt;&gt; n[i];\n    }\n    stack&lt;int&gt; sta;\n    vint result(t, 0);\n    for (size_t i = t - 1; i &gt;= 0; i--) {\n        while (!sta.empty() &amp;&amp; n[sta.top()] &lt;= n[i]) {\n            sta.pop();\n        }\n        result[i] = sta.empty() ? 0 : sta.top() + 1;\n        sta.push(i);\n    }\n    for (auto &amp;&amp;i : result) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n\n思路解释：\n\n维护一个单调存放数字下标的单调栈，这个单调栈入栈的规则根据数字的具体大小决定\n当某个元素入栈时，说明至少这个元素会比当前的栈顶下标所代表的元素要大，所以我们便把栈顶弹出，直到找到某个比当前元素大的数\n而找到的这个正好就是我们要找的刚好大于这个数，我们就被栈顶放入 result  数组中即可\n那为什么栈顶就是我们要找的数字呢？\n\n如 2 6 5 7 5\n\n进行比较的是与元素的大小，但栈存放的是下标 \\to 所以使用 n[sta.top()] &lt;= n[i]进行下标栈和元素大小栈的转换\n\n\n我们最先放进去的是 5 ，此时栈的状态是 { 5 } ， \\to  下标栈的状态 { 5 }\n接着我们要放入 7  ，不难发现 7  &gt; 5  ,弹出 5 放入 7\nsta : { 4 } —— num { 7 }\n再看 5 ，5  &lt;  7  ,不需要弹出，直接放入，此时比 5 大的数就是 7 ，在result 数组下 放入 sta.top()即可\nsta : { 3 4 } ——  num {5 7}\n看 6 ，6 比 5 大 ，比 7 小 ， 将 5 弹出 ，放入 7 所代表的下标作为答案\n以此类推即可\n\n\n\n\n例题2：\n\n [USACO06NOV] Bad Hair Day S\n\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int t = 1, ans = 0;\n    cin &gt;&gt; t;\n    stack&lt;int&gt; cowh;\n    for (size_t i = 1; i &lt;= t; i++) {\n        int h;\n        cin &gt;&gt; h;\n        while (!cowh.empty() &amp;&amp; cowh.top() &lt;= h) {\n            cowh.pop();\n        }\n        ans += cowh.size();\n        cowh.push(h);\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n\n思路解释\n\n与上一题相似，但这次我们要找的是前面有多少个比放入的数字大的数量\n\n还是维护一个栈，如果当前放入的数字比栈顶大就弹出栈顶\n我们 ans 加的是还放入这个数的栈的大小，代表在这之前比这个数字大的数字有多少个\n我们要求的是 这个数能看见多少个数，求所有数能看见的总和   同样可以标识为 这个数能被多少个数看见，每个数能被看见的总和\n那当我们弹出比这个数小的数字之后，剩下的数就一定都能看见这个数\n将这些数量加到 ans 内即可\n\n\n\n"},"ACM/算法/哈希表":{"slug":"ACM/算法/哈希表","filePath":"ACM/算法/哈希表.md","title":"哈希表","links":["tags/哈希","tags/STL","C++/STL/Set-集合","C++/STL/Map-映射"],"tags":["哈希","STL"],"content":"哈希 STL\n哈希表\n哈希表的实现可以由三种数据结构实现\n\nSet 集合 Map 映射 unordered_map 无序映射\n\n\n\n哈希表算法是一种以空间换时间的算法，可以在判断数据是否重复出现 or 数据去重方面有优异性能\n\n例题：leetcode NO.1两数之和\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n哈希代码示例：&lt;leetcode.1&gt;\n\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; mp;\n        for (int i = 1; i &lt;= nums.size(); i++) {\n            mp[nums[i - 1]] += i;\n            if (mp[target - nums[i]] != 0) {\n                return {i, mp[target-nums[i]]-1};\n            }\n        }\n        return {};\n    }\n};"},"ACM/算法/并查集":{"slug":"ACM/算法/并查集","filePath":"ACM/算法/并查集.md","title":"并查集","links":["tags/图","tags/模板"],"tags":["图","模板"],"content":"图 模板\n并查集维护的是多个不相交的集合，支持两种操作:\n\n查找:查找某个元素所属的集合\n合并:将两个元素合并成一个\n\n用于维护并查集数据结构是多颗 树 组成的 森林\n原理\n查询\n\n在使用并查集时候，设立一个数组 parent 来记录每个元素的父节点：\n\n如果 parent[i] = i ,表明 i 是自己的根，即它是一个独立的集合\n如果 parent[i] = j,说明 i 属于 j 这个集合\n当我们想查询 i 时候,我们可以递归查询 parent[i]\n合并\n\n\n我们若要实现对两个数组 parent_i 和 parent_j 的合并\n\n我们只需要将一棵树的根指向另一颗树即可\n换句话说，我们只需要将 parent[i] = j即可\n\n\n\n基础实现\nconst int N = 1e7;\nvector&lt;int&gt; parent(N);\n \nvoid init()\n{\n    for (size_t i = 0; i &lt; N; i++) {\n        parent[i] = i;\n    }\n}\n \nint dsufind(int x)\n{\n    if (parent[x] == x) return x;\n    return dsufind(parent[x]);\n}\n \nvoid union_set(int x, int y)\n{\n    int rootx = x;\n    int rooty = y;\n    if (rootx != rooty) parent[x] = y;\n}\n \nvoid solve()\n{\n    init();\n    union_set(1, 2);\n    union_set(3, 1);\n    cout &lt;&lt; dsufind(3);\n}\n并查集的优化\n\n在对并查集的基本实现中,查找可能会遍历很深的树,为了提高效率,我们引入路径压缩和按秩合并\n\n路径压缩\n在dsufind过程中，让x直接指向根，减少查找的层数\nint dsufind(int x)\n{\n    if (parent[x] != x) parent[x] = dsufind(parent[x]);\n    return parent[x];\n}\n按秩合并\n目标： 在 union_set(x, y) 时，让“矮的树”挂到“高的树”下面，减少树的高度\n方法： 维护一个 rank[] 数组，表示树的高度：\n\nrank[rootX] &gt; rank[rootY]：让 rootY 挂到 rootX 下\nrank[rootX] &lt; rank[rootY]：让 rootX 挂到 rootY 下\nrank[rootX] == rank[rootY]：任选一个为根，并 rank++\n\nvoid union_set(int x, int y)\n{\n    int rootx = x;\n    int rooty = y;\n    if (rootx != rooty) {\n        if (ranks[rootx] &gt; ranks[rooty]) {\n            parent[rooty] = rootx;\n        }\n        else if (ranks[rootx] &lt; ranks[rooty]) {\n            parent[rootx] = rooty;\n        }\n        else {\n            parent[rootx] = rooty;\n            ranks[rootx]++;\n        }\n    }\n}\n在优化后的并查集时间复杂度为O(\\alpha(N)) 其中\\alpha(N)为阿克曼函数的逆，增长极慢，可以近似表现为O(1)\nunordered_map作为数据结构的并查集\n当我们试图对字符串做并查集操作的时候，我们可以利用到unordered_map&lt;string,string&gt;作为数据结构基础来实现并查集\n我们这里用类给出\nclass dsuFind {\nprivate:\n    unordered_map&lt;string, string&gt; parent;  // 存储每个字符串的父节点\n    unordered_map&lt;string, int&gt; rank;       // 按秩合并，记录树的高度\n \npublic:\n    // 查找（带路径压缩）\n    string find(string x) {\n        if (parent.find(x) == parent.end()) parent[x] = x;  // 如果 x 不在并查集，初始化\n        if (parent[x] != x) parent[x] = find(parent[x]);  // 路径压缩\n        return parent[x];\n    }\n    // 合并（按秩合并）\n    void union_set(string x, string y) {\n        string rootX = find(x);\n        string rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] &gt; rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] &lt; rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootX] = rootY;\n                rank[rootY]++;\n            }\n        }\n    }\n    // 判断两个字符串是否在同一集合\n    bool isConnected(string x, string y) {\n        return find(x) == find(y);\n    }\n};\n当然对整数我们也可以使用unordered_map来构造树，但是在大部分情况下都没有数组效率高\n特别的，当n特别大且是离散的时候我们可以使用unordered来作为树的结构"},"ACM/算法/快速幂":{"slug":"ACM/算法/快速幂","filePath":"ACM/算法/快速幂.md","title":"快速幂","links":["tags/模板","tags/数学"],"tags":["模板","数学"],"content":"模板 数学\n7 快速幂\n\n不多说，先上代码\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \nlong long fastpower(long long a , long long b)\n{\n    long long ans = 1;\n    while (b &gt; 0)\n    {\n        if (b&amp;1)\n        {\n            ans *= a;\n        }\n        a *= a;\n        b &gt;&gt;= 1;\n    }\n    return ans;\n}\n \nint main()\n{\n    cout &lt;&lt; fastpower(2,8);\n}\n快速幂的核心思路在下面这串代码里\nwhile (b &gt; 0)\n{\n    if (b&amp;1)\n    {\n        ans *= a;\n    }\n    a *= a;\n    b &gt;&gt;= 1;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n\n\nb是我们的指数，只要大于零，我们便把这个循环继续下去\n\n\n对任何一个数，都可以拆解为2进制的数，快速幂的核心思想在于，在幂次b二进制转化为十进制的时候0\\times2^k是可以不用乘进结果的而 1\\times2^k是需要被乘进结果的\n\n\n示例：\n\n\n假设我们要计算 a^{13}：\n\n13 的二进制表示是 1101_2。\n从最低位开始：\n\n第一位（1）：需要 a^{2^0}。\n第二位（0）：不需要 a^{2^1}。\n第三位（1）：需要 a^{2^2}。\n第四位（1）：需要 a^{2^3}。\n\n\n\n因此，我们可以计算：\n\\begin{split}\na^{13} &amp;= a^{1\\times2^0} + a^{0\\times2^1} + a^{1\\times2^2} +a^{1\\times2^3} \\\\\n\t   &amp;= a^{1+0+4+8}\\\\\n \t   &amp;= a^{13}\\\\\n\\end{split}\n\n\n只要b大于零，我们就把他的二进制右移(除二)，这样我们就能获取下一位二进制数字\n\n\n如果b的二进制位为1，我们就把该位置的幂次方乘进ans中，待b移位完成后ans也完成了幂运算\n\n\n\n\n\n\n快速幂的时间复杂度为O(\\log{N})\n"},"ACM/算法/扩展欧几里得算法":{"slug":"ACM/算法/扩展欧几里得算法","filePath":"ACM/算法/扩展欧几里得算法.md","title":"扩展欧几里得算法","links":["tags/数学","tags/丢番图","tags/模板","ACM/算法/线性丢番图方程"],"tags":["数学","丢番图","模板"],"content":"数学 丢番图 模板\n扩展欧几里得算法(Extended Euclidean Algorithm)\n扩展欧几里得算法是基于经典的欧几里得算法，用于计算两个整数 a和 b的最大公约数，同时还能够找到一组整数系数 x和 y，使得以下等式成立：\nax+by=\\gcd⁡(a,b)\n\n上式是一个典型的线性丢番图方程，其实扩展欧几里得算法也常用于计算线性丢番图方程的一组特解\n\n实现：\n\n初始化：设置初始值 r_0=a, r_1=b，同时设置系数 s_0=1, s_1=0 和 t_0=0, t_1=1\n执行辗转相除直到余数为0 (求gcd过程).对于每次迭代 i :\n\n计算商q_i = \\lfloor{r_i-2/r_i-1}\\rfloor和余数r_i = r_{i-2} - q_ir_{i-1}\n更新系数s_i = s_{i-2}-q_is_{i-1}和t_i = t_{i-2}-q_it_{i-1}\n\n\n结束条件：当某个余数 r_n=0=0 时，前一个非零余数 r_{n−1}就是 a 和 b 的最大公约数，而对应的 s_{n−1} 和 t_{n−1}即为满足等式的系数  x和 y\n\nint exgcd(int a, int b, int &amp;x, int &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a; // 返回gcd(a, b)\n    }\n    int r = exgcd(b, a % b, x, y);\n    int t = y;\n    y = x - (a / b) * y;\n    x = t;\n    return r;\n}\n\n上述代码中传入参数x,y最后会变为一组特解，返回的r是a，b的最大公因数\n"},"ACM/算法/最长回文子序列":{"slug":"ACM/算法/最长回文子序列","filePath":"ACM/算法/最长回文子序列.md","title":"最长回文子序列","links":["tags/字符串","tags/模板","tags/模拟"],"tags":["字符串","模板","模拟"],"content":"字符串 模板 模拟\n最长回文子序列\n\n给定一个字符串 s , 求 s 的最长回文子序列\n\n1 模拟暴力法\n\n通过一个二维数组遍历原字符串的所有子串\n逐一判断该子串是否为回文串\n更新最长子串\n\n#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nstring huiwen(const string &amp;s, int back, int front)\n{\n    int idx_b = back;\n    int idx_f = front;\n    while (idx_b &gt; idx_f) {\n        if (s[idx_f] != s[idx_b]) {\n            return s.substr(0,1);\n        }\n        idx_f++;\n        idx_b--;\n    }\n    string res;\n    for (size_t i = front; i &lt;= back; i++) {\n        res += s[i];\n    }\n    return res;\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    string ans = &quot;&quot;;\n    if(s.size() &lt;= 1){\n        cout &lt;&lt; s;\n    }\n    for (size_t i = 0; i &lt; s.size(); i++) {\n        for (size_t j = i + 1; j &lt; s.size(); j++) {\n            string temp = huiwen(s, j, i);\n            ans = (temp.size() &gt; ans.size() ? temp : ans);\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n\n这个算法的复杂度来到了惊人的O(n^3),令人汗颜，数据量在10^3就能直接让OJ爆TLE\n\n2 中心扩展算法\n中心算法的三个核心步骤\n\n1.选择中心：对于一个长度为 n 的字符串，其拥有  2n - 1 个中心结点（即长度为奇数的回文子串结点有n个，长度为偶数的回文子串的结点有n-1个\n2.扩展回文：对于每个选定的中心，尝试向两边扩展，直到无法形成回文为止\n3.更新结果：在每次成功扩展后，计算当前回文的长度，并与已知的最大回文长度进行比较。如果更长，则更新最大回文及其起始位置\n\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nint expandAroundCenter(const string &amp;s, int left, int right)\n{\n    while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) {\n        left--;\n        right++;\n    }\n    return right - left - 1;\n}\n \nstring longestPalindrome(const string &amp;s)\n{\n    if (s.empty()) return &quot;&quot;;\n    int start = 0;\n    int end = 0;\n    for (size_t i = 0; i &lt; s.size(); i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = max(len1, len2);\n        if (len &gt; end - start) {\n            end = i + len / 2;\n            start = i - (len - 1) / 2;\n        }\n    }\n    return s.substr(start, end - start + 1);\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; longestPalindrome(s) &lt;&lt; endl;\n    return 0;\n}\n\n此时时间复杂度已经降至 O(n^2) ，空间复杂度降低至O(1) ,已经绝杀大部分算法\n\n3 Manacher’s Algorithm\n\n很抱歉没能让manacher大人尽兴\t——by 中心扩展算法\n\n\n\nManacher’s Algorithm(马拉车算法)是一种高效解决最长回文子串的算法，其提供一个O(n)复杂度下的方法来实现对回文子序列的查找\n\n核心思想\n回文串的对称性： 假设已经计算出了以某个位置为中心的回文串的半径（即该回文串两边的最大扩展长度），那么与其对称的部分的回文半径也可以直接推算出来\n预处理：将原字符串进行预处理，以避免处理奇数长度和偶数长度回文的不同情况。通常的做法是在每个字符之间插入一个特殊字符（如 #），并在字符串的开头和结尾添加不同的特殊字符（如 ^ 和 $）。这样处理后的字符串长度一定是奇数，且不会出现冲突。\n动态维护最远回文边界：在扩展时，维护一个“右边界” R 和一个“中心” C，C 代表回文串的中心位置，R 代表回文串的最右边界。当当前处理的位置 i 位于 R 的范围内时，可以利用已知的对称性质来减少计算。\n\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \n//预处理\nstring preprocess(const string &amp;s)\n{\n    string t = &quot;^&quot;;\n    for (char c : s) {\n        t += &quot;#&quot; + string(1, c);\n    }\n    t += &quot;#$&quot;;\n    return t;\n}\n \nstring longestPalindrome(const string &amp;s)\n{\n    string T = preprocess(s);\n    int n = T.size();\n    vector&lt;int&gt; P(n, 0); //P[i] 记录以 t[i] 为中心的回文半径\n    int C = 0, R = 0;    //C 是回文中心，R 是回文串的最右边界\n    for (size_t i = 1; i &lt; n - 1; i++) {\n        // 确定对称位置\n        int Mirror = 2 * C - i;\n        if (i &lt; R) {\n            P[i] = min(P[Mirror], R - i);\n        }\n        // 尝试扩展边界\n        while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) {\n            P[i]++;\n        }\n        // 如果当前回文串扩展超过了 R，更新中心和右边界\n        if (i + P[i] &gt; R) {\n            C = i;\n            R = i + P[i];\n        }\n    }\n    // 找到最长的回文子串\n    int maxLen = 0;\n    int Centerindex = 0;\n    for (size_t i = 0; i &lt; n - 1; i++) {\n        if (P[i] &gt; maxLen) {\n            maxLen = P[i];\n            Centerindex = i;\n        }\n    }\n    // 构造回文串\n    int start = (Centerindex - maxLen) / 2;\n    return s.substr(start, maxLen);\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; longestPalindrome(s) &lt;&lt; endl;\n    return 0;\n}\n\n"},"ACM/算法/杂项笔记/杂项练习笔记1":{"slug":"ACM/算法/杂项笔记/杂项练习笔记1","filePath":"ACM/算法/杂项笔记/杂项练习笔记1.md","title":"杂项练习笔记1","links":["ACM/算法/扩展欧几里得算法"],"tags":["杂项练习","函数类","STL"],"content":"杂项练习\n0 点子王\n\n万能头文件 #include&lt;bits/stdc++.h&gt;(可以解决大部分头文件问题)\n使用 printf(&quot;%.2f&quot;,[输出])来输出保留两位的小数\n小写字母的ASCII码是大写字母的ASCII + 32\n在处理时间问题时，我们不妨全部转化为最小的时间单位，再用循环回复时间格式\n字符串/字符 进行比较的时候要用stramp(a,b)\n\n当 str1 &lt; str2 时，返回为负数(-1)；\n当 str1 == str2 时，返回值= 0；\n当 str1 &gt; str2 时，返回正数(1)。\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n更新：对字符串来说也可以用 == 符号判等 ——&gt; 甚至可以扩展到vector上\n\n\n\n使用stoi()函数将字符串强转为整型\nint i = char(数字) - &#039;0&#039;i即为字符型数字的整型\nchar i = int(整型) + &#039;0&#039;i即为整型数字的字符型\n在解题的时候切忌只用算法硬算，理解数学思路并简化题目非常重要\n使用getline()函数获取长字符串 getline(cin,str)\n主要当 cin&gt;&gt;和 getline()一起使用的时候要使用如下代码删除getline缓存：\n\n int n = 0;\n    cin &gt;&gt; n;\n    string str;\n    getline(cin,str);\n    str = &quot;\\n&quot;;\n    getline(cin,str);\n\n\n比较器函数初识\n\n\nless&lt;类型&gt;表示升序排列[由小到大][^6]\n\n\ngreater&lt;类型&gt;表示降序排列[由大到小]\n\n\nstring也是可以比大小的，会按照字典序来比较大小\n\n\n关闭同步流，获得最速输入输出 ！关闭同步流后cin和cout不能和printf和scanf混用\n\n\nios::sync_with_stdio(0),cin.tie(0),cout.tie(0);[取消同步流]\n\n\n#pragma GCC optimize(2)在文件头添加这个实现O2优化\n\n\n判断一个除法除出来的数是不是整数推荐使用取模法 if((a*c)%b == 0) cout &lt;&lt; &quot;is intnum&quot; (血泪教训见下)\n\n\n神奇函数：在C和 C+++中，toupper 函数用于将小写字母转换为其对应的大写字母。这个函数定义在&lt;cctype.h&gt;或&lt;ctype.h〉头文件中。\n\n\n当某一个数据经常更新(比如说判断max值)我们可以将：\n\nif(i &gt; max0) max0 = i 改为 max0 = max(max0,i)\n同理 ：if(i &lt; min0) min0 = i改为 min0 = min(min0,i)\n\n\n\n结构体在初始化vector&lt;int&gt;这类特殊特殊变量的时候，可以使用显式调用来初始化容器\n\n\n\n  struct st{\n      vector&lt;int&gt; a = vector&lt;int&gt;(6,0);\n  }\n1.printf 和 scanf为格式化输出输入函数\n\n基本语法为\nprintf(&quot;输出控制符&quot;,输出参数)\nscanf(&quot;输入控制符&quot;，输入参数)\n其中常用的输入(输出)控制符有：\n\n\n​     %a(%A)     浮点数、十六进制数字和p-(P-)记数法(C99)\n​      %c             字符\n​      %d             有符号十进制整数\n​      %f              浮点数(包括float和doulbe)\n​      %e(%E)     浮点数指数输出[e-(E-)记数法]\n​      %g(%G)     浮点数不显无意义的零”0”\n​      %i              有符号十进制整数(与%d相同)\n​      %u             无符号十进制整数\n​      %o             八进制整数    e.g.     0123\n​      %x(%X)      十六进制整数0f(0F)    e.g.   0x1234\n​      %p             指针\n​      %s             字符串\n​      %%            ”%”\n\n\n\n                  \n                  Note\n                  \n                \n\n\n\nprintf 和 scanf 都可以支持多位输入(输出)\n\nscanf(&quot;%1d%1d&quot;,&amp;a,&amp;b)就代表输入两个1位数字(两位数)，第一个赋值到a,第二个赋值到b (&amp;为取址符)\n\nscanf 读取字符串的时候不用加寻址符\nscanf不能读取 string str格式的字符串\n\n\n\n\n\n例子：我们可以用 printf&amp;scanf实现数字位数的获取来简化优化程序\n优化前\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    float a = 114.5;\n    cin &gt;&gt; a ;\n    int b = a*10;\n    float c = b%10 + 0.1*((b/10)%10) + 0.01*((b/100)%10) + 0.001*(b/1000);\n    cout &lt;&lt; c;\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n优化后\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    int a;int b;int c;int d;\n    scanf(&quot;%1d%1d%1d.%1d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);\n    printf(&quot;%1d.%1d%1d%1d&quot;,d,c,b,a);\n    system(&quot;pause&quot;);\n    return(0);\n}\n2 取整函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数名称函数说明floor()不大于自变量的最大整数ceil()不小于自变量的最小整数round()四舍五入到最临近的整数fix()朝零方向取整\n\nfloor()朝负无穷方向取整\nceil()朝正无穷方向取整\nround()函数，才是我们需要的四舍五入的函数，因为它会返回离自变量最近的整数，这个返回的整数可能大于也可能小于原来的数，但是一定是离它最近的那个整数。\nfix() 朝零方向取整，正数向下去，负数向上取\n\n\n3 位运算(简单版)\n\ni&lt;&lt;1 等同于 i*2\ni&gt;&gt;1等同于i/2\n\n4 sort()排序函数\n\nsort()可以用一行实现数组的排序，而且可以实现从小到大，从大到小(甚至个位数从小到大之类的排序)的排序\nsort()函数的语法为 sort(begin,end,cmp),其中begin指向待sort数组的第一个元素的指针，end指向待sort数组的最后一个元素的下一个位置的指针\ncmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序\n如果我们想从大到小排序可以将cmp参数写为greater&lt;int&gt;()就是对int数组进行排序，当然&lt;&gt;中我们也可以写double、long、float等等\n例：从小到大\n\nint main()\n{\n    int num[10] = {5,8,9,7,6,8,4,2,7,6};\n    sort(num,num+10);\n    for(int i=0;i&lt;10;i++)\n    {\n\t\tcout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;\n\t}\n}\n例：从大到小\nint main()\n{\n    int num[10] = {5,8,9,7,6,8,4,2,7,6};\n    sort(num,num+10,greater&lt;int&gt;());\n    for(int i=0;i&lt;10;i++)\n    {\n\t\tcout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;\n\t}\n}\n\n==cmp的编写规则==\n\n\ncmp函数的返回值是bool值\ncmp传入的参数为(待排序的第一个类型&amp; a，待排序的第二个类型&amp; b)\ncmp里 return a &gt; b指降序排序 (从大到小)\n\n\n例给无法排序的map排序\n\nbool cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b){\n    return a.first &gt; b.first;\n}\nint main()\n{\n   \tmap&lt;int,int&gt; arr;\n\tvector&lt;pair&lt;int, int&gt;&gt; temp(arr.begin(),arr.end());\n}\n其实cmp的排序可以这么理解：\nbool cmp(const &lt;Type T&gt; &amp;a , const &lt;Type T&gt; &amp;b ){\n    return a &gt; b; //降序排列\n    //......\n}\n\n\n                  \n                  Tip\n                  \n                \n\n\nbool 类型的函数返回的是一个bool值，所以return回去的是一个bool值，传入的参数是 a,b 如果bool值为 1 ，则说明这个a b的顺序无需改变，如果传入的是0，则说明需要改变\n注意：实际上cmp的规则并非如此，当我们不做任何判断直接返回1的话，数组会被倒序排序，而0则是没有任何改变\n\n\n\n5 __gcd求最大公约数函数\n格式：__gcd(a,b)返回值为a，b的最大公因数\n头文件：#include&lt; algorithm&gt;\n实现:\n\n欧几里得算法\n\nint main() \n{\n    int a,b,r;\n    cin &gt;&gt;a&gt;&gt;b;\n    //求x 和 y 的最大公约数，就是求 y 和 x % y 的最大公约数\n    while (a%b!=0) //判断a能否整除b\n    {\n        //开始循环找数\n        //判断余数能否被被除数整除\n        //循环到1\n        r=a%b; \n        a=b;\n        b=r;    \n    }\n    cout &lt;&lt; b;\n    return 0;\n}\n\n还存在一种扩展欧几里得算法，用于求出方程\\gcd(a,b)与方程ax + by = gcd \\left({a,b}\\right) 的一组(x_0，y_0)\n\n6 字符与字符串\n\n字符串本质是一个数组，因此我们可以用str(字符串)[下标]的方式访问字符串的子字符，而下标从”0”开始计数\n字符串的两种表示方式中，scanf()和printf()都无法访问 string str[^3]形式的字符串\n可以用str.size();的方式访问字符串长度(注意字符串最后会存在一个空字符，所以实际长度会比str.size输出的长度多一)\n使用强转函数 to_string可以时整型变为字符串型\n我们可以使用 str.empty()来判断一个字符串是否为空，若为空，该函数会返回一个 True 的bool值，否则返回 False\nstr.clear()可以帮我们愉悦的删掉有效字符(但str.clear不会改变底层空间(capacity)的大小)\n我们可以用 str.capacity()的方式查看字符串的底层空间大小\n\n其实字符串(string类型)采用动态数组作为底层实现，它会为字符串提前预留一些额外的储存空间来减少内存的分配与释放次数\n\n\n\n7 vector 容器 / 动态数组\n\n使用 vector&lt;int&gt; vec[^4]的方式来创建一个动态数组\n对于 vector的赋值，不能直接使用cin &gt;&gt; vec[i] 的方式，我们可以建立一个临时变量，用 vec.push_back(temp)的方法输入值\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n9.17修改 ：对于使用 vector&lt;int&gt; dp(a,b)形式的vec可以使用cin输入\n\n\n\n\n对 vector容器的排序，我们必须使用迭代器来确定其数据位置，不能使用”+“确定位置\n\n\n\n所以我们可以这样输入语法\nsort(vec.begin(),vec.end())\n\n\n使用 vec[i]来获取第 i - 1个元素(从零计数)\n\n8 栈(stack)\n\n栈是一种线性储存结构，其元素遵守先进后出的规则\n只能在栈顶进行元素的添加和删除(进栈和出栈)\n使用stack&lt;int&gt; st创建一个栈\n对栈常见的操作有：\nempty(): 判断栈是否为空栈，如果为空栈返回true， 否则或者false\npush(): 进栈操作，将新的元素放入到栈中，新的元素成为栈顶元素。\npop()： 出栈操作，栈顶元素从栈中离开\ntop(): 获取栈顶元素，但是不会移除它\nsize(): 获取栈的长度，即栈中元素的数量\n\n9 宏常量定义小寄巧\n打勾的就是好用的\n\n  #define endl &quot;\\n&quot;\n #define int long long\n\n\n\n                  \n                  WARNING\n                  \n                \n\n\n使用这个的时候 int main()要改为 signed main()\n\n\n\n\n #define double long double\n\n10 数组前导零与后导零的删除\n\n有的时候我们会用vis记录某一数据的增量和变化，到最后进行增量的排序\n但是这个时候vis里没有在数据范围里的数据就是 0 这给我们sort数组带来极大的困惑\n\nwhile(*arr.begin() == 0) arr.erase(arr.begin);\nwhile(*(arr.end()-1) == 0) arr.erase(arr.end()-1);\n\n我们可以使用这样的代码删除数组中的前后导零\n\n11 位运算抽象版\n\n\n                  \n                  Important\n                  \n                \n\n\n位运算虽然在卡常时可以发挥一些优化作用，但其会导致代码可读性下降至一个难以理解的程度\n\n\n\n\n用位运算代替 *=2 /=2 的操作\n\nint a = 10; (a &lt;&lt;= 2) == (a*=2); (a &gt;&gt;= 2) == (a/=2)\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n对位运算来说，左移右移都是改变二进制位的操作，比如我们可以这么理解\n\\begin{split}\n设某一数x\\\\\nx_2 &amp;= tttttt\\\\\nx &lt;&lt; s &amp;= tttttt\\underbrace{0000 \\ldots 00}_{s}\\\\\n则 x_{10} &amp;= x \\times 2^s\n\\end{split}\n同理，右移就是x_{10} = \\frac{x}{2^s} \n\n\n\n\n用位运算代替swap()\n\n    int a = 5 , b = 2;\n    a ^= b, b^=a, a^=b;\n    //swap(a,b)\n\n\n                  \n                  Tip\n                  \n                \n\n\n^运算，即 **异或(XOR)**运算，比较两个值的二进制位，如果两个值相同，则结果为假，如果两个值相同，则结果为真\n推理：\n\n第一次异或运算：A = A ^ B\n\n这一步将 A 和 B 的值进行异或运算，并将结果存储在 A 中。\n此时，A 包含了 A 和 B 的异或结果，而 B 仍然是原来的值。\n\n\n第二次异或运算：B = A ^ B\n\n由于 A 现在包含了 A 和 B 的异或结果，我们将这个结果与 B 进行异或运算，并将结果存储在 B 中。\n这一步实际上是将 B 的原始值与 A 和 B 的异或结果进行异或运算，这将导致 B 现在包含 A 的原始值。\n\n\n第三次异或运算：A = A ^ B\n\n现在 B 包含了 A 的原始值，我们将 A（包含 A 和 B 的异或结果）与 B（现在包含 A 的原始值）进行异或运算。\n这一步将导致 A 现在包含 B 的原始值。\n\n\n\n\n\n\n\n\n取出二进制的某一位\n  int a = 15;\n  for(int i = 31;i &gt;= 0 ;--i) cout &lt;&lt; (x &gt;&gt; i &amp; 1);\n\n怎么实现的呢？\n从31位开始向前将a的每一个二进制位与 1 做与位操作\n与位操作即：\n\n如果两个比较的位都是1，则结果位是1。\n如果两个比较的位中至少有一个是0，则结果位是0。\n那么与 1 做&amp;操作的二进制位则必然会等于其本身\n\n\n\n\n优化版：\n\n\nvector&lt;int&gt; arr;\nint a = 15;\nfor(int i = 31;i &gt;= 0 ;--i) arr.push_back(a &gt;&gt; i &amp; 1);\nwhile(!*arr.begin()) arr.erase(arr.begin());\nfor(auto &amp;&amp;i : arr) cout &lt;&lt; i;\n\n实现了前导零的删除\n用异或判断两变量是否相等\n\nint a = 10,b = 5;\nif(a^b) cout &lt;&lt; &quot;不相等&quot;；\nelse cout &lt;&lt;&quot;相等&quot;；\n\n使用^48实现int和char的转化\n\nint a = 6;\nchar ch = x^48;\ncout &lt;&lt; ch &lt;&lt; endl;\n//同理char变int也可以用^48\nint y = ch^48;\ncout &lt;&lt; y;\n\n用&amp;1判断函数奇偶性\n\nint a = 7;\nif(a&amp;1)\n{\n\tcout &lt;&lt; &quot;奇数&quot; &lt;&lt;endl;   \n}\nelse\n{\n\tcout &lt;&lt; &quot;偶数&quot; &lt;&lt;endl;\n}\n12 时间函数帮你计算运算时间\nclock_t st = clock();\n//代码......\nclock_t ed = clock();\ncout &lt;&lt; &quot;time: &quot; &lt;&lt; ed - st &lt;&lt;&quot; ms&quot;&lt;&lt;endl; \n13 一组数的各种数计算\n\n对一组数据而言，对其分布有影响的数据类型有: \\to 平均数 ， 中位数\n\n平均数：\nint sum = 0;\nfor(int i = 0; i &lt; arr.size() ; i++){\n    sum += arr[i];\n}\ndouble tnum = (sum/n*1.0);\n中位数：\nvector&lt;int&gt; arr(n);\ndouble cent = 0;\nsort(arr.begin(),arr.end());\nif(arr.size()%2 == 1) cent = arr[n/2 + 1];\nelse cent = (arr[n/2 + 1] + arr[n/2]*1.0)/2; \n//数组从0开始技术的时候，要注意下标减一\nif(arr.size()%2 == 1) cent = arr[n/2 + 1 - 1];\nelse cent = (arr[n/2 + 1 - 1] + arr[n/2 - 1]*1.0)/2; "},"ACM/算法/杂项笔记/杂项练习笔记2(codeforces)(详细ver)":{"slug":"ACM/算法/杂项笔记/杂项练习笔记2(codeforces)(详细ver)","filePath":"ACM/算法/杂项笔记/杂项练习笔记2(codeforces)(详细ver).md","title":"杂项练习笔记2(codeforces)(详细ver)","links":["tags/杂项练习","tags/codeforces","ACM/算法/杂项笔记/杂项练习笔记4(codeforces)(简单ver)","tags/数学","tags/二进制","ACM/算法/二进制","tags/数论"],"tags":["杂项练习","codeforces","数学","二进制","数论"],"content":"杂项练习 codeforces\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n这是对codeforces里不会的题的详细题解,在自己平均水平之上，所以会比较详细\n对于较为简单的题，可以参阅杂项练习笔记4(codeforces)(简单ver)\n\n\n\n\n同时取模两数相等的总个数\n数学\n\n对两个数 x_1,x_2 ，从 0 到 n 的所有数字中，存在 p 使得 p \\mod x_1 = p \\mod x_2 的所有 p 的个数 k 有\n\nk = \\left \\lfloor \\frac{\\left( n+1 \\right)}{\\operatorname{lcm}{(x_1,x_2)}}\\right \\rfloor \\cdot \\min(x_1,x_2) + \\begin{cases} \n(n + 1) \\bmod \\operatorname{lcm}(x_1, x_2) &amp; \\text{if } (n + 1) \\bmod \\operatorname{lcm}(x_1, x_2) &lt; \\min(x_1, x_2) \\\\\n\\min(x_1, x_2) &amp; \\text{otherwise}\n\\end{cases}\n\n可以精简为：\n\nk = \\left\\lfloor \\frac{n+1}{\\operatorname{lcm}(x_1, x_2)} \\right\\rfloor \\cdot \\min(x_1, x_2) + \\min\\left( (n+1) \\bmod \\operatorname{lcm}(x_1, x_2), \\min(x_1, x_2) \\right)\n用代码表示为：\n k = ((n + 1) / lcm(x1,x2)) * min(x1,x2) + min((n+1)%lcm(x1,x2),min(x1,x2))\n\nEducational Codeforces Round 175 (Rated for Div. 2) A\n\n对R1009.D3.C 异或解题思考\n数学 二进制\n\nCodeforces Round 1009 (Div. 3) C. XOR and Triangle \n\n原题目的要求是给定一个数 x ，要求找到一个 y 使得：\n\nx + y &gt; x \\oplus y \\qquad (1)\ny + x \\oplus y &gt; x \\qquad (2)\ny &lt; x \\qquad \\qquad \\quad \\ \\ (3)\n有一个知识点：加法可以用位运算表示，即：\nx + y = \\left(x \\oplus y\\right) + 2 \\left( x\\,\\&amp;\\, y \\right)\n则题式就可以表示为：\n\n\\begin{split}\nx + y &amp;&gt; x \\oplus y \\\\\n \\,\\ \\left(x \\oplus y\\right) + 2 \\left( x\\,\\&amp;\\, y \\right) &amp; &gt; x \\oplus y \\\\\n即:\\left( x\\,\\&amp;\\, y \\right) &amp;&gt; 0\n\\end{split}\n同理，对(2)式有原式：y + (x + y) - 2(x \\&amp; y) &gt; x 即 y &gt; x\\&amp;y\n\n即我们得到条件 \\left( x\\,\\&amp;\\, y \\right) &gt; 0 和 y &gt; x\\&amp;y\n对二进制位分析则不难发现：\n\ny 的二进制位必须包含一个 x 二进制位下的1 → 对应条件 (1)\ny 的二进制位必须包含一个 x 二进制位下的0 → 对应条件 (2)\n\n\n特殊情况分析：\n\n当 x = 2^n 时不存在y\n\nx = 2^n 即x只有最高位为1，此时对任意 y &lt; x 有 x \\&amp; y = 0 , 不符合条件1\n\n\n当 x 为全 1 数时不存在y (根据条件(2)显然)\n实现：\n\n\n对特殊情况，可以使用这个方法判断\n对非特殊情况，可以使用构造，构造y为x的二进制最高有效位-1\n\ny = 1 &lt;&lt; (31 - __bulitiz_clz(x)) - 1\n\n\n\n最大公约数(GCD)相关的优化问题\n数论\n问题\n\n考虑一个数组 A 你可以时数组里的每个元素同时加任意数d ,现在你需要找到数组中任意两个元素 a_i,a_j 使得 \\gcd(a_i,a_j) 最大\n\n正解是当我们选取k 使\nk = \\underset{A}{\\max}\\ a_i \\,-\\underset{A}{\\min} a_j \n\n知识点：对于任意整数 x,y ,有 \\gcd(x,y)|(y-x)\n换句话说，x和y的最大公约数总是能整除他们的差\n则对于任意一组数据a_i,a_j,其\\gcd(a_i + d,a_j + d)不可能大于\\left \\vert a_i - a_j \\right \\vert\n显然最大的\\left \\vert a_i - a_j \\right \\vert 为 \\underset{A}{\\max}\\ a_i \\,-\\underset{A}{\\min} a_j\n接下来，我们利用选取d的机会构造使得\n\n\\gcd(\\underset{A}{\\max}\\ a_i + d \\, ,\\, \\underset{A}{\\min} a_j + d) = \\underset{A}{\\max}\\ a_i \\,-\\underset{A}{\\min} a_j \n我们记\\underset{A}{\\max}\\ a_i = M \\,,\\underset{A}{\\min} a_j = m\n\n则我们构造一个d使得m + d \\equiv 0\\, \\left( \\mathrm{mod}(M-m)\\right) ,换句话说，我们得找到d使得m + d是M-m的倍数,则此时 M + d也为M-m的倍数\n换句话说，d  一定是存在且非负的\n以上，证明完毕\n\n\n来源：Codeforces Round 1014 (Div. 2) A. Kamilka and the Sheep\n\n数论之质数和gcd与lcm\n数论\n问题：\n给你一个整数 n ，存在两个数a,b满足 1 \\leq a &lt; b \\leq n 现在，我们称:\nF\\left(a,b\\right) = \\frac{\\mathrm{lcm}(a,b)}{\\gcd(a,b)}\n若 F(a,b) 为质数，则我们称这个数对是”有趣的”,现在我们想知道在满足1 \\leq a &lt; b \\leq n的条件下有多少”有趣的”数对\n思路：\n\n数论基础知识：a \\cdot b = \\gcd(a,b) \\cdot \\mathrm{lcm}(a,b)\n我们不妨将F(a,b)上下同乘\\gcd(a,b) 得到 F(a,b) = \\frac{a \\cdot b}{\\gcd^2{(a,b)}}\n设 x = \\gcd(a,b) \\cdot a \\ ,\\ y = \\gcd(a,b) \\cdot b\n现在F(a,b) = x \\cdot y\n因为F(a,b)为质数，即x \\cdot y为质数，根据质数性质，x,y必须是一个质数乘1\n\n因为 a &lt; b 且 x = \\gcd(a,b)\\cdot a 则 x = 1\n那么 y 为质数\n\n\n那么接下来，问题变为:\n\n计算数对(a,b) 中 a \\le \\gcd(a,b) &lt; \\gcd(a,b) \\cdot y \\le n 的数对\n\n\n我们将每个小于n质数y固定下来，\\gcd(a,b)则可以取1到\\left \\lfloor \\frac{y}{n} \\right \\rfloor的数\n即对于每个y,有\\left \\lfloor \\frac{y}{n} \\right \\rfloor个数对符合要求\n\n在 n \\le 10^7的数量下，必须先用埃式筛或欧拉筛提前准备质数数组，可以在最优O(N + \\pi(M)) 下完成\n\n其中N表示题目最大数据量，M表示测试数据最大数量\n其中\\pi(M)表示小于M的质数数量\n来自：CR1013 d3 E\n\n二分搜索技巧\n\n背景：\n给定数组 A,B ，对A里的每个元素a_i我们可以做下面这个操作：\n\n在B中选择一个元素b_j，使得 a_i&#039;= b_j - a_i\n问能不能实行若干次操作将数组A变为非递减序列\n\n\n思路：\n\n我们先对数组B进行排序，以便后续二分查找\n对与每个a_i我们希望其在操作后尽可能的小，以便后续成立\n对每一个a_i 我们的任务是找到一个最小的b_j使得b_j - a_i \\ge a_{i-1}\n二分上，我们使用\n\nlower_bound(iterator_1,iterator_2,T,cmp)\n\n对于这个传函数式的传参，返回的是第一个为flase的值\n\n则我们使用：\nlower_bound(all(b),-14,[](int k1,int k2){\n\treturn k1 - a[i] &lt; a[i-1];\n})；\n因为b数组已被排序，此时返回的就是b中不符合b_j - a_i &lt; a_{i-1}的最小的b_j 即满足b_j - a_i \\ge a_{i-1} 的最小的b_j ,而这正是我们所需要的\n\n对于每一个a_i 如果找不到b_j 则跳过\n如果原本a_i &lt; a_{i-1} 且操作后仍 b_j - a_i \\ge a_{i-1} 则是无解的，跳过\n其余则考虑在b_j - a_i 与 a_i 中找最小值\n最后检查排序即可，这里可以使用is_sorted函数\n来自：\nCR1003 d4 C_2\n\n贪心前缀和\n\n你有一个长度为n的数组A ,你现在可以执行下面操作直到数组为空\n\n选择一个数 a\n\n如果是 a_i&lt;0 ，则用 [a_1,a_2,\\ldots,a_{i - 1}]替换替换A(即删除以a_i开头的后缀)\n否则，将 A 替换为 [a_{i+1},a_{i+2},…,a_m] (即删除以 a_i 结尾的前缀)\n\n\n每次选择数时将数|a|加入分数中\n我们需要最后分数最大\n\n\n我们发现，每一次都是删除最左边的正数元素或删除最右边的负数元素从而获得最高的分数\n则我们依据正数和负数构造两个数组表示前缀和后缀，而这些前后缀只对其对应符号的数生效\n我们的答案就是找到么某个点使得其前缀加后缀最大\n并查集策略\n来自ECR117 d2 C\n\n\n你有一个长度为 n 的 排列数组 p，也就是说它包含了从 1 到 n 的所有整数，且不重复。\n接下来你会收到 n 个 查询，每个查询会把数组中某个位置的元素替换成 0(每个位置只会被替换一次)\n在每次查询之后，你要判断：最少需要多少次操作，才能把当前这个数组恢复成一个合法的排列（包含 1 到 n，每个数恰好一次）。\n允许的操作是：对于 1 \\sim n 中的任意一个数 i，可以 将数组的第 i 个位置的值替换成 i\n\n\n\n思路：\n\n假设我们缺失的数字为P_{d_i},我们知道最终的排列一定包含该数字，且该数字只能被放置在P_{d_i},则P_{P_{d_i}}的数字可能被丢失，而该数字也必须被包含在排列中，以此类推。当一个数被放置在已经缺失数的位置上时候，该过程结束\n\n\n我们只关心有哪些数会在一次修复中被涉及，我们考虑使用并查集或集合模拟\n这里给出使用集合模拟的解决方法：\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vint v(n);\n    for (auto &amp;&amp;i : v) {\n        cin &gt;&gt; i;\n        i--;\n    }\n    set&lt;int&gt; x;\n    for (int i = 0; i &lt; n; i++) {\n        int d;\n        cin &gt;&gt; d;\n        d--;\n        while (!x.contains(d)) {\n            x.insert(d);\n            d = v[d];\n        }\n        cout &lt;&lt; x.size() &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}\n\n其中核心操作为15-17行的操作\n\n维护一个集合X表示所有需要固定的位置\n输入其查询数字P_{d_i},查询P_{d_i}是否在集合X中\n若存在，说明已经有该位置，可以则输出集合大小\n若不存在，则说明X中一定会增加P_{d_i}这个位置\n\n此时将 P_{d_i} 赋值为 d_i 表示查询P_{d_i}的位置，直到可以在集合X中找到为止\n\n\n因为每一次的丢失会继承到下一次查询中，所以不需要清空集合\n若使用思路也是一样的，将P_{d_i} 与 d_i 设置在一个集合中并且赋值，知道可以在集合中找到P_{d_i}\n\n\n\n差分序列与反转下的最大值\n来自：\nCR1001 d1+2 C\n\n有一个数组 A  长度为 n ,可以执行任意次下面的两个操作\n\n反转数组\n用差值序列替换序列。形式上，操作后[a1,a2,…,an] 变为[a2−a1,a3−a2,…,an−an−1] \n你需要求所有运算后a中元素的可能的和的最大值\n\n\n思路：\n\n对操作(1),反转后不会对数组和产生任何影响\n对操作(2),构造一个差序对数组\\Delta A = [a_2​−a_1​,a_3​−a_2​,\\cdots,a_m​−a_{m−1}]\n\n显然对\\sum (\\Delta A) = a_m - a_1\n倘若我们先执行一遍操作(1) ,则\\sum (\\Delta A&#039;) = a_1 - a_m = -\\sum (\\Delta A)\n\n\n若对 A 执行 k 次差分(其中可以自由执行操作(1)来构造最大值)，最终得到的序列长度为 n - k,其元素和正好为其元素和恰好是原序列经过 k 次差分的总和,即S^{(k)} = \\underset{i = 1}{\\overset{n-k}\\sum}v_i\n\n证明1\n\n\n则我们选择k \\in \\{0 \\sim n-1\\}的\\max(S^{(k)})即可，特别的S^{(0)} = \\underset{i = 1}{\\overset{n}\\sum}a_i\n对于代码实现，直接模拟就可以\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vint v(n);\n    for (auto &amp;&amp;i : v) {\n        cin &gt;&gt; i;\n    }\n    int ans = accumulate(all(v), 0);\n    vint cur = v; //构造差序对数组\n    for (size_t i = 1; i &lt; n; i++) {\n        int m = cur.size();\n        int sum = 0;\n        vector&lt;int&gt; nxt(m - 1); // 下一个差序对数组\n        for (size_t k = 0; k + 1 &lt; m; k++) {\n            nxt[k] = cur[k + 1] - cur[k];\n            sum += nxt[k];\n        }\n        ans = max(ans, abs(sum));\n        cur.swap(nxt);\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n标答很简洁但是我写很多的难绷题目\n\n来自CR1022 d2 C\n\n题目大意:\n\n你有一个数组A，你可以选择一个数字放下标识\n\n这个标识可以左右移动\n当标识经过一个没有被标识经过的数时候就会将这个数加入到数组B中\n\n\n我们需要数组B按单调递减排序且B含有A的所有元素\n求最少需要放几个标识\n\n我的思路：\n\n先将数组A排序为数组B，再根据B的顺序去找A中的元素\n其中找到第一个元素向左右扩散直到遇见上升数(即a_i &lt; a_{i+1})，将这些数加入mp和path中\n\n其中mp表示当我们在B遇到某个数时，该数有没有已经处于一个标识可以达到的集合之中，用map&lt;int,int&gt;记录\npath表示该坐标有没有被走过\n\n\n考虑到时间复杂度，必须使用很离谱的优化：即将数组A的数组与下标都保存在一个map中\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vint a(n);\n    for (auto &amp;&amp;i : a) {\n        cin &gt;&gt; i;\n    }\n    vint vs = a;\n    ranges::sort(vs, greater&lt;int&gt;{});\n    //抽象优化技巧之把v[i]和其对应的下标存入map中\n    map&lt;int, vector&lt;int&gt;&gt; v_index;\n    for (int j = 0; j &lt; n; ++j) {\n        v_index[a[j]].push_back(j);\n    }\n    //为每个权重记录了下一次我们应该从 v_index[i] 向量的哪个位置开始查找\n    map&lt;int, size_t&gt; next_idx_ptr;\n    map&lt;int, int&gt; st;\n    vint path(n, 0);\n    int ans = 0;\n    for (auto &amp;&amp;i : vs) {\n        if (st[i] &gt; 0) {\n            st[i]--;\n            continue;\n        }\n        //这个idx表示我们55行后面操作的下标\n        int idx = -1;\n        if (v_index.count(i)) {\n            // 取当前数的所有下标集合\n            vint &amp;vi_idx = v_index[i];\n            // 取这个数下标集合中进行到多少个下标\n            size_t &amp;now_idx = next_idx_ptr[i];\n            while (now_idx &lt; vi_idx.size()) {\n                // f_inx 代表我们要找的第下标的实际值\n                // 该下标应该满足path[idx] != 0\n                int f_idx = vi_idx[now_idx];\n                // 当我们找到符合的下标的时候退出\n                if (path[f_idx] == 0) {\n                    idx = f_idx;\n                    now_idx++;\n                    break;\n                }\n                now_idx++;\n            }\n        }\n        // 为什么要做上面这一步？\n        // 我们需要排除出现找10时候出现[... 10 10 ...] 这样的情况\n        if (idx != -1) {\n            ans++;\n            path[idx] = 1;\n            for (int k = idx; k + 1 &lt; n; ++k) {\n                if (a[k] &gt;= a[k + 1] &amp;&amp; path[k + 1] == 0) {\n                    path[k + 1] = 1;\n                    st[a[k + 1]]++;\n                    continue;\n                }\n                break;\n            }\n            for (int k = idx; k - 1 &gt;= 0; --k) {\n                if (a[k] &gt;= a[k - 1] &amp;&amp; path[k - 1] == 0) {\n                    path[k - 1] = 1;\n                    st[a[k - 1]]++;\n                    continue;\n                }\n                break;\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl; \n}\n答案思路：\n\n其实从上面我的思路中就可以优化两点\n\n连续的相同数字不影响结果\n我们实际上找的是极大值点的数目\n则非常简单的就可以出来\n\n\n\nvoid solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tvint v;\n\tv.emplace_back(-1e9);\n\tfor(int i = 0; i &lt; n ; i++){\n\t\tint t = 0;\n\t\tcin &gt;&gt; t;\n\t\tif(t != v.back())v.emplace_back(t);\n\t}\n\tv.emplace_back(-1e9);\n\tint ans = 0;\n\tfor(int i = 1; i + 1 &lt; v.size() ; i++){\n\t\tif(v[i] &lt; v[i + 1] &amp;&amp; v[i] &gt; v[i - 1]) ans++;\n\t}\n\tcout &lt;&lt; ans &lt;&lt; endl;\n}\n一种很新的贪心 — 延迟决策与追溯修改\n来自CR 1026 d2 C\n\n大意:\n你有一个飞行器，其起始高度h_0 = 0，同时给你一个操作数组 d , d 中存在两种操作可能，分别是：\n\n保持不动(0) → h_{i+1} = h_i\n向上移动一位(1) → h_{i+1} = h_i + 1\n其中还存在特殊操作 -1,代表你可以自己决定其保持不动还是上升\n\n现在给你一些障碍，障碍的表现形式使用 l_i,r_i 给出，当飞行器高度l_i \\leq h_i \\leq r_i 时候，飞行器可以穿过障碍\n操作从0起始，现在我们想知道能不能穿越所有障碍，如果不行输出-1,如果可以，输出整个操作数组d\n\n核心思路：延迟决策与追溯修改\n\n\n我们维护两个数组L，R表示h_i目前可以到达的可能的高度\n\n\n维护一个栈sk保存出现-1的情况[主要保存的是idx]\n\n\n对每一个障碍我们做如下判断\n\n\n当d_i \\neq -1时，直接根据d_i改变h_i\n\n\n否则，将i，即idx存入栈中\n\n\n当h_i \\notin [L,R] 时候\n\n当h_i &lt; L_i时候，表示当前飞行器在不”人为干预”的情况下会撞到下障碍\n\n我们关注栈的状态，如果栈处于空，则直接输出-1,表示我们在之前已经没有多余的操作数去影响现在的h_i\n否则我们将栈中元素对应的idx的-1修改为1,并弹出栈顶表示飞行器向上移动一位\n\n\n当h_i + sk.\\text{size}() &gt; R_i时候，表示如果我们之前-1全设定为1时候会大于上障碍\n\n我们同样关注栈状态，如果栈空,直接输出-1，这表示我们没有办法通过前面的-1去降低h_i\n否则我们将栈中元素对应的idx的-1修改为0,并弹出栈顶,表示飞行器在之前假设最大高度下降一格\n\n\n\n\n\n最后我们输出数组d,注意要输出max(0,i)  因为到最后栈内元素不保证为空，则是我们不去控制即可，全部以0输出\n\n\n\n\n                  \n                   延迟决策与追溯修改\n                  \n                \n\n\n\n对于这样的贪心思路，我们先储存操作可能，在需要操作的时候返回去修改操作的可能，我们称之为延迟操作与追溯修改\n这是一个非常不错的贪心思路，在这类需要全局操作和后面情况会对前项造成影响的时候可以尝试\n\n\n\n\nFootnotes\n\n\n如果你连续做 k 次差分，那么等价于先做一次差分得序列 \\Delta v，再对它做一次差分 \\Delta^2 v，……，直到 \\Delta^k v。而每一步差分的“和”都只剩下“前者首尾之差”这种形式，所以对第 k 次差分：\n \\sum (\\Delta^k v) = (\\Delta^{k-1} v)_{\\text{末}} - (\\Delta^{k-1} v)_{\\text{首}}\n在最后一步我们依旧可以翻转来取正负号，于是对第 k 次差分所能得到的和，就是\n\\sum (\\Delta^k v) =\\pm \\left[ (\\Delta^{k-1} v)_{\\text{末}} - (\\Delta^{k-1} v)_{\\text{首}} \\right]\n而对于(\\Delta^{k-1} v)_{\\text{末}} 与 (\\Delta^{k-1} v)_{\\text{首}} 我们也可以用递归的方式展开，最终即可证明 ↩\n\n\n"},"ACM/算法/杂项笔记/杂项练习笔记3":{"slug":"ACM/算法/杂项笔记/杂项练习笔记3","filePath":"ACM/算法/杂项笔记/杂项练习笔记3.md","title":"杂项练习笔记3","links":["tags/杂项练习","ACM/算法/二分"],"tags":["杂项练习"],"content":"杂项练习\n两个数组大小(字典序比较)\n描述：\n我们称序列 \\{ a_1​,⋯,a_n​ \\} 比序列 \\{ b_1​,⋯,b_n​ \\} “小”，如果存在1\\leq k \\leq n 满足 a_i = b_i​ 对所有 i&lt;k 成立，且 a_k​ &lt; b_k​。\n核心规则是：\n\n从第一个元素开始逐项比较两个序列的对应位置；\n若在第 k 个位置首次出现 a_k \\ne b_k​，则通过 ak​ 和 bk​ 的大小关系直接判定整个序列的大小（ak​&lt;bk​ 时序列 {ai​} 更小）；\n若所有对应位置均相等，则较短的序列视为更小（但题目中隐含比较的序列长度相同）。\n\n代码实例：\n//通过cmp函数返回sort的cmp值\n//排序的是较小数组放前方\n \nbool cmp(vector&lt;int&gt; a , vector&lt;int&gt; b)\n{\n\tfor(int i = 0; i &lt; min(a.size(),b.size()) ; i++){\n\t\tif(a[i] != b[i]) return a[i] &lt; b[i];\n\t}\n\treturn a.size() &lt; b.size();\n}\n//返回的cmp参数会使sort函数由大到小排列\n \nbool cmp_big(vector&lt;int&gt; a,vector&lt;int&gt; b)\n{\n\tfor(int i = 0; i &lt; min(a.size(),b.size()) ; i++){\n\t\tif(a[i] != b[i]) return a[i] &gt; b[i];\n\t}\n\treturn a.size() &gt; b.size();\n}\n最大连号数问题\n题目描述见最大连号数问题，在二分章节，我们介绍了一种O(\\log n)的解法，现在我们介绍一种O(1)的解法\n\n要使最大的连号数最小，我们将尽量均分每个连号数\n当我们将k个人分成尽可能多的段时，每段之间的空房间可以有效减少最大连号数。最多可以分割的段数为m = n - k + 1，因为每段之间至少需要一个空房间\n则最大连号数为 \\left \\lceil \\frac{k}{n-k+1} \\right \\rceil\n代码表示则为ans = ceil((k*1.0)/(n-k+1))\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\nceil在很高精度下会有精度丢失，我们用整数除法代替取整函数\n\\lceil \\frac{a}{b} \\rceil = \\lfloor \\frac{a+b-1}{b} \\rfloor\n即ceil((a*1.0)/b) == (a+b-1)/b\n\n\n\n\n数论(平方差)\n\n给定一个数 k ,对任意正整数 y\\,,\\,x \\quad (y \\ge x) 若 k\\mod 4 = 2,则k \\ne y^2 - x^2\n\n扩展 费马定理\n\n给定一个数 k ,存在正整数 p , q 使 k = q^2 + p^2 ,k 的存在定理：\n\n若k的所有质因数分解的为A 如果有其中元素 a_i \\mod 4 = 3 且该元素的指数幂次为偶数，则证明该数可以被平方和构造\n\n\n使用下面代码，能帮助我们在 O(\\sqrt{n})时间复杂度下检查某一个数是不是平方和数\n\nbool checkpowersum(int n)\n{\n\tunordered_map&lt;int,int&gt; nprime;\n\tfor(int i = 2 ; i &lt;= n/i ;i++) {\n\t\twhile(n % i == 0) {\n\t\t\tnprime[i]++;\n\t\t\tn /= i; \n\t\t}\n\t}\n\tif(n &gt; 1) {\n\t\tnprime[n]++;\n\t}\n\tfor(auto &amp;&amp;[prime,num] : nprime){\n\t\tif(prime % 4 == 3 &amp;&amp; num % 2 != 0){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n方法(方差与二分)\n对一组数据我们对其方差有：\nD(x) = E(x^2) -E^2(x) \n对于一组数据我们快速计算其方差就可以用前缀和的方式提前算好E(x)和E(x^2)\n数论2^n的最高位为k时n的取值\n当n满足下述方程时成立，方程表现形式如下\n\\left\\lfloor \\{n \\cdot \\log_{10} 2\\} - \\log_{10} k \\right\\rfloor = 0 \n其中\\{x\\}表示取x小数部分,\\left\\lfloor x \\right\\rfloor表示对该数向下取整\nPoof：\n推论1 ：对一般整数p = k^n，其最高位表示为\\left\\lfloor10^{\\{n\\log_{10}k\\}}\\right\\rfloor\nPoof_1:\n对p = k^n两边同时取10的对数:\n\\log_{10}​p=n\\log_{10}​k=m+f\n其中 m=⌊n\\log_{10}​k⌋ 为整数部分，f={n\\log_{10}​k}\\in[0,1) 为小数部分\n则p = k^n可以被分解为\np = k^{m + f} = k^m \\, \\cdot \\, k^f\n显然 f = \\{n\\log_{10}k\\}, 且k^m为一个10的次幂整数，而且我们不难得出k^f \\in [0,10)\n所以\\lfloor k^f \\rfloor即为最高位的数字\n推论1得证\n则我们可以得到 2^n = \\left\\lfloor10^{\\{n\\log_{10}2\\}}\\right\\rfloor\n拆去取底有\n\\begin{split}\n\\iff &amp;k \\leq 10^{\\{n\\log_{10}2\\}} &lt; k+1 \\\\\n\\iff &amp;\\log_{10}k \\leq \\{n\\log_{10}2\\} &lt; \\log_{10}{(k+1)} \\\\ \n\\iff &amp; 0 \\leq {n\\log_{10}2} - \\log_{10}k &lt; \\log_{10}{(k+1)} - \\log_{10}k \\\\\n\\iff &amp;\\left\\lfloor \\{n \\cdot \\log_{10} 2\\} - \\log_{10} k \\right\\rfloor = 0 \n\\\\\n&amp;&amp;\\mathcal{Q.E.D.}\n\\end{split}"},"ACM/算法/杂项笔记/杂项练习笔记4(codeforces)(简单ver)":{"slug":"ACM/算法/杂项笔记/杂项练习笔记4(codeforces)(简单ver)","filePath":"ACM/算法/杂项笔记/杂项练习笔记4(codeforces)(简单ver).md","title":"杂项练习笔记4(codeforces)(简单ver)","links":[],"tags":[],"content":"\n\n命名采用标准 [比赛简名] + [div.x] + [x题]\nCR: Codeforces Round\nECR: Educational Codeforces Round\n\n\nCR1012 d2 B\n\n对这题我们发现，当某一个位置是1的时候，这个1必须到最上方或者最右方是连通的，我们只需要实现这个查询就可以了\n\n我们在读入数据的时候多开两个数组用于记录这个数与前一个数和上一个数的连通性，即\nvx[i][j] += vx[i][j - 1] + vv[i][j];\nvy[i][j] += vy[i - 1][j] + vv[i][j];\nvv是输入数组\n则我们在查询的时候就可以查询这个数组该位置的值是否是i(j)来判断是不是到最右侧是连通的\n\n\n\n\nCR1004 d2 B\n通读题目发现我们需要将两个包内的数字一致，初始B包为空，我们可以进行如下操作\n\n将A包的一个数移动到B包\n在A包选择B包中有的数使该数 值+1\n\n思路：\n\n我们维护一个map，存下每个数出现的个数\n从最大值开始沿整数遍历到最小值\n对于遍历的每一个数i，我们设一个 ck 用于计算和保存需要多少 i - 1：\n\n检查 mp[i] - ck\n\n若其大于 0 ,表示该数足以填补前面所有需要的数，则将ck归零，mp[i]减去ck;\n然后计算mp[i] 能不能被二整除,不行的话则将 ck + 3\n若不大于零，则需要下一个数进行补充\n\n我们发现若要达到A，B袋子平衡态，则需要3个 k → k+1 和 1 个k+1才能达到\n若我们需要两个 k+1 ,则只需要多加一个 k 就行(即4个k)，因为本身已经处于平衡态，不需要额外的 k 保证平衡\n\n\n则新 ck 为 原ck - mp[i] - 1 + 3\n\n\n\n\n遍历完成后检查 ck 是否大于0,大于零则说明不够形成平衡态，输出 No 即可\n\n\nCR1007 d2 B\n\n题目需求是让我们求一个长度为n的排列，这个排列前的\\{1,2,3,\\cdots,n\\}项的和都不能是平方数\n\n显然对一个长度为n的排列的和 S = \\frac{n(n+1)}{2} ，若该S为平分数，则长度为n的序列一定不能被构造出来\n我们考虑长度不为n的排列，先从1～n进行排列，若其中某下标k满足上面的平分构造，则我们交换 a_k,a_{k+1}\n\n而对于交换后是否一定满足其前缀和为平方数？我们可以这样理解，对于最小的两个平方数差为 4 - 1 = 3，而交换两个相邻数，前缀和+1，小于最小平方数之差。\n\n\n\n\n输出构造完毕的排序即可\n\n\nECR176 d2 B\n\n对长度为 n 的数组 A 有k次操作选择 A 中的数，在根据这些数为原点任意扩散，我们需要知道选择的k个数和选择完毕扩散到的最后一个数的值的最大情况\n\n显然当 k &gt; 1 时候，我们扩散到的最后一个数可以是选择后数组中的任意一个数，则我们只需要选择前k + 1大的数做和即可\n当k = 1时，我们注意到A序列两端中必有一端是最后被扩散的数，则我们只需要取除去两端外最大的数和两端中最大的数即可\n\n\n\n\nCR1019 d2 B\n\n贪心思路\n\n先在字符串加前缀”0”方便后续操作\n在字符串里寻找 “01” 与 “10” 并分别计数\n若不改变字符串，操作数为 n + cnt01 + cnt10\n当 “10” 数量与 “01” 数量之和小于2时候，直接计数即可\n否则看是否有字符串的数量大于 2 ，如果存在操作数就 -2，否则 -1\n\n\n\n\nCR1005 d2 B\n\n贪心 + 双指针\n\n我们需要寻找数组中最长的且数字只出现一次的子序列\n维护一个map用来保存数字出现几次\n在map为1的数下查找最长的子序列\n注意不要忘记当所有数字出现次数都大于2时候输出0\n\n\n\n\nCR998 d3 D\n\n贪心\n\n显然当数组已经排序时可以通过操作\n对每一次操作，都会将\\{a_i,a_{i+1}\\}变为\\{0,a_{i+1} - a_i\\}或\\{a_i - a_{i+1},0\\},显然后者是不可取的\n因为构造出的第一个数是0，则我们若想一个非已经排序数字的开头开始按题目要求向后构造\n\n从第一个构造到最后一个，倘若可以形成非递减序列，则最后数组形式一定为\\{0,0,0,\\cdots,0,x\\}形式，则检查最后数组是否排序即可\n\n\n\n\n\n\nCR997 d2 B\n\n图与排序\n\n根据题目含义，我们可以知道，图中两个定点元素有边，则说明小的元素的下标值一定小于大的元素\n则根据这一点，我们可以先确定一个排序[\\,n\\,,\\,n-1\\,,\\,\\cdots \\,\\,2\\,,\\,1\\,] 然后从第一个元素出发，如果发现该元素比其小的元素有边，说明这个元素下标应该比有边的元素大\n\n整个排序过程可以使用类似快速排序的思想完成\nlambda = [&amp;]( int a , int b ){ return (mp[a][b] == 1 ? a &lt; b : a &gt; b)};\n\n\n\n\n\n\nECR178 d2 D\n\n这种题目属于典型的看了答案大彻大悟，不看答案一头雾水\n\n我们理解题目限制1,即我们操作后的元素和不能大于原数组和\n现在考虑一个理想数组的特性，一个大小为n的理想数组的和的最小状态应该是前n项质数组成的数组\n则我们只需要知道原数组和是质数数组前缀和的第几项就可以了\n\n但是直接做前缀可以有超时风险，我们可以先由大到小排序给定数组，在加和给定数组和质数数组，每一次加和的时候进行比较sumv &gt;= sump ? ans = i + 1 :\n最终答案便是 n - ans\n\n\n\n\n\n"},"ACM/算法/树状数组(BIT)":{"slug":"ACM/算法/树状数组(BIT)","filePath":"ACM/算法/树状数组(BIT).md","title":"树状数组(BIT)","links":["线段树","ACM/算法/前缀和与差分"],"tags":[],"content":"树状数组是一种支持单点修改和区间查询的，代码量小的数据结构,在这里我们可以理解为线段树的简化版本\n\n树状数组对单点修改和区间查询的时间复杂度都为O(\\log n)\n对于前缀和，树状数组在更新值的时候\n\n引入\n\n对于数组 A 其中元素为 [a_0,a_1 \\cdots a_n]\n有q次询问，每次询问可能涉及两种操作\n\n对 a_i 加 k\n给定区间[\\,l,r\\,]，求区间和\n\n\n\n\n对数组A，我们朴素的使用前缀和也可以实现上面的两个操作，但是对于询问次数特别多且n特别大的时候，前缀和在修改的O(n)时间复杂度就不能满足题目要求\n\n\n我们试想，将A的每个元素两两加和得到一个新的A&#039;，对A&#039;做操作这样我们需要查询和修改的n就变为了 \\frac n2\n\n\n我们继续重复以上步骤，将每次的A&#039;的元素都两两加和\n\n\n最终我们会得到下面的一幅图：\n\n\n\n我们发现在我们进行修改和区间和的时候，有些元素是完全不会被用上的\n\n即：每行的第偶数个元素都是没必要的\n比如我们需要计算 [\\,1,3\\,] 的区间和，我们只需要计算最下面数组的a_3 + 倒数第二行的 a_1 即可。其余的都证明\n\n\n\n所以我们将从上到下每个数组偶数个元素删去\n\n\n\n发现剩下的数据正好有n个,即我们的新数组可以表示为一个为长度n的新数组，即树状数组\n\n\n数组中的每一个元素，都代表莫一个区间\n\n\n\n则我们可以在这个新的数组中了解树状数组两个操作，即单点修改和区间查询\n\n\n那我们如何查找每个元素对应的区间呢？\n\nlowbit(i)函数，这个函数会返回数 i 最后一位二进制为1的数对应的数 如 5 = (101)_2 则 lowbit(5)= (1)_2 = 1\nlowbit(i){ return i&amp;(-i);\n我们发现对上图的每个元素下标 i ,\\mathrm{lowbit}(i) 即为从下到上的区间位置和区间长度\n也就是说，序号为i的序列正好就是长度为lowBit(i)且以i结尾的序列。\n\n\n\n回到引入题目，我们现在需要构建一个树状数组，那我们从树状数组的单点修改入手：\n单点修改\n\n当我们想要修改某一个数的时候，我们需要找到包含这个数的所有区间\n\n而树状数组的性质告诉我们，某一个序列上方的序列在树状数组的下标中为：b[i&#039;] = b[i+\\mathrm{lowbit}(i)\n则我们只需要不断的向上累加直到超过长度就可以了\n\n\n\n\n// 在i位置加k\nvoid add(int i,int k)\n{\n\twhile(i &lt; N){\n\t\tb[i] += k;\n\t\ti += lowbit(i);\n\t}\n}\n\n而对于初始化，我们只需要一开始设置一个长度为n，初始值0的数组,将每个i位加上元素值即可\n\nvoid init()\n{\n\tfor(int i = 1 ; i &lt;= n ; i++) add(i,v[i]);\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n我们约定俗成的规定树状数组的下标由1开始，避免lowbit(0)的死循环问题\n\n\n\n区间查询\n\n树状数组能够做到的是对求到i的前缀和，而根据数上前缀和的原理，我们便可以求解区间\n\n前缀和的求解非常简单，只需要求i位置对应的区间及其前面的区间即可，可以用lowbit定位到每一个区间\n\n\n\nint getsum(int i)\n{\n\tint cnt = 0;\n\twhile(i &gt; 0){\n\t\tcnt += b[i];\n\t\ti -= lowbit(i);\n\t}\n\treturn cnt;\n}\n\n而对于区间求和就可以使用数上前缀和的方法ans = sum[r] - sum[l-1]\n\nint range_sum(int l ,int r)\n{\n\treturn getsum(r) - getsum(l-1);\n}"},"ACM/算法/桶排序":{"slug":"ACM/算法/桶排序","filePath":"ACM/算法/桶排序.md","title":"桶排序","links":["tags/哈希","tags/排序"],"tags":["哈希","排序"],"content":"哈希 排序\n桶排序\n\n有一种排序方式可以很快的对数字进行排序\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main() \n{\n    int arr[11];\n    for (size_t i = 1; i &lt;= 10; i++)\n    {\n        int a;\n        cin &gt;&gt; a;\n        arr[a]++; \n    }\n    for (size_t j = 0; j &lt;= 10; j++)\n    {\n        if (arr[j] != 0)\n        {\n            for (size_t i = 1; i &lt;= arr[j]; i++)\n            {\n                cout &lt;&lt; j &lt;&lt;&quot; &quot;;                \n            }\n        }\n    }\n    \n    return 0;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n\n在使用桶排序解决实际题目的时候，一定要注意初始开始值\n点名表扬洛谷 [P5729 【深基5.例7】工艺品制作]\n\n\n\n\n\n\n                  \n                  Note\n                  \n                \n\n\n\n桶排序的思想可以用在需要标记类的题目上，例如洛谷 [P1047 [NOIP2005 普及组] 校门外的树] [P5729 【深基5.例7】工艺品制作]\n\n\n\n"},"ACM/算法/深度优先搜索-DFS":{"slug":"ACM/算法/深度优先搜索-DFS","filePath":"ACM/算法/深度优先搜索 DFS.md","title":"深度优先搜索 DFS","links":["tags/递归与递推","tags/搜索","tags/模板","ACM/算法/递归"],"tags":["递归与递推","搜索","模板"],"content":"递归与递推 搜索 模板\nDFS 深度优先搜索\n\n题目来源：P1036 [NOIP2002 普及组] 选数\n题目核心:\n\n\n[NOIP2002 普及组] 选数\n题目描述\n已知 n 个整数 x_1,x_2,\\cdots,x_n，以及 1 个整数 k（k&lt;n）。从 n 个整数中任选 k 个整数相加，可分别得到一系列的和。例如当 n=4，k=3，4个整数分别为 3,7,12,19 时，可得全部的组合与它们的和为：\n3+7+12=22\n3+7+19=29\n7+12+19=38\n3+12+19=34\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n有别于传统模拟，这种在N个数里找k个数的操作，正常人应该都不会想到使用 循环 或 枚举 但受限于知识则停滞不前\n其实思路很简单，选多少个数就建立多少个标记，然后从某一标记开始移动，将所有标记过的数加和即可\n问题是，怎么使用代码实现？\n\n\n\n\n\nDFS:深度优先搜索\n这时候就需要用到递归搜索了。\n该类搜索算法的特点在于，将要搜索的目标分成若干「层」，每层基于前几层的状态进行决策，直到达到目标状态。\n\n先看核心代码\nvoid dfs(int m, int sum, int startx){\n    if(m == k){\n        if(isprime(sum))\n            ans++;\n        return ;\n    }\n    for(int i = startx; i &lt; n; i++)\n        dfs(m + 1, sum + a[i], i + 1);\n    return ;\n}\n\n前置知识：每次递归调用dfs时，都会创建一个新的栈帧，并将m + 1、sum + a[i]和i + 1作为参数传递给dfs函数。当dfs函数执行到return语句时，它会返回到上一个栈帧，也就是上一次调用dfs的地方\n\n\n例子\n\n\n\n让我们用一个简化的例子来说明DFS算法的运行原理。假设我们有一个数组 a = [1, 3, 5, 7] 和 k = 2，我们要找出所有长度为2的子数组，其和为素数\n\n\n 开始\n  |\n  v\n dfs(0, 0, 0)  &lt;- 初始化，m=0（子数组长度），sum=0（子数组和），startx=0（起始索引）\n  |\n  |\n  |--&gt; dfs(1, 1, 1)  &lt;- 选择a\\[0]，m=1，sum=1，startx=1\n  |   |\n  |   |--&gt; dfs(2, 4, 2)  &lt;- 选择a\\[1]，m=2，sum=4，startx=2\n  |   |   |\n  |   |   |--&gt; 检查sum=4（不是素数），结束这个分支\n  |   |\n  |   |&lt;-- 返回到 dfs(1, 1, 1) \\[返回到这个栈帧的时候for循环内的参数不会变化] //保留了这个栈帧的数据\n  |\n  |   |--&gt; dfs(2, 8, 2)  &lt;- 选择a\\[2]，m=2，sum=8，startx=2\n  |   |   |\n  |   |   |--&gt; 检查sum=8（不是素数），结束这个分支\n  |   |\n  |   |&lt;-- 返回到 dfs(1, 1, 1)\n  |   |\n  |&lt;----- 返回到 dfs(0, 0, 0)\n  |\n  |--&gt; dfs(1, 3, 1)  &lt;- 选择a\\[1]，m=1，sum=3，startx=1\n  |   |\n  |   |--&gt; dfs(2, 6, 2)  &lt;- 选择a\\[2]，m=2，sum=6，startx=2\n  |   |   |\n  |   |   |--&gt; 检查sum=6（不是素数），结束这个分支\n  |   |\n  |   |&lt;-- 返回到 dfs(1, 3, 1)\n  |\n  |   |&lt;-- 返回到 dfs(0, 0, 0)\n  |\n  |--&gt; dfs(1, 5, 1)  &lt;- 选择a\\[2]，m=1，sum=5，startx=1\n  |   |\n  |   |--&gt; dfs(2, 10, 2)  &lt;- 选择a\\[3]，m=2，sum=10，startx=2\n  |   |   |\n  |   |   |--&gt; 检查sum=10（不是素数），结束这个分支\n  |   |\n  |   |&lt;-- 返回到 dfs(1, 5, 1)\n  |\n  |   |&lt;-- 返回到 dfs(0, 0, 0)\n  |\n  |&lt;-- 返回到开始\n 结束\n使用DFS实现全排列\n\nDFS的核心思路是一路往下寻找，不撞南墙不回头说明当DFS到达边界情况时，就完成了一次搜索\n使用DFS时就要考虑完成一次**“搜索”**所需要的条件和边界情况\n\n\n使用DFS实现全排列\n\n思考第一步：全排列的一次情况的边界条件\n\n我们不妨对DFS传入一个参数 step 表示完成一次全排列的步骤\n当step 到 n 的时候，一次全排列的一种情况便结束了：\n在当前情况下，我们需要做的事情是：\n\n输出全排列的一次情况\n\n\n\n\nQ1：如何输出一次全排列情况？\n\nA:用result数组存\n\n\n思考第二步：全排列的实现\n\n我们可以使用一 个 path 来保留加入到result数组\npath 数组在一次查找过程中先将其标记，再进入下一个DFS函数查找，再取消标记，即一次回溯操作\n\n\n\n\nvector&lt;bool&gt; path;\nvint result;\nint t = 1;\n \nvoid quan(int step)\n{\n    if (step == t + 1) {\n        for (size_t i = 1; i &lt;= t; i++) {\n            cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n    for (size_t i = 1; i &lt;= t; i++) {\n        if (path[i] == 0) {\n            path[i] = 1;\n            result[step] = i;\n            quan(step + 1);\n            path[i] = 0;\n        }\n    }\n    return;\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    cin &gt;&gt; t;\n    path = vector&lt;bool&gt;(t + 10);\n    result = vint(t + 10);\n    quan(1);\n    return 0;\n}\n[板子] 一组数据取任意个数据进行操作\n例1：在数组[1,2,3,4,5] 中取任意个数，求这些取出来的数相加的结果\n方法一：DFS爆搜\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nvint res;\nvoid dfs(int n, int sum, int T, vint k)\n{\n    if (n &gt;= T) return;\n    sum += k[n];\n    res.emplace_back(sum);\n    for (size_t i = n + 1; i &lt; T; i++) {\n        dfs(i, sum, T, k);\n    }\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int T = 1;\n    cin &gt;&gt; T;\n    vint k(T);\n    for (auto &amp;&amp;i : k) {\n        cin &gt;&gt; i;\n    }\n    for (size_t i = 0; i &lt; T; i++) {\n        dfs(i, 0, T, k);\n    }\n    cout &lt;&lt; 0 &lt;&lt; &quot; &quot;;\n    for (auto &amp;&amp;i : res) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n\n其结果表现为：\n\n0 1 3 6 10 15 11 7 12 8 4 8 13 9 5 10 6 2 5 9 14 10 6 11 7 3 7 12 8 4 9 5\n充分体现了人类看不懂栈帧的特点\n\n\n法二：DP\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    vint food(T);\n    for(auto &amp;&amp; i : food){\n        cin &gt;&gt; i;\n    }\n    vint dp;\n    dp.emplace_back(0); // 初始状态\n    for (auto &amp;&amp;i : food) {\n        vint temp = dp;\n        for (auto &amp;&amp;j : dp) {\n            temp.emplace_back(i + j);\n        }\n        dp = move(temp);\n    }\n    for (auto &amp;&amp;i : dp)\n    {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n\n输出如下：\n0 1 2 3 3 4 5 6 4 5 6 7 7 8 9 10 5 6 7 8 8 9 10 11 9 10 11 12 12 13 14 15\n\n已验证，两个程序的结果除了顺序完全一致\n例2: P2036 [COCI2008-2009 #2] PERKET\n\n\n例二 法一：DFS\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nint T;\nvpii food;\n// vint result;\nint ans = 1e6;\n \nvoid dfs(int n, int sum_s, int sum_k)\n{\n    if (n == T) {\n        sum_s *= food[n - 1].first;\n        sum_k += food[n - 1].second;\n        ans = min(ans, abs(sum_s - sum_k));\n        return;\n    }\n    sum_s *= food[n].first;\n    sum_k += food[n].second;\n    ans = min(ans, abs(sum_s - sum_k));\n    for (size_t k = 0; k &lt; T; k++) {\n        for (size_t i = n; i &lt; T; i++) {\n            dfs(i + 1, sum_s, sum_k);\n        }\n        sum_s = 1;\n        sum_k = 0;\n    }\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    cin &gt;&gt; T;\n    food = vpii(T);\n    // result = vint(T, 0);\n    for (auto &amp;&amp;[s, k] : food) {\n        cin &gt;&gt; s &gt;&gt; k;\n    }\n    dfs(0, 1, 0);\n    cout &lt;&lt; ans;\n    return 0;\n}\n// 比我命还暴力这个算法\n// 这题绝对能用DP写，待我研究一下\n例二 法二 ： DP\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair&lt;ll, ll&gt; pii;\n \nsigned main()\n{\n    int T = 1;\n    cin &gt;&gt; T;\n    vector&lt;pii&gt; food(T);\n    for (auto &amp;&amp;[s, k] : food) {\n        cin &gt;&gt; s &gt;&gt; k;\n    }\n    // 使用集合记录所有可能的 (酸度, 苦度) 组合\n    set&lt;pii&gt; dp;\n    dp.emplace(1, 0); // 初始状态\n    for(auto &amp;[s, b] : food){\n        set&lt;pii&gt; temp = dp;\n        for(auto &amp;[acid, bitter] : dp){\n            temp.emplace(acid * s, bitter + b);\n        }\n        dp = move(temp);\n    }\n    // gtp写的，确实很精巧，用set记录了每个可能的情况\n    // 因为初始状况是(1,0),就相当于每一次内层循环的第一次都是只选当前组的食物\n    // 每一次都会把dp数组过完一遍，相当于在之前的所有情况下加一个 选择当前食物的情况\n    ll result = LLONG_MAX;\n    for(auto &amp;[acid, bitter] : dp){\n        if(acid != 1 || bitter != 0){\n            result = min(result, abs(acid - bitter));\n        }\n    }\n    cout &lt;&lt; result;\n    return 0;\n}"},"ACM/算法/状态压缩":{"slug":"ACM/算法/状态压缩","filePath":"ACM/算法/状态压缩.md","title":"状态压缩","links":["tags/模板"],"tags":["模板"],"content":"模板\n状态压缩\n状态压缩指的是用较小的数据结构（如整数或位掩码）来表示一个可能的状态或组合，从而减少存储空间和计算复杂性\n\n当两个数据分析特别大的时候，我们可以考虑使用二进制来实现0/1的分类;\n下面举例使一个数组的分为 a b两组,找到 max( \\sum a , \\sum b ) 中的最小值\na 代表一个分类     b 代表一个分类\n\ncin &gt;&gt; n;\nfor(int i = 0; i &lt; n; i ++) cin &gt;&gt; k[i];\nfor(LL state = 0; state &lt; 1LL &lt;&lt; n; state ++){           ---&gt; A \n    a = 0, b = 0;\t\t\t\t\t\t\t\t\t\t\n    for(int i = 0; i &lt; n; i ++){\t\t\t\t\t   \t ---&gt; B\n        if(state &gt;&gt; i &amp; 1) a += k[i];\n    \telse b += k[i];\n    }\n    ans = min(ans, max(a, b));                           ---&gt; C\n\nstate表示了一个被压缩的状态 \\to 用long long 表示一个被分类的状态\n\n\nA：实际上是表示了2^{n}种状态 1LL &lt;&lt; n 等效于 2^n\nB：二进制位一共有n位，i 从零到 n 解 state二进制位\n\n对于每个元素 k[i]，根据 state 的二进制位判断该元素属于组 a 还是组 b\n\nC: 刷新ans,这确保了 ans 始终存储的是所有分组方式中最小的最大和\n例子解释，当 n = 3 时\n每个 state 的二进制位表示每个元素属于哪一组。例如，对于 n = 3（有 3 个元素的情况）：\n\nstate = 0（000）：所有元素都在组 b\nstate = 1（001）：第一个元素在组 a，其余元素在组 b\nstate = 2（010）：第二个元素在组 a，其余在组 b\nstate = 3（011）：第一个和第二个元素在组 a，第三个在组 b\n…\nstate = 7（111）：所有元素都在组 a\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n状态压缩的复杂度为 O(2^n)  在 n &gt; 29 时大概率TLE\n\n\n"},"ACM/算法/现代C++之function":{"slug":"ACM/算法/现代C++之function","filePath":"ACM/算法/现代C++之function.md","title":"现代C++之function","links":["tags/语法"],"tags":["语法"],"content":"语法\nC++11 提供 std::function 这样一个函数包装式来封装函数\n\n基本语法：\n\nfunction&lt;返回值(传参)&gt;\n示例： function&lt;int(int,int)&gt; func\n\n\n利用function包装函数：\n\nvoid add(int a,int b){\n\treturn a+b;\n}\n \nint main()\n{\n\tstd::function&lt;int(int,int)&gt; fun = add;\n\tint res = fun(3,4);\n\t// 此时res输出 7\n}\n你同样也可以使用 function包装一个lambda表达式 为什么不直接使用lambda\nint main()\n{\n\tauto lamb = [&amp;](int a,int b){\n\treturn a+b;\n\t}\n\tstd::function&lt;int(int,int)&gt; fun1 = lamb;\n\t//上式等价于下式\n\tstd::function&lt;int(int,int)&gt; fun2 = [&amp;](int a,int b)-&gt; int{\n\t\treturn a+b;\n\t};\n}"},"ACM/算法/素数筛":{"slug":"ACM/算法/素数筛","filePath":"ACM/算法/素数筛.md","title":"素数筛","links":["tags/数学","tags/数论","tags/素数"],"tags":["数学","数论","素数"],"content":"数学 数论 素数\n9 素数筛\n9.1 一般双重筛\n\n通过不断试除来判断某一数字k有无因数\n时间复杂度为O(N^2)\n\nbool prime(long long i)\n{\n    if (i == 2)\n        return 1;\n    else if (i == 1)\n        return 0;\n    for (size_t k = 2; k * k &lt;= i; k++) {\n        if (i % k == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    for (size_t i = 2; i &lt;= n; i++) {\n        if (prime(i)) {\n            cout &lt;&lt; i &lt;&lt; endl;\n        }\n    }\n    return 0;\n}\n9.2 埃拉托斯特尼筛法\n\n核心思路是先标记素数，然后把素数的所有倍数全标记为非素数\n时间复杂度是O(n\\log{\\log{n}})\n对于任意一个大于1的正整数n,那么它的x倍就是合数(x &gt; 1)。利用这个结论，我们可以避免很多次不必要的检测。\n如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。\n\nvector&lt;int&gt; prime;\nvector&lt;bool&gt; IsPrime(1e7);\n \nvoid Eratosthenes(long long n)\n{\n    IsPrime[0] = IsPrime[1] = 0; //前两项不为素数，记作0\n    for (size_t i = 2; i &lt;= n; i++) //先全部记作1\n    {\n        IsPrime[i] = 1;\n    }\n    //memset(IsPrime,1,sizeof(IsPrime)); //似乎使用memset的时间复杂度也是O(N)\n    for (size_t i = 2; i &lt;= n; i++)\n    {\n        //素数筛选\n        //从第三项开始，如果这个数被标记为1，就把它记作素数，放入数组 \n        //同时从 i*i 项开始，每次将 i 的倍数标记为非素数\n        if (IsPrime[i])\n        {\n            prime.push_back(i);\n            if ((long long)i * i &gt; n) continue; //超过n的不计\n            for (size_t j = i*i ; j &lt;= n; j += i)\n            {\n                IsPrime[j] = 0;\n            }\n        }\n    }\n}\n \nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    Eratosthenes(n);\n    for (auto &amp;&amp;i : prime) cout &lt;&lt; i &lt;&lt;endl;\n    return 0;\n}\n\n我们可以只筛选到\\sqrt{N}来降低操作次数\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &quot;\\n&quot;\nusing namespace std;\n \nvector&lt;int&gt; prime;\nvector&lt;bool&gt; IsPrime(1e7);\n \nvoid Eratosthenes(long long n)\n{\n    IsPrime[0] = IsPrime[1] = 0; //前两项不为素数，记作0\n    for (size_t i = 2; i &lt;= n; i++) //先全部记作1\n    {\n        IsPrime[i] = 1;\n    }\n    //memset(IsPrime,1,sizeof(IsPrime)); //似乎使用memset的时间复杂度也是O(N)\n    for (size_t i = 2; i*i &lt;= n; i++)\n    {\n        //素数筛选\n        //从 i*i 项开始，每次将 i 的倍数标记为非素数\n        if (IsPrime[i])\n        {\n            for (size_t j = i*i ; j &lt;= n; j += i)\n            {\n                IsPrime[j] = 0;\n            }\n        }\n    }\n    //计入数组\n    for (size_t i = 2; i &lt;= n; i++)\n    {\n        if (IsPrime[i])\n        {\n            prime.push_back(i);\n        }\n    }\n}\n \nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    Eratosthenes(n);\n    for (auto &amp;&amp;i : prime) cout &lt;&lt; i &lt;&lt;endl;\n    return 0;\n}\n\n我们也可以改写0/1来实现非初始化bool数组\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &quot;\\n&quot;\nusing namespace std;\n \nvector&lt;int&gt; prime;\nvector&lt;bool&gt; IsPrime(1e7);\n \nvoid Eratosthenes(long long n)\n{\n    IsPrime[0] = IsPrime[1] = 0; //前两项不为素数，记作0\n    for (size_t i = 2; i*i &lt;= n; i++)\n    {\n        //素数筛选\n        //从 i*i 项开始，每次将 i 的倍数标记为非素数\n        if (!IsPrime[i])\n        {\n            for (size_t j = i*i ; j &lt;= n; j += i)\n            {\n                IsPrime[j] = 1;\n            }\n        }\n    }\n    //计入数组\n    for (size_t i = 2; i &lt;= n; i++)\n    {\n        if (!IsPrime[i])\n        {\n            prime.push_back(i);\n        }\n    }\n}\n \nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    Eratosthenes(n);\n    for (auto &amp;&amp;i : prime) cout &lt;&lt; i &lt;&lt;endl;\n    return 0;\n}\n9.3 欧拉筛法\n\n时间复杂度O(n)\n埃氏筛法仍有优化空间，它会将一个合数重复多次标记。我们可以用改进的筛法欧拉筛来计算\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &quot;\\n&quot;\nusing namespace std;\n \nvector&lt;int&gt; prime;\nvector&lt;bool&gt; not_prime(1e7);\n \nvoid Euler(long long &amp;n)\n{\n    for (size_t i = 2; i &lt;= n; i++)\n    {\n        //如果该数标记为 0 即 非(非素数),计入素数数组\n        if (!not_prime[i])\n        {\n            prime.push_back(i);\n        }\n        // 换言之，i 之前被 prime[j] 筛过了\n        // 由于 prime 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被\n        // prime[j] 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break掉\n        for (auto &amp;&amp;j : prime)\n        {\n            if(i*j &gt; n) break;\n            not_prime[i*j] = 1;\n            if(i%j == 0) break;\n        }\n    }\n}\n \nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    Euler(n);\n    for (auto &amp;&amp;i : prime) cout &lt;&lt; i &lt;&lt; endl;\n    return 0;\n}"},"ACM/算法/约瑟夫问题":{"slug":"ACM/算法/约瑟夫问题","filePath":"ACM/算法/约瑟夫问题.md","title":"约瑟夫问题","links":["tags/数学","tags/模拟","tags/递归与递推"],"tags":["数学","模拟","递归与递推"],"content":"数学 模拟 递归与递推\n约瑟夫问题\n\n人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。\n现在我想知道幸存者的编号(编号从0开始)的多少\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n考虑在有n - 1个人，处决k的情况下最后一个人的编号是f(n - 1,k),那么对n个人而言，有递推式==f(n,k) = (f(n-1,k) + k)\\mod n==\n递推式求解抽象化：考虑对f(n-1,k)，扩展到n人时，我们只需要将第k个人处决，问题便又回到了对n-1人中找f(n-1,k)的问题上，但我们删除编号k个数时候,所有数的编号都会进行变化映射,即新的环的起点发生了变化,即集体向后移动k位且保证在n范围内,所以需要取模与n\n即 : ==f(n,k) = (f(n-1,k) + k)\\mod n==\n\n\n\nint josephus(int n, int k)\n{\n    int s = 0;\n    for (int i = 2; i &lt;= n; i++) s = (s + k) % i;\n    return s + 1;\n}\n\n上述算法时间复杂度O(n),空间复杂度O(1),但对 k = 2的情况我们可以有特殊解法使时间复杂度降低到O(\\log n) : 引用自Wikipedia\n\n答案的最漂亮的形式，与n的二进制表示有关：把n的第一位移动到最后，便得到f(n)。如果n的二进制表示为n=b_{0}b_{1}b_{2}b_{3}\\dots b_{m}则f(n)=b_{1}b_{2}b_{3}\\dots b_{m}b_{0}。这可以通过把n表示为2^{m}+l来证明。\n\n\nint yuesefu(int n)\n{\n    // 找到最高位的值，即n的最高位所代表的2的幂\n    int highestBit = 1;\n    while (highestBit &lt;= n) {\n        highestBit &lt;&lt;= 1; // 将最高位左移\n    }\n    // 移动后的结果\n    return (n - (highestBit &gt;&gt; 1)) &lt;&lt; 1 + 1;\n // return (n -  highestBit / 2) * 2 + 1\n}"},"ACM/算法/线性丢番图方程":{"slug":"ACM/算法/线性丢番图方程","filePath":"ACM/算法/线性丢番图方程.md","title":"线性丢番图方程","links":["tags/数学","tags/丢番图","tags/数论","ACM/算法/扩展欧几里得算法"],"tags":["数学","丢番图","数论"],"content":"数学 丢番图 数论\n20 线性丢潘图方程(Diophantine equation)\n\n线性丢番图方程（Diophantine equation）通常指的是形如 ax+by=c的方程，其中 a,b,c 是整数，而我们感兴趣的是找到整数解 x,y。\n孩子们，牛客周赛77第三题会这个秒杀了（怪不得那群人可以20min ak，全是板子题）\n\nx,y 存在解的情况下，a,b 满足以下条件\n\nc 必须是 a 和 b 的最大公约数 (gcd) 的倍数\n\n具体而言，当 c\\mod({\\gcd(a,b)}) = 0 时存在x,y 使上述方程存在整数解\n\n扩展：\n若上述条件满足，则存在无穷多组解 (x,y) ,一旦找到一组特殊的解(x_0,y_0)，则所有解都可以被表示出来，其表示方式如下\nx = x_0 + k\\left(\\frac{b}{g}\\right)\ny = y_0 - k\\left(\\frac{a}{g}\\right)\n其中g = \\gcd(a,b)\n\n\n其具体作用为，在确定线性丢潘图方程有解的情况，可以使用扩展欧几里得算法展欧几里得算法找出其中一个特解(x_0,y_0) , 然后找出所有解的通项\n\n找出丢潘图方程通项代码模板\n\n需要用到扩展欧几里得算法进行实现\n\n\n如下：\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \n// 扩展欧几里得算法\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n{\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a; // 返回gcd(a, b)\n    }\n    int r = exgcd(b, a % b, x, y);\n    int t = y;\n    y = x - (a / b) * y;\n    x = t;\n    return r;\n}\n \nint main()\n{\n    int a, b, c;\n    cout &lt;&lt; &quot;请输入线性丢番图方程(ax+by=c)的系数a, b和常数c : &quot; &lt;&lt; endl;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    int g = __gcd(a, b); // 计算gcd(a, b)\n    if (c % g != 0) {\n        cout &lt;&lt; &quot;方程无整数解.&quot; &lt;&lt; endl;\n        return 0;\n    }\n    // 使用扩展欧几里得算法找到一个特解\n    int x0, y0;\n    exgcd(a / g, b / g, x0, y0);\n    x0 *= c / g;\n    y0 *= c / g;\n    cout &lt;&lt; &quot;一个特解为: x = &quot; &lt;&lt; x0 &lt;&lt; &quot;, y = &quot; &lt;&lt; y0 &lt;&lt; endl;\n    // 输出一般解\n    cout &lt;&lt; &quot;一般解的形式为:&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;x = &quot; &lt;&lt; x0 &lt;&lt; &quot; + &quot; &lt;&lt; b / g &lt;&lt; &quot; * k&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;y = &quot; &lt;&lt; y0 &lt;&lt; &quot; - &quot; &lt;&lt; a / g &lt;&lt; &quot; * k&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;其中k为任意整数.&quot; &lt;&lt; endl;\n    return 0;\n}\n\n\n                  \n                  Tip\n                  \n                \n\n\n由于 g 已经是 a 和 b 的最大公约数，因此 \\frac{a}{g} 和 \\frac{b}{g} 互质（即它们的最大公约数为1）。这样做的目的是为了简化问题，使得新的系数 \\frac{a}{g} 和 \\frac{b}{g} 成为互质的整数，从而可以使用扩展欧几里得算法来求解简化后的方程。\n因为有了简化过程，所以结果出来时要乘上 \\frac{c}{g}来回复正常解\n\n\n"},"ACM/算法/贪心":{"slug":"ACM/算法/贪心","filePath":"ACM/算法/贪心.md","title":"贪心","links":["tags/贪心"],"tags":["贪心"],"content":"贪心\n贪心\n\n每一步再选择中都选择当前状态下的最优解\n通过局部最优解做到全局最优解\n例：\n\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n{\n    int N ,sum = 0,p = 1,j =0,emp = 0;\n    cin &gt;&gt; N;\n    int arr[N] = {0};\n    int arrp[N] = {0};\n    for (size_t i = 1; i &lt;= N; i++)\n    {\n        cin &gt;&gt; arr[i];\n    }\n    sort(arr+1,arr+N+1);\n    \n    if (N == 1)\n    {\n        cout &lt;&lt; arr[1];\n        return 0;\n    }\n \n    while (1)\n    {\n        if (N - j == 2 || N - j == 1)\n        {\n            sum += arr[2];\n            break;\n        }\n        sum += arr[1] + 2*arr[2] + arr[N-j];\n        j += 2;\n    }\n    cout &lt;&lt; sum;\n    \n    return 0;\n \n}\n\n\n                  \n                  Note\n                  \n                \n\n\n\n这题的题解找个时间我再写\n\n\n\n"},"ACM/算法/递归":{"slug":"ACM/算法/递归","filePath":"ACM/算法/递归.md","title":"递归","links":["tags/递归与递推","ACM/算法/深度优先搜索-DFS","ACM/算法/递推"],"tags":["递归与递推"],"content":"递归与递推\n递归\n递归的定义：函数的自我调用\n例：\n\n利用递归实现阶乘\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint out(int n)\n{\n\tint res;\n\tif (n == 1)\n\t{\n\t\tres = 1;\n\t}\n\telse\n\t{\n\t\tres = out(n-1)*n; //在这里又调用了一次out,即out(n-1) = out(n-2)*(n-1)\n\t}\n\treturn res;\n}\n \nint main()\n{\n\tcout &lt;&lt; out(5);\n\treturn 0;\n}\n\n基于递归的算法\n\n深度优先搜索 DFS\n\n\n\n\n学递归有感而发：\n\n只有上帝和出题人知道递归传参究竟是怎么传的\n\n\n\n\n递归的缺陷\n使用递归计算斐波那契数列数列第n项(n &lt; 50)\n\nint f(int n)\n{\n\tint res;\n\tif (n == 1 || n == 2)\n\t{\n\t\tres = 1;\n\t}\n\telse\n\t{\n\t\tres = f(n-1)+f(n-2);\n\t}\n\t\n\treturn res;\n}\n \nint main()\n{\n\tfor (size_t i = 1; i &lt;= 50; i++)\n\t{\n\t\tcout &lt;&lt; i &lt;&lt;&quot;\t&quot;&lt;&lt;f(i) &lt;&lt;endl;\n\t}\n\t\n\treturn 0;\n}\n\n运行不难发现，在第46项以后，运行极为缓慢\n由此引入 递推\n"},"ACM/算法/递推":{"slug":"ACM/算法/递推","filePath":"ACM/算法/递推.md","title":"递推","links":["tags/递归与递推"],"tags":["递归与递推"],"content":"递归与递推\n递推\n\n从1开始，向下求解，直到输出正确函数\n用若干重复计算解决实际问题的方法\n找规律构成递推式\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n{\n\tlong arr[60] = {0};\n\tarr[1] = 1;\n\tarr[2] = 1;\n\tfor (size_t i = 3;i &lt;= 50; i++)\n\t{\n\t\tarr[i] = arr[i-1] + arr[i-2];\n\t}\n\tfor (size_t i = 1; i &lt;= 50; i++)\n\t{\n\t\tcout &lt;&lt; i &lt;&lt;&quot;\t&quot;&lt;&lt; arr[i] &lt;&lt;endl;\n\t}\n\treturn 0;\n}\n\n又找到一道递推好题 洛谷P1044[栈]\n上代码：\n\n/*\n    P1044递推解法\n    注意到待入栈数n里的第k个数: 设其方案有f[k] (k &gt; 0)\n    则再设 k 前面的数的排列方式有 f[k-1] 种\n    k 后面的数的排列方式有 f[n-k]种\n    根据组合数原理: f[k] = f[k-1] * f[n-k]\n    则有  f[n] = sum_{k = 0}^{n-1} f[k] 即 f[n] = f[0]f[n-1] + f[1]f[n-2] ...... + f[n-1]f[0]\n    简单分析不难发现f[0] = 1 , f[1] = 1, f[2] = 2;\n*/\n \n#include &lt;bits/stdc++.h&gt;\n#define endl &quot;\\n&quot;\nusing namespace std;\n \nint main()\n{\n    int n;\n    long long f[20] = {1,1,2};\n    cin &gt;&gt; n;\n    //在这里 i 表示上文的 n ; j 表示上文的 k;\n    //因为f[0] , f[1] , f[2] 均已明确 i 从 3 开始算;\n    for (size_t i = 3; i &lt;= n; i++)\n    {\n        for (size_t j = 1; j &lt;= i; j++)\n        {\n            f[i] += f[j-1]*f[i-j];\n        }\n    }\n    cout &lt;&lt; f[n];\n    return 0;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n主要在于对N里的任何一项k存在：f(k) = f(k-1)\\times f(n-k)\nf(k)表示第k项的情况:\n则f(N) = \\sum_{k=1}^{N-1}f(k)\n即：f(n) = f(0)f(n-1) + f(1)f(n-2) ...... + f(n-1)f(0)\n\n\n"},"ACM/算法/高精度":{"slug":"ACM/算法/高精度","filePath":"ACM/算法/高精度.md","title":"高精度","links":["tags/模拟","tags/高精度"],"tags":["模拟","高精度"],"content":"模拟 高精度\n高精度\n\n一般而言，在long long 格式下的字符占用有8个字节，其范围是-2^63^~2^63^-1(19位数)这个区间，那么，超过这个区间的计算我们又该如何进行呢？\n\n1 高精度加法\n\n在进行超过19位数相加的大数加法的时候，我们可以模拟竖式加法的原理，对数组进行操作\n如图\n\n\n\n使用字符串获取大数字\n将字符串的数字提取出来逆序储存在数组中\n对数组中的数组做加法并存储到另一个数组中\n逆序输出数组\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n{\n    string s1,s2;\n    int a1[210],a2[210],a3[210] = {0};\n    getline(cin,s1);\n    getline(cin,s2);\n    for (size_t i = 0; i &lt; s1.size(); i++)\n    {\n        a1[s1.size()-i-1] = s1[i] - &#039;0&#039;;\n    }\n    for (size_t i = 0; i &lt; s2.size(); i++)\n    {\n        a2[s2.size()-i-1] = s2[i] - &#039;0&#039;;\n    }\n    int len = max(s1.size(),s2.size()); \n    for (size_t i = 0; i &lt; len;i++)\n    {\n        a3[i] = a1[i] + a2[i];\n    }\n    for (size_t i = 0; i &lt; len; i++)\n    {\n        if (a3[i] &gt;= 10)\n        {\n            a3[i + 1] = a3[i]/10;\n            a3[i] = a3[i]%10;\n        }\n    }\n    if (a3[len] != 0)\n    {\n        len++;\n    }\n    for (int i = len - 1; i &gt;= 0; i--)\n    {\n        cout &lt;&lt; a3[i];\n    }\n    return 0;\n}\n\n更好用的字符串 string类型的高精度\n\nstring largeadd(string&amp; a, string&amp; b)\n{\n    if (a.size() &lt;= b.size()) swap(a, b);\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++) {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        int bi = b[b.size() - i - 1] - &#039;0&#039;;\n        int sum = ai + bi + p;\n        if (sum &gt;= 10) {\n            p = 1;\n            sum -= 10;\n        } else p = 0;\n        a[a.size() - 1 - i] = sum + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++) {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == &#039;9&#039; &amp;&amp; p == 1) {\n            a[a.size() - i - 1] = &#039;0&#039;;\n        } else {\n            a[a.size() - i - 1] = ai + p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    if (p == 1) a.insert(a.begin(), &#039;1&#039;);\n    return a;\n}\n2 高精度减法\n\n与加法类似，主要是注意借位与进位的不同\n负数的处理\n\nstring largemin(string a, string b)\n{\n    int flag = 0;\n    if (b.size() &gt;= a.size()&amp;&amp; b &gt;= a) {\n        swap(a, b);\n        flag = 1;\n    }\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++) {\n        int ai = a[a.size() - 1 - i] - &#039;0&#039;;\n        int bi = b[b.size() - 1 - i] - &#039;0&#039;;\n        int diff = ai - bi - p;\n        if (diff &lt; 0) {\n            p = 1;\n            diff += 10;\n        } else p = 0;\n        a[a.size() - i - 1] = diff + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++) {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == 0 &amp;&amp; p == 1) {\n            a[a.size() - i - 1] = &#039;9&#039;;\n        } else {\n            a[a.size() - i - 1] = ai - p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    while (*a.begin() == &#039;0&#039; &amp;&amp; a.size() &gt; 1)\n        a.erase(a.begin());\n    if (flag) a.insert(a.begin(), &#039;-&#039;);\n    return a;\n}\n3 高精度乘法\n\n\n                  \n                  Tip\n                  \n                \n\n\n对于乘法来说，高精度的最佳计算思维就是将两个数拆分，用一个数的个十百位依次去乘以另一个数\n拿我们常用的，主要的步骤有以下几点：\n\n字符串化数字，倒置字符串\n两位相乘，计算结果与储存位数\n数组变字符串\n\n\n\n\n//#pragma GCC optimize(2)\n#include &lt;bits/stdc++.h&gt;\n#define endl &#039;\\n&#039;\nusing namespace std;\n \nstring largemuiti(string a, string b)\n{\n    if (a == &quot;0&quot; || b == &quot;0&quot;) return &quot;0&quot;;\n    int len1 = a.size();\n    int len2 = b.size();\n    vector&lt;int&gt; result(len1 + len2, 0);\n    for (int i = len1 - 1; i &gt;= 0; i--) {\n        for (int j = len2 - 1; j &gt;= 0; j--) {\n            int mult = (a[i] - &#039;0&#039;) * (b[j] - &#039;0&#039;);\n            int sum = result[i + j + 1] + mult;\n            result[i + j + 1] = sum % 10;\n            result[i + j] += sum / 10;\n        }\n    } \n    string res = &quot;&quot;;\n    for (size_t i = 0; i &lt; result.size(); i++) {\n        if (!(result[i] == 0 &amp;&amp; res.empty())) {\n            res += to_string(result[i]);\n        }\n    }\n    return res;\n}\n \nint main()\n{\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cout &lt;&lt; largemuiti(&quot;123&quot;, &quot;234&quot;);\n    return 0;\n}"},"ACM/题解/CR1037-div.3-题解":{"slug":"ACM/题解/CR1037-div.3-题解","filePath":"ACM/题解/CR1037 div.3 题解.md","title":"CR1037 div.3 题解","links":[],"tags":[],"content":"CR1037 题解\nA\n题意 :\n输入一个数n,找到最小的和它有共同数字的数 k\n思路:\n显然k就是这个数n的所有位数的最小的那一位\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    string s = to_string(n);\n    sort(all(s));\n    cout &lt;&lt; s[0] &lt;&lt; endl;\n}\n\nB\n题意:\n给定一个包含n个元素的数组A和一个数k ,A中的每个元素由 0,1 构成,需要我们寻找k数量的连续0串且每个串之间需要有一个元素相隔\n思路:\n直接模拟即可\nvoid solve()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vint v(n);\n    for (auto &amp;&amp;i : v) {\n        cin &gt;&gt; i;\n    }\n    int cnt = 0;\n    int now = 0;\n    for (size_t i = 0; i &lt; n; i++)\n    {\n        if(v[i] == 0)now++;\n        if(v[i] == 1)now = 0;\n        if(now == k){\n            i++;\n            cnt++;\n            now = 0;\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; endl;\n}\n\nC\n题意:\n给定两个数 n,k 和一个有 n 个元素的数组 A ,有一个从0开始的每秒加1的水位,数组A中的元素a_i表示第i座塔的高度,你初始在a_k 高度的塔上,你可以花费 |a_j - a_i| 的时间从第i座塔移动到第j座塔,当水位完全超过你所在塔的高度的时候便会失败\n你需要判断能否到达最高的塔而不失败\n思路:\n我们考虑贪心,因为水位上涨速度与我们移动速度是一致的,故只要从我们目前所在高度的 a_i 到最高位置 a_{max} 之间从小到大两两的距离差都小于初始高度a_i 我们就可以到达最高的塔\nvoid solve()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vint v(n);\n    for (auto &amp;&amp;i : v) {\n        cin &gt;&gt; i;\n    }\n    int under = v[k - 1];\n    // 贪心:一开始所在位置就是我们能跨越的最大位置,而且我们只需要看比一开始大的\n    ranges::sort(v);\n    vint res;\n    for (size_t i = 0; i &lt; n; i++) {\n        if (v[i] &gt;= under) {\n            res.emplace_back(v[i]);\n        }\n    }\n    vint diff(n,0);\n    for (size_t i = 0; i + 1 &lt; res.size(); i++) {\n        diff[i] = res[i + 1] - res[i];\n    }\n    cout &lt;&lt; (ranges::max(diff) &gt; under ? &quot;NO&quot; : &quot;YES&quot;) &lt;&lt; endl;\n}\n\nD\n题意:\n给定 n 个赌场,其有三个参数 l,r,real ,再给定初始金币 k ,规定持有金币数量p每个赌场只能允许p \\in [l,r] 进入并且会将 p 变为 real ,并且每个赌场只能进入一次\n我们需要知道我们在参加任意次赌场后获得的最大金币数量为多少\n思路:\n由于我们需要最大的金币数量,所以我们每一次游玩后都想要金币尽可能上涨,这里我们考虑使用 大堆顶 即优先队列来筛选,其存放数据为\\{r,real\\}\n具体做法是\n\n先将所有赌场的进入门槛 l 从小到大排序\n然后进行循环,首先令 now = k\n\n对当前金币now ,将l \\le now 的放入大堆顶,这样存放进入的数据中会按照real的大小排序\n对堆里的数据,先排除 r &lt; now 的\n如果堆空了或者堆顶的real \\le now 的话说明已经没有比 now 还大的元素了,那么我们就退出循环\n否则就将 now 赋值为堆顶的real 代表这一轮找到了最大的real_i 然后重复循环\n\n\n\nstruct st\n{\n    int l, r, re;\n};\n \nvoid solve()\n{\n    int n,k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;st&gt; v(n);\n    for (size_t i = 0; i &lt; n; i++)\n    {\n        auto &amp;&amp;[l, r, t] = v[i];\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n    }\n    ranges::sort(v, [](st a, st b) { return a.l &lt; b.l; });\n    priority_queue&lt;pii&gt; pq;\n    int now = k;\n    int idx = 0;\n    while (1)\n    {\n        while (idx &lt; n &amp;&amp; v[idx].l &lt;= now)\n        {\n            pq.emplace(v[idx].re, v[idx].r);\n            idx++;\n        }\n        // 排除 r &lt; now的\n        while (!pq.empty() &amp;&amp; pq.top().second &lt; now)\n        {\n            pq.pop();\n        }\n        // 如果空或者没有比x大的,那么就退出\n        if (pq.empty() || pq.top().first &lt;= now) {\n            break;\n        }\n        // 提升now\n        now = pq.top().first;\n        pq.pop();\n    }\n    cout &lt;&lt; now &lt;&lt; endl;\n}\n"},"C++/STL/Deque-双向队列":{"slug":"C++/STL/Deque-双向队列","filePath":"C++/STL/Deque 双向队列.md","title":"Deque 双向队列","links":["tags/STL","tags/容器","tags/队列","C++/STL/Vector","C++/STL/Queue-队列"],"tags":["STL","容器","队列"],"content":"STL 容器 队列\ndeque 双向队列\n\n作用： deque可以作为一个双向队列，在队首队尾以及任意位置实现元素的插入和删除\n定义： 和*Vector*一致\n有和Queue 队列几乎一样的功能，但双端可操作，是经常\n\n成员函数：\n    push_back()     //在队列的尾部插入元素。\n    emplace_front() //与push_front()的作用一样\n    push_front()    //在队列的头部插入元素。\n    emplace_back()  //与push_back()的作用一样\n    pop_back()      //删除队列尾部的元素。\n    pop_front()     //删除队列头部的元素。\n    back()          //返回队列尾部元素的引用。\n    front()         //返回队列头部元素的引用。\n    clear()         //清空队列中的所有元素。\n    empty()         //判断队列是否为空。\n    size()          //返回队列中元素的个数。\n    begin()         //返回头位置的迭代器\n    end()           //返回尾+1位置的迭代器\n    rbegin()        //返回逆头位置的迭代器\n    rend()          //返回逆尾-1位置的迭代器\n    insert()        //在指定位置插入元素\n    erase()         //在指定位置删除元素"},"C++/STL/List-列表":{"slug":"C++/STL/List-列表","filePath":"C++/STL/List 列表.md","title":"List 列表","links":["tags/STl","tags/容器"],"tags":["STl","容器"],"content":"STl 容器\n1.9 列表list\n构造\nlist&lt;类型&gt; lt\n1.9.1 优势与适用范围\nlist容器插入和删除元素的效率较高，时间复杂度为常数级别,其底层为带头双向循环链表\n1.9.2 常用方法\n\n\n定义:\n\n构造空list() / 含有n个元素的类型容器list / 拷贝某个类型容器的复制品\n\nlist&lt;int&gt; lt1; //构造int类型的空容器\nlist&lt;int&gt; lt2(10,2); //构造含有10个2的int类型容器\nlist&lt;int&gt; lt3(lt2); //拷贝构造int类型的lt2容器的复制品\nlist&lt;int&gt; lt4{ 1,2,3,4,5 };  // 直接使用花括号进行构造---C++11允许\n\n迭代器复制字符内容\n\nstring s(&quot;hello world&quot;);\nlist&lt;char&gt; lt5(s.begin(),s.end()); //构造string对象某段迭代器区间的内容\n\n\n1.9.3 list的遍历及迭代器的操作\n\n迭代器\n正向迭代器\n\nint arr[] = {1,1,4,5,1,4}; //构造数组\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0])); //copy数组到list\nfor(list&lt;int&gt;::iterator it = lt.begin();it != lt.end();++it)\n{\n    cout &lt;&lt; *it &lt;&lt;endl;\n}\n\n反向遍历器(抽象)[防止你不知道]\n\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\nfor(list&lt;int&gt;::reverse_iterator it = lt.rbegin();it != lt.rend();++it)\n{\n    cout &lt;&lt; *it &lt;&lt;endl;\n}\n\n范围for(好用)\n\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n\n\n\n常见容器操作\n\n\n.size():返回容器中有效元素的个数\n\n\n.resize():调整容器的有效元素大小(size)\n\n\n.empty():判断容器是否为空\n\n\n.clear():用于清空容器,清空后容器的size为0, 但是头结点(哨兵位)不会被清除\n\n\n\n\n\n\n\n**.resize(a,b)**有两个参数:\n\na:将list大小变为(a)\nb:若list新大小大于原大小,则新增的大小用b填充\n\n\n\n\n1.9.4 list容器的常见访问操作\n\n.front():访问list头元素[返回list的第一个元素]\n.back():访问list尾元素[返回list的最后一个元素]\n\n1.9.5 list 容器的常见修改操作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数(接口)名称函数(接口)说明.push_front()在list首元素前插入元素.pop_front()删除list首元素.push_back()在list尾部插入元素.pop_back()删除list最后一个元素.insert()在list&lt;int&gt;::iterator it 前插入元素.erase()在list&lt;int&gt;::iterator it 前删除元素.swap()交换两个元素\n\n\n                  \n                  Important\n                  \n                \n\n\n\n\n有关**insert()**的操作:[^7]\n\n\ninsert共有三种形式：\n\ninsert(iterator, value);\ninsert(iterator, num, value);\ninsert(iterator, iterator1, iterator2);\n\n\n\n\ninstert的所有操作都由迭代器位置确定,不存在lt[2]这类的中括号表操作\n\n\n\n对insert(iterator, value);(会返回一个新迭代器指向插入的元素)\n\n\n\n\n\n//创立一个数组\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\ncout &lt;&lt; &quot;befor&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n//创立一个迭代器指向lt的头元素\nlist&lt;int&gt;::iterator it = lt.begin();\n//迭代器向后移动2位,指向4\nadvance(it,2);\n//在4的迭代器前,插入元素3\nauto itnew = lt.insert(it,3);\ncout &lt;&lt; &quot;after&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\ncout &lt;&lt; &quot;new iterator = &quot; &lt;&lt; *itnew &lt;&lt;endl;\nreturn 0;```\n&gt; ![[Pasted image 20250123210215.png]]\n&gt;\n&gt; - 对 `insert(iterator, num, value);`(会返回一个新迭代器指向插入的第一个元素)\n&gt;\n```cpp\n//创立一个数组\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\ncout &lt;&lt; &quot;befor&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n//创立一个迭代器指向lt的头元素\nlist&lt;int&gt;::iterator it = lt.begin();\n//迭代器向后移动2位,指向4\nadvance(it,2);\n//在4的迭代器前,插入元素3个3\nauto itnew = lt.insert(it,3,3);\ncout &lt;&lt; &quot;after&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n//新迭代器的位置在第一个3\ncout &lt;&lt; &quot;new iterator = &quot; &lt;&lt; *itnew &lt;&lt;endl;\nreturn 0;\n\n\n\n\n对 insert(iterator, iterator1, iterator2); \n\n//创立一个数组\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\ncout &lt;&lt; &quot;befor&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n//创立一个迭代器指向lt的头元素\nlist&lt;int&gt;::iterator it = lt.begin();\n//迭代器向后移动2位,指向4\nadvance(it,2);\n//建立新的list或(vector);\nvector&lt;int&gt; lt2 = {1,9,1,9,8,1,0};\n//确定迭代器位置\nauto it1 = lt2.begin();\nauto it2 = lt2.end();\n//在4的迭代器前,插入迭代器it1 - it2 这之间的数\n//会返回插入的数的第一个元素的迭代器\nauto itnew  = lt.insert(it,it1,it2);\ncout &lt;&lt; &quot;after&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\ncout &lt;&lt; &quot;new iterator = &quot; &lt;&lt; *itnew;\nreturn 0;\n\n\n\n**.erase()**用法和 **.insert()**差不多,只是从添加元素变为删除元素删除的为迭代器指向的元素或两个迭代器之间(包括本身)的元素\n\n\n1.9.6 list容器常用的操作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数声明接口说明splice将元素从列表转移到其它列表remove删除具有特定值的元素remove_if删除满足条件的元素unique删除重复值sort(慢)容器中的元素排序merge合并排序列表reverse反转元素的顺序\n\n.splice()一共有四种形式\n\nsplice(iterator_pos, otherList) : 将otherList中的所有元素移动到iterator_pos指向元素之前\n\n\n\nlist&lt;int&gt; ls1 ={1,2,3,4,5};\nlist&lt;int&gt; ls2 ={10,20,30,40,50};\nls2.splice(ls1.begin(),ls2); //和ls1.splice(ls1.begin(),ls2); 等价\n \nfor(auto &amp;p : ls1)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}\n//输出 10 20 30 40 50 1 2 3 4 5\n//此时ls2的情况: 空\n\nsplice(iterator_pos, otherList, iter1): 从 otherList转移 iter1 指向的元素到当前list。元素被插入到 iterator_pos指向的元素之前。\n\nlist&lt;int&gt; ls3 ={10,20,30};\nlist&lt;int&gt; ls4 ={3,5,7,8};\nauto it = ls3.begin();\nadvance(it,1);\nls3.splice(it,ls4,ls4.begin());\nfor(auto &amp;p : ls3)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}    \ncout &lt;&lt;endl;\n//ls4\nfor(auto &amp;p : ls4)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}\n//输出:\n//10 3 20 30\n//5 7 8\n\nsplice(iterator_pos, otherList, iter_start, iter_end) : 从 otherList转移范围 [iter_start, iter_end) 中的元素到 当前列表。元素被插入到 iterator_pos指向的元素之前。\n\nlist&lt;int&gt; ls5 ={1,2,3,4,5};\nlist&lt;int&gt; ls6 ={10,20,30,40,50};\nauto it2 = ls6.begin();\nadvance(it2,2); \nauto it3 = ls5.begin();\nauto it4 = ls5.end();\nadvance(it3,1); \nadvance(it4,-2); \nls6.splice(it2,ls5,it3,it4);\nfor(auto &amp;p : ls6)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n//ls5\nfor(auto &amp;p : ls5)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n//输出: \n// 10 20 2 3 30 40 50 \n// 1 4 5"},"C++/STL/Map-映射":{"slug":"C++/STL/Map-映射","filePath":"C++/STL/Map 映射.md","title":"Map 映射","links":["tags/STL","tags/容器","tags/哈希"],"tags":["STL","容器","哈希"],"content":"STL 容器 哈希\n1.6 映射 map\ninclude &lt;map&gt;\n\n提供对数时间的有序键值对结构[任意类型的映射];\n\nmap&lt;string,int&gt; a;\na[&quot;qaq&quot;] = 1;\na[&quot;abc&quot;] = 2;\na[&quot;mmp&quot;] = 3;\n\nkey[键]:的概念\n\na[key] = value;\nkey 在映射中处于中括号内,表示提示map的元素\n\n性质\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n性质解释mapmultimapunordered_map互异性一个键仅可以在映射中出现一次✔❌（任意次）✔无序性键是没有顺序的❌（从小到大）❌（从小到大）✔\n1.6.1 构造及常用操作\nmap&lt;key,value&gt; mp;\n\n\n增/改:map[0] = 1\n\n\n\n倘若没有定义就直接访问map,就会返回一个初值(默认为0)\n\n\n\n查找元素[找的是 key]:mp.find()\\to返回这个元素的迭代器,若找不到,返回mp.end(尾迭代器)\n\n\n删除: mp.erase(元素)\n\n\n查找[找的是 key]:mp.count()\\to 返回的是元素数量\n\n\n清空判空同上\n\n\n1.6.2 遍历\n\n萌新式遍历[适合&lt;int int&gt;型]\n\nmap&lt;int , int&gt; mp;\nmp[6] = 3;\nmp[5] = 1;\nmp[7] = 3;\nmp[9] = 666;\nfor (size_t i = 0; i &lt; mp.size(); i++)\n{\n    cout &lt;&lt; mp[i] &lt;&lt;endl;\n}\n\n缺点很明显,给个图就明白了\n\n\n\n迭代器式遍历\n\nstring a;\nmap&lt;string , int&gt; mp;\nmp[&quot;aaa&quot;] = 1;\nmp[&quot;bbb&quot;] = 5;\nmp[&quot;tsts&quot;] = 3;\nfor (map&lt;string , int&gt;::iterator it = mp.begin() ;it != mp.end() ; it++)\n{\n    cout &lt;&lt; it-&gt;second &lt;&lt;endl;\n}\n\n这个遍历器指向一个键对,所以得用 it-&gt;first或 it-&gt;second来判断指向的哪一个\n\n\nauto范围遍历\n\nstring a;\nmap&lt;string , int&gt; mp;\nmp[&quot;aaa&quot;] = 1;\nmp[&quot;bbb&quot;] = 5;\nmp[&quot;tsts&quot;] = 3;\nfor(auto &amp;el:mp)\n{\n    cout &lt;&lt; el.first &lt;&lt; &quot; &quot; &lt;&lt;el.second&lt;&lt;endl;\n}\n1.6.3 适用范围\n\n维护特殊的映射[string \\to int]\n\n\n统计输入的字符串组中每个字符串出现的次数\n\nmap&lt;string ,int&gt; mp;\nvector&lt;string&gt; vec;\nvec.push_back(&quot;aqa&quot;);\nvec.push_back(&quot;aqa&quot;);\nvec.push_back(&quot;qaq&quot;);\nvec.push_back(&quot;qaq&quot;);\nvec.push_back(&quot;wqw&quot;);\nvec.push_back(&quot;aqa&quot;);\nvec.push_back(&quot;qaq&quot;);\n \nfor (size_t i = 0; i &lt; vec.size(); i++)\n{\n    mp[vec[i]]++;\n}\nfor (auto &amp;el : mp)\n{\n    cout &lt;&lt; el.first &lt;&lt; &quot; &quot; &lt;&lt;el.second&lt;&lt;endl;\n}\n\n\n效果如此\n\n1.6.4 注意事项\n\n空map会返回一个默认值\n不能使用遍历器找下标\n\n\nunordered_map无序map 也称哈希表，我们可以随意的建立映射关系，时间复杂度是O(1)\n"},"C++/STL/Pair-二元组":{"slug":"C++/STL/Pair-二元组","filePath":"C++/STL/Pair 二元组.md","title":"Pair 二元组","links":["tags/STL","tags/容器","C++/STL/Map-映射","C++/STL/Vector"],"tags":["STL","容器"],"content":"STL 容器\n1.8 二元组 pair\n构造\npair&lt;int, int&gt; pr;\n1.8.1 常用方法\n\n\n赋初值: pair&lt;int , int&gt; pr = {1,2}\n\n\n老式: pair&lt;int , int&gt; pr2 = make_pair(1,2)\n\n\n判同 : pr == pr2\n\n\n三元组曲线救国法:pair&lt;pair&lt;int,char&gt;,char&gt; p3;\n\n\n访问第一个值 .first\n\n\n访问第二个值 .second\n\n\n1.8.2 适用范围\n适用于所有需要二元组的场景,效率和自己定义结构体差不多\n1.8.3 临时拆分二元组\n我们可以使用语法 auto [f,s] = pr来将pair的两个元素起到临时拆分的作用，同时在范围for循环里也可以使用这个对由pair构成的容器进行拆分\n\n下面罗列一些我清楚的\nMap 映射 Vector构成的pair数组\n\nfor(auto &amp;&amp;[a,b] : mp){\n\t/*\n\t对 a 和 b 的操作\n\t*/\n}\n\n\n                  \n                   .first b代表 .second ,而对于 map而言，a代表 key ， b代表值\n                  \n                \n对 auto 拆分的pair而言，[a,b]内 a代表 \n"},"C++/STL/Priority_queue-优先队列":{"slug":"C++/STL/Priority_queue-优先队列","filePath":"C++/STL/Priority_queue 优先队列.md","title":"Priority_queue 优先队列","links":["tags/STL","tags/队列"],"tags":["STL","队列"],"content":"STL 队列\n1.4 优先队列(堆) priority_queue\ninclude &lt;queue&gt;\n1.4.1 构造\npriority_queue&lt;类型,容器,比较器&gt;\n\n类型:要储存的数据类型\n容器:储存数据的底层容器,默认为 vector&lt;T&gt;,竞赛时保存默认即可\n比较器: 比较大小使用的比较器,默认为 less&lt;T&gt;,可以自定义\n\npriority_queue&lt;int&gt; pque1;\npriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pque2;//变小顶堆\n\n自定义比较器尽量不用,容易犯迷糊\n\n1.4.2 常用语法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例进堆.push(元素)que.push(1);出堆.pop()que.pop();取堆顶(最大值/最小值).top()int a = que.top();查看大小/判空和vector一致略\n\n\n                  \n                  Note\n                  \n                \n\n\n进出堆复杂度O(\\log n),取堆顶O(1)\n\n\n\n适用场景\n\n保持数据的有序性,每次向队列中插入大小不定的元素,或每次从队列取出最大/最小的元素,元素数量为n,插入操作数量为k\n\n使用快排:k\\cdot n \\log n\n使用优先队列:k\\cdot \\log n\n\n\n\n1.4.3 注意事项\n\n仅堆顶可读\n\ncout &lt;&lt; qpue[1] &lt;&lt;endl; //错误\n\n所有元素不可写\n\nqpue[1] = 2;\npque.top() = 1;\n//均为错误\n但如果要修改堆顶元素\nint tp = pque.top(); //保存堆顶\npque.pop(); //弹出堆顶\nqpue.push(tp + 1); //通过保存的堆顶修改堆顶"},"C++/STL/Queue-队列":{"slug":"C++/STL/Queue-队列","filePath":"C++/STL/Queue 队列.md","title":"Queue 队列","links":["tags/容器","tags/STL","tags/队列","C++/STL/Stark-栈","C++/STL/Priority_queue-优先队列"],"tags":["容器","STL","队列"],"content":"容器 STL 队列\n1.3 队列 queue\n\nincloud &lt;queue&gt;\n\n通过二次封装双端队列，实现先进先出(双端获取)的数据结构\n1.3.1常用方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例构造queue&lt;类型&gt; quequeue&lt;int&gt; que进队que.push(元素)que.push(1)出队.pop()que.pop()取队首.front()int a = que.front()取队尾.banc()int a = que.back()查看大小.size()int a = que.size()清空.clear()que.clear()判空.empty()que.empty()\n1.3.2 注意事项\n不能访问内部元素! 示例同2.4 写栈的注意事项\n\n有一类特殊的队列容器Priority_queue 优先队列可以做到将队列内的元素以O(\\log n)的速度读入并排序\n"},"C++/STL/STL":{"slug":"C++/STL/STL","filePath":"C++/STL/STL.md","title":"STL","links":["tags/STL","C++/STL/迭代器","C++/STL/STL算法函数"],"tags":["STL"],"content":"STL\nC++ STL（Standard Template Library，标准模板库）是C++编程语言的一部分，提供了丰富的数据结构和算法，旨在提高代码的复用性和效率。STL由容器、迭代器、算法和函数对象四个主要组件构成。\n\n容器：用于存储和管理一组对象的数据结构，如vector（动态数组）、list（双向链表）、set（有序集合）、map（键值对映射）等。\n迭代器：用于遍历容器中的元素，提供了一种统一的方式访问不同类型的容器。\n**STL算法函数：实现了许多常用的计算任务，如排序、搜索、复制等，这些算法可以独立于具体的容器类型工作。\n函数对象：也称为仿函数，是一种行为类似于函数的对象，可以用作算法的参数，从而实现更灵活的操作。\nSTL的设计理念是泛型编程，通过使用模板技术使得代码更加通用和高效。这种抽象层次的提升不仅简化了编程过程，还促进了代码的模块化和可维护性。\n\n\n优点：更加简短的代码语句，调试方便\n缺点：有些时候用更复杂的方式进行算法实现\n"},"C++/STL/STL算法函数":{"slug":"C++/STL/STL算法函数","filePath":"C++/STL/STL算法函数.md","title":"STL算法函数","links":["tags/STL","tags/函数类"],"tags":["STL","函数类"],"content":"STL 函数类\n6.3 STL函数\n对容器操作类\n\nsort(iterator_begin,iterator_end,cmp) 快速排序\nfind：顺序查找。find(iterator_begin, iterator_end, value)，其中 value 为需要查找的值。\nreverse：翻转数组、字符串。reverse(iterator_begin, iterator_end()) 或 reverse(a + begin, a + end)。\nunique：去除容器中相邻的重复元素。unique(ForwardIterator first, ForwardIterator last)，返回值为指向 去重后 容器结尾的迭代器，原容器大小不变。与 sort 结合使用可以实现完整容器去重。\nmove:  可以高效赋值容器，当你确定某一个容器在后面不需要被使用时可以使用 move来降低时间复杂度，尤其是对vector&lt;pair&lt;int,int&gt;&gt; 这类复杂容器而言\n\n    for(auto &amp;&amp;i : f){\n        set&lt;int&gt; temp = dp;\n        for(auto &amp;&amp;j : dp){\n            temp.emplace(i+j);\n        }\n        dp = move(temp);\n    }\n\n这是一个求一个数组取任意个数个数字相加的板子，其中使用到 move(temp) 就起到了降低时间复杂度的作用\n\n对容器改动类\n\n().emplace()   ().emplace_back()\n\nemplace 是 C++11 引入的标准容器函数，用于直接在容器中构造对象，而不是先创建对象再插入。它适用于几乎所有 STL 容器（如 vector, set, map, deque 等），提供了比 insert 更高效的方式。\n例子：我们可以直接在 set&lt;pair&lt;int,int&gt;&gt; 后插入 (x,y)\n\n\n\n    set&lt;pair&lt;int,int&gt;&gt; st;\n    //传统办法\n    st.insert(make_pair(x,y));\n    //emplace办法\n    st.emplace(x,y);\n\n对 vector而言，emplace_back() 几乎可以完全代替 push_back()  而emplace 则能代替 insert\n\n    vector&lt;pair&lt;int,int&gt;&gt; v\n    v.push_back(make_pair(x,y)) == v.emplace_back(x,y);\n    v.insert(v.begin(), make_paie(x,y)) == v.emplace(v.begin(),x,y)"},"C++/STL/Set-集合":{"slug":"C++/STL/Set-集合","filePath":"C++/STL/Set 集合.md","title":"Set 集合","links":["tags/STL","tags/容器"],"tags":["STL","容器"],"content":"STL 容器\n1.5 集合set\n提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n集合三要素解释setmultisetunordered_set确定性一个元素要么在集合中，要么不在✔✔✔互异性一个元素仅可以在集合中出现一次✔❌（任意次）✔无序性集合中的元素是没有顺序的❌（从小到大）❌（从小到大）✔\n1.5.1 常用操作\n\n\n函数构造 set&lt;类型,比较器&gt;\n\n\n插入元素 st.insert(元素)\n\n\n删除元素 st.erase(元素)\n\n\n查找元素 st.find(元素)\n\n\n查找元素个数 st.count\n\n\n1.5.2 遍历\n可以使用遍历器来遍历set数据:\nset&lt;int&gt; st;\nfor (set&lt;int&gt;::iterator it = st.begin() ; it != st.end();++it )\n{\n    cout &lt;&lt; *it &lt;&lt;endl;\n}\n基于范围的循环:\nfor(auto &amp;ele : st)\n{\n    cout &lt;&lt; ele &lt;&lt; endl;\n}\n1.5.3适用范围\n\n元素的去重 [1,1,2,3,3,5,7] \\to [1,2,3,5,7]\n元素顺序的维护 [1,6,8,4,1] \\to [1,4,6,8]\n元素大小很大但数量很少的情况(大小:[-10^18^,10^18^],数量10^6^)\n\n1.5.4 注意事项\n\nset数据不存在下标的说法,但可以用遍历器找数据:\n\nset&lt;int&gt;::iterator it = st.begin();\nadvance(it,2); //迭代器后面会讲\ncout &lt;&lt; *it &lt;&lt;endl;\n\n元素都是只读的,set迭代器提取的元素都是只读的(因为是const迭代器),不能够修改它的值,需要先erase再inset\n\ncout &lt;&lt; *st.begin() &lt;&lt;endl; //正确\n*st.begin() = 1; //错误,不可写\n\n不可用迭代器计算下标\n\nset 的迭代器不能像 vector 一样相减得到下标。下面是错误用法：\nauto it = st.find(2);      // 正确，返回2所在位置的迭代器。\nint idx = it - st.begin(); // 错误！不可相减得到下标。"},"C++/STL/Stark-栈":{"slug":"C++/STL/Stark-栈","filePath":"C++/STL/Stark 栈.md","title":"Stark 栈","links":["tags/STL","tags/栈","tags/容器","ACM/算法/深度优先搜索-DFS"],"tags":["STL","栈","容器"],"content":"STL 栈 容器\n栈 stack\n头文件：&lt;stark&gt;\n2.1 构造方式\nstack&lt;double&gt; stk[stk是栈名]；\n2.2 进栈与出栈及取栈顶部\n\n进栈：stk.push(x);[将x放入栈中]\n出栈：stk.pop();[栈顶出栈]\n取栈顶：stk.top()[获取栈顶\n\n2.3 用vector模拟stack\n使用dp.back()取栈(容器)顶\n2.4 写栈的注意事项\n\n不能访问栈的内部元素 \n下面都是错误用法\n\nstack&lt;int&gt; stk;\nfor(int i = 1;i &lt; stk.size();i++)\n{\n    cout &lt;&lt; stk[i]&lt;&lt;endl;\n}\nfor(auto ele : stk)\n{\n    cout &lt;&lt; stk &lt;&lt;endl;\n}\n\n2.5 与 vector 相比 stack的优势是什么？\n\nstack效率是高于vector的\nstack的内存占用更低\n在某些算法实现下(如深度优先搜索 DFS)，stack可能是更自然的选择\n"},"C++/STL/String-字符串":{"slug":"C++/STL/String-字符串","filePath":"C++/STL/String 字符串.md","title":"String 字符串","links":["tags/STL","tags/容器","tags/字符串"],"tags":["STL","容器","字符串"],"content":"STL 容器 字符串\n1.7 字符串string\n1.7.1 常用方法\n\n\n构造: string str;\n\n\n输入: cin &gt;&gt; str;\n\n\n输出:cout &lt;&lt; str;\n\n\nstring 的初值构造 string str(100,&#039;0&#039;)\n\n\n赋值 str = &quot;awa&quot;;\n\n\n判断相等 str1 == str2\n\n\n修改字符 str[0] = &quot;a&quot;\n\n\n连接字符串 str1 + str2;\n\n\n字符串尾接 str1 += &quot;awa&quot;;\n\n\n取子串:\n\n\nstring s1 = &quot;123123123&quot;;\ncout &lt;&lt; s1.substr(3) &lt;&lt;endl; //从第三位开始输出到末尾\ncout &lt;&lt; s1.substr(3,4) &lt;&lt;endl; //从第三位输出,输出4位 \n\n查找函数 : find(字串)  \\to 返回字串起始点的下标[若找不到,则会返回一个 string::npos]\n对上面一条：返回的是下标，是size_t类型的数字!\n\n6.1.7.2 string 转化\n\n\nstr \\to int : int x = stoi(str)\n\n\nstr \\to long long : long long x =stoll(str)\n\n\nstr \\to float : stof()\n\n\nstr \\to double : stod()\n\n\nstr \\to long double : stold()\n\n\nint \\to str : string str = to_string(x)\n\n\n6.1.7.3 注意事项\n\n尾接要用 += [使用 str = str + &quot;awa&quot;很慢]\n.substr()方法下,第一个参数传的是字串起点下标,第二个是字串长度\n.find()的实现是暴力枚举,复杂度是O(n^2)\n"},"C++/STL/Vector":{"slug":"C++/STL/Vector","filePath":"C++/STL/Vector.md","title":"Vector","links":["tags/STL","tags/容器","C++/STL/Pair-二元组"],"tags":["STL","容器"],"content":"STL 容器\n1 vector\n构造\n一维数组： vector&lt;类别&gt; dp(长度，初值) [^5]\n二维数组：vector&lt;vector&lt;int&gt;&gt; dp(行数,vector&lt;int&gt; (列数,初值)); \n三维数组：\n vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp3(3层,vector&lt;vector&lt;int&gt;&gt;(行数,vector&lt;int&gt; (列数,0)));\n等价于 int mat[][][]\n\n\n                  \n                  Note\n                  \n                \n\n\n我们也可以使用 vector&lt;vector&lt;int&gt;&gt; dp(100,vector&lt;int&gt;())来构建不指定列数的二维数组\n\n\n\n1.1 尾接与尾删\n\n尾接： dp.push_back(x)[解释：在dp数组末尾添加数字x]\n尾删：dp.pop_back(x)[解释：在dp数组末尾删除数字x]\n\n1.2 size函数\n\ndp.size()[解释：获取dp数组的长度(数组内有多少个数)]\n\n1.3清空数组\n\ndp.clear()[清空数组内数据]\n\n1.4 empty函数\n使用dp.empty()判断数组是否为空，空返回true(1)，非空返回false(0)\n一般这个函数会放在if语句中\nif(dp.empty()) //如果数组为空，则执行语句\n{\n    //....\n}\n1.5  resize函数\n\ndp.resize(m,n)[m表示新大小，n表示：如果增加长度，多出来的位置的默认数字]\n注意resize函数改小的话，会将多出来的数据删除\n\n1.6 访问vector的数据\n\n使用dp[x],访问dp数组内x-1的数据\n\n1.7 vector的赋值与读取\n\n一维数组的赋值\n\n\n方法一(推荐)\n\nvector&lt;int&gt; dp(10,0);\nfor(int i = 0;i &lt; k; i++)\n{\n    int temp;\n    cin &gt;&gt; temp;\n    dp.pish_back(temp);\n}\n\n方法二(不推荐)\n\nvector&lt;int&gt; dp(10,0);\nfor(int i = 0;i &lt; k; i++)//k不能大于10(k &gt; 10 也可以读入dp,但是会有诡异的bug)\n{\n    cin &gt;&gt; dp[i];\n}\n\n\n                  \n                  Note\n                  \n                \n\n\n所以动态读写一套下来为：\n\n\n\n&gt; vector&lt;int&gt; dp(0,0);\n&gt; for (size_t i = 0; i &lt; 15; i++)\n&gt; {\n&gt;     int temp;\n&gt;     cin &gt;&gt; temp;\n&gt;     dp.push_back(temp);\n&gt; }\n&gt; \n&gt; for (size_t i = 0; i &lt; dp.size(); i++)\n&gt; {\n&gt;     cout &lt;&lt; dp[i] &lt;&lt;&quot; &quot;;\n&gt; }\n\n二维数组动态读写\n\n\n\n                  \n                  Note\n                  \n                \n\n&gt; vector &lt;vector&lt;int&gt;&gt; dp;\n&gt; vector&lt;int&gt; dp1;\n&gt; for (int i = 0; i &lt;k; i++)    \n&gt; {\n&gt;     for (int j = 0; j &lt;p; j++) //内部数组保存\n&gt;     {\n&gt;         int value;\n&gt;         cin &gt;&gt; value;\n&gt;         v.push_back(dp1); \n&gt;     }\n&gt;     dp.push_back(dp1); //保存dp1的每个元素到dp[i]中\n&gt;     dp1.clear(); //清空dp1内元素\n&gt; }\n&gt; \n&gt; for (int i = 0; i &lt;array.size(); i++)\n&gt; {\n&gt;     for (int j = 0; j &lt; p; j++)\n&gt;     {\n&gt;         cout &lt;&lt;array[i][j];\n&gt;     }\n&gt;     cout&lt;&lt;endl;\n&gt; }\n&gt; return 0;\n\n\n思路：先建立动态二维数组dp和动态临时一维数组dp1\ndp1负责保存单行数据\ndp负责保存dp1保存下来的行数据从而形成多数据\n记得clear dp1的元素\n\n\n1.8 vector的使用情况\n\n\n例：n\\times m 的矩阵，1\\leq n,m\\leq 10^6 且 n\\times m \\leq 10^6\n\n\n普通数组就是 int arr[100010][100010]，直接炸内存(MLE)\n\n\n动态数组就可以 vector&lt;vector&lt;int&gt;&gt; dp(n+10,vector&lt;int&gt; (m+10,0))\n\n\n在读取了m,n后再设立数组，解决了炸内存的尴尬\n\n\n虽然有时候我也会用 int arr[m+10][n+10] 来写数组(好孩子不要学)\n\n\nvector储存在堆空间，不会炸栈\n\n\n1.9 注意事项\n\n提前规定长度\nvector的push_back逻辑是，当超过长度时会消耗时间进行重分配\n\n// 优化前: 522ms\nvector&lt;int&gt; a;\nfor (int i = 0; i &lt; 1e8; i++)\n{\n    a.push_back(i);\n}\n// 优化后: 259ms\nvector&lt;int&gt; a(1e8);\nfor (int i = 0; i &lt; a.size(); i++)\n{\n\ta[i] = i;\n}\n\n小心size_t溢出\n\nvector 获取长度的方法 .size() 返回值类型为 size_t，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 [0,2^{32}).\nvector&lt;int&gt; a(65536);\nlong long a = a.size() * a.size(); // 直接溢出变成0了\n1.10 和其他容器的组合技\n\n和Pair 二元组\n\nvector&lt;pair&lt;int,int&gt;&gt; dp1(10);\npair&lt;int,int&gt; p1;\nfor (size_t i = 0; i &lt; 5; i++)\n{\n    cin &gt;&gt; p1.first &gt;&gt; p1.second;\n    dp1[i] = p1;\n}\nint k;\ncin &gt;&gt; k;\nfor (size_t i = 0; i &lt; dp1.size(); i++)\n{\n    if (k == dp1[i].first)\n    {\n        cout &lt;&lt; dp1[i].second;\n    }\n}\n\n\n                  \n                  Tip\n                  \n                \n\n\n**dp[i]**可以作为一个二元组绑死.first和.second\ndp容器可以起到结构体的作用\n\n\n"},"C++/STL/迭代器":{"slug":"C++/STL/迭代器","filePath":"C++/STL/迭代器.md","title":"迭代器","links":["tags/STL","tags/迭代器"],"tags":["STL","迭代器"],"content":"STL 迭代器\n6.2 迭代器(遍历器)\n\n概念：迭代器是一种检查容器内元素并遍历元素的数据类型，通常用于对C++中各种容器内元素的访问，但不同的容器有不同的迭代器，初学者可以将迭代器理解为指针。\n迭代器可以干嘛？\n\nint main()\n{\n    vector&lt;int&gt; arr;\n    for (size_t i = 0; i &lt; 10; i++)\n    {\n        arr.push_back(i);\n    }\n    for(vector&lt;int&gt;::iterator it = arr.begin(); it != arr.end();it++)\n    {\n        cout &lt;&lt; *it &lt;&lt;endl;\n    }\n \n    return 0;\n}\n\n我们观察上面这个程序，这是它的输出结果\n\n\n\n不难发现，这个数组被遍历输出了\n\nfor(vector&lt;int&gt;::iterator it = arr.begin(); it != arr.end();it++)这一行\nvector&lt;int&gt;::iterator it = arr.begin(); \\to 创立了一个迭代器，vector&lt;int&gt;::iterator表明创立了一个vector迭代器 it是迭代器名称 arr.begin()是数组的头迭代器\n迭代器之间也可以用比较运算符 ==or !=\n迭代器也可以使用自增运算 \\to it++\n\n\n常用容器的迭代器\n\n==vector ——随机访问迭代器==\ndeque——随机访问迭代器\n==list —— 双向迭代器==\nset / multiset——双向迭代器\nmap / multimap——双向迭代器\nstack——不支持迭代器\nqueue——不支持迭代器\n\n下面主要讲解随机访问迭代器 双向迭代器\n\n双向迭代器\n\nvoid text()\n{\n\tlist&lt;int&gt; lst;\n\tfor (int i = 0; i &lt; 10; ++i)\n\t{\n\t\tlst.push_back(i);\n\t}\n\tlist&lt;int&gt;::iterator it;//创建list的迭代器\n\tcout &lt;&lt; &quot;遍历lst并打印: &quot;;\n\tfor (it = lst.begin(); it != lst.end(); ++it)//用 != 比较两个迭代器\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\t}\n\t//此时it=lst.end(),这个位置是最后一个元素的下一个位置，没有存储数据\n\t--it;//等价于it--，回到上一个位置\n\t//it -= 1; //报错,虽然都是-1，但这种方式是随机迭代器才有的功能\n\tcout &lt;&lt; &quot;\\nlst的最后一个元素为：&quot; &lt;&lt; *it &lt;&lt; endl;\n}\n\n随机迭代器\n\nvoid text()\n{\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 10; ++i)\n    {\n        v.push_back(i);\n    }\n    vector&lt;int&gt;::iterator it;\n    for (it = v.begin(); it != v.end(); ++it) //用 != 比较两个迭代器\n    {\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n    for (it = v.begin(); it &lt; v.end(); ++it) //用 &lt; 比较两个迭代器\n    {\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n    it = v.begin();//让迭代器重新指向首个元素的位置\n    while (it &lt; v.end())//间隔一个输出\n    { \n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n        it += 2; // 用 += 移动迭代器\n    }\n    cout &lt;&lt; endl;\n \n    it = v.begin();\n    cout &lt;&lt; it[5] &lt;&lt; endl; //用[]访问\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n\n对vector数组迭代器来说，迭代器可以用 +x来表示，但对双向迭代器如list，上述操作就不可取，可以用下面函数的方法来移动迭代器\n\n\n\n\n迭代器的辅助函数\nSTL 中有用于操作迭代器的三个函数模板，它们是：\n\n\nadvance(it, n)；使迭代器 it 向前或向后移动 n 个元素。\n\n\ndistance(it1, it2)；计算两个迭代器之间的距离，即迭代器 it1 经过多少次 + + 操作后和迭代器 it2相等。如果调用时 it1 已经指向 it2 的后面，则这个函数会陷入死循环。\n\n\niter_swap(it1, it2)；用于交换两个迭代器 it1、it2 指向的值。\n要使用上述模板，需要包含头文件\n\n\n#include&lt;algorithm&gt;"},"C++/基础语法/C++语言入门":{"slug":"C++/基础语法/C++语言入门","filePath":"C++/基础语法/C++语言入门.md","title":"C++语言入门","links":["tags/define","C++/基础语法/函数"],"tags":["define"],"content":"C++\nC++语言是一门广泛被使用的语言，学习C语言，可以使我们更加深入的了解到编程语言的运行方式和底层逻辑，下面，让我们从零开始，学习C++\n\n1 C++语言入门\n1.1 第一个C++程序\n我们利用C++输入 hello world\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main()\n{\n    cout &lt;&lt; &quot;hello world&quot;&lt;&lt; endl;\n \n    system(&quot;pause&quot;);\n    \n    return(0);\n}\n\n1.2 C++程序的注释\n\n单行注释\n\n使用//来注释一行代码\n\n\n多行注释\n\n使用/* ...... */来多行注释\n\n\n例子\n\n#include &lt;iostream&gt;     \n \n/* 这是一个头文件\n用于给定指定函数名称*/\n \nusing namespace std;    \nint main()\n{\n    cout &lt;&lt; &quot;hello world&quot;&lt;&lt; endl; //输出hello world\n \n    system(&quot;pause&quot;);\n    \n    return(0);\n}\n\n1.3 变量\n\n作用：给定一段指定的内存空间取名以方便我们操纵这段内存\n语法：数据类型 变量名 = 初始值(int a =10)\n实例\n\n#include &lt;iostream&gt;     \nusing namespace std;\nint main()\n{\n    int a = 10;\n    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n此时C++会输出“a=10”\n\n1.4 常量\n作用：用于记录程序中不可更改的数据\nC++有两种定义常量的方法\n\n\ndefine 宏常量：#define 常量名 = 常量值\n\n通常在代码文件上方定义,表示一个常量\n\n\n\nconst修饰的变量：const 数据类型 常量名 =常量值\n\n通常在变量定义加关键字const,修饰该变量为常量，不可更改\n\n\n\n示例1：\n#include &lt;iostream&gt;     \nusing namespace std;\n \n#define day 7\nint main()\n{\n    cout&lt;&lt;&quot;一周有&quot;&lt;&lt;day&lt;&lt;&quot;天&quot;&lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n如果我们强加的去修改day的值，C++则会报错,说明我们的改动不合规矩\n\n\n示例2：\n#include &lt;iostream&gt;     \nusing namespace std;\n \n#define day 7\nint main()\n{\n    const int year = 365;     //这里修饰了year，后面无法修改\n    cout&lt;&lt;&quot;一周有&quot;&lt;&lt;day&lt;&lt;&quot;天&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;一年有&quot;&lt;&lt;year&lt;&lt;&quot;天&quot;&lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n1.5 关键字\n\n关键字是C++内置的函数或字符名称，我们在创建变量时不用用关键字来给变量来命名\n\n1.6 标识符命名规则\nC++在对标识符(变量，常量)命名时有一套规则，具体如下：\n\n标识符不可以是关键字\n标识符只能由数字，字母，下划线构成\n第一个字符必须为字母或下划线\n标识符大小写敏感\n\n\n建议是标识符名称要通俗易懂，做到见名知意的效果\n\n"},"C++/基础语法/函数":{"slug":"C++/基础语法/函数","filePath":"C++/基础语法/函数.md","title":"函数","links":[],"tags":[],"content":"6 函数\n6.1 概述\n作用： 将经常使用的一段代码封装起来，减少重复代码\n\n一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能\n\n6.2 函数的定义\n一般函数定义有5个主要步骤\n\n返回值类型\n函数名\n参数列表\n函数体语句\nreturn表达式\n\n语法\n//返回值类型 函数名(参数列表)\nint isprime(int n)\n{\n    //函数体语句\n    \n    //return表达式\n    return 0;\n}\n \n\n实例1\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint add(int a , int b) \n{\n    int sum = a+b;\n    return sum;\n}\n \nint main()\n{\n    int num1,num2;\n    scanf(&quot;%d %d&quot;,&amp;num1,&amp;num2);\n    printf(&quot;%d&quot;,add(num1,num2));\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n\na,b 我们可以称为形参，num1,num2 我们可以称为实参，函数调用本质是将实参传递给形参并进行函数运算，返回return值\n\n6.3 函数的调用\n功能： 使用定义好的函数\n语法：函数名(参数)\n6.4 值传递\n\n值传递就是函数调用时实参将数值转递给形参\n值传递时，形参发生变化，并不会影响实参\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nvoid swap(int a,int b) //在无需返回值时，可以输入viod类型\n{\n    int temp = a;\n    a = b;\n    b =temp;\n    cout &lt;&lt; &quot;交换后:&quot;&lt;&lt;a &lt;&lt;&quot; &quot;&lt;&lt;b &lt;&lt;endl;\n    return;\n}\n \nint main()\n{\n    int i1 = 4;\n    int i2 = 5;\n    cout &lt;&lt;&quot;交换前:&quot;&lt;&lt;i1&lt;&lt;&quot; &quot;&lt;&lt;i2&lt;&lt;endl;\n    swap(4,5);\n}\n\n\n                  \n                  Note\n                  \n                \n\n\n在值传递的时候，为实参和形参分别分配内存空间，将实参的内存传递给形参，进而使用形参的内存去执行函数，实参的内存不会发生改变\n\n\n\n6.5 函数的常见样式\n\n无参无返\n有参无返\n无参有返\n有参有返\n\n\n实例\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \n//1.无参无返\nvoid test_01()\n{\n    cout &lt;&lt; &quot;跟你爆了&quot;&lt;&lt;endl;\n    return;\n}\n \n//2.有参无返\nvoid test_02(int a)\n{\n    cout &lt;&lt; a*a &lt;&lt;endl;\n    return;\n}\n \n//3.无参有返\nint test_03()\n{\n    return 1000;\n}\n \n//4.有参有返\nint test_04(int k)\n{\n    return (k*2)+k;\n}\n \nint main()\n{\n    test_01();\n    test_02(4);\n    int num1 = test_03();\n    cout&lt;&lt;num1&lt;&lt;endl;\n    int m = test_04(4);\n    cout &lt;&lt;m &lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n6.6 函数的声明\n作用： 告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义\n\n函数可以声明多次，但函数的定义只能有一次\n\n示例：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \n//声明\nint max01(int a,int b);\n \nint main()\n{\n    int t = max01(5,6);\n    cout &lt;&lt; t &lt;&lt; endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n \n//定义\nint max01(int a,int b)\n{\n    return a&gt;b ? a : b;\n}\n6.7 函数的分文件填写\n作用： 让代码结构更加清晰\n函数分文件编写一般有4个步骤\n\n创建后缀名为.h的头文件\n创建后缀名为.cpp的源文件\n在头文件中书写函数的声明\n在源文件中书写函数的定义\n\n示例\n//head.h\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nvoid swap(int a,int b);\n//fun.cpp\n#include&lt;bits/stdc++.h&gt;\n#include &quot;head.h&quot;\nusing namespace std;\n \nvoid swap(int a,int b)\n{\n    int temp = a;\n    a = b;\n    b = temp;\n    cout &lt;&lt; a &lt;&lt;&quot; &quot;&lt;&lt;b &lt;&lt; endl;\n}\n//test.cpp\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#include &quot;head.h&quot;\n \nint main()\n{\n    swap(4,5);\n    return(0);\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n在VScode中，C++编译只对test.cpp中的main函数进行编译，无法连接到我们的fun.cpp文件\n\n==解决方法:将头文件的文件目录复制到 .vscode目录下的tasks.json的”args”: 的”${file}“下面即可==\n注意复制的单斜杠要改为多斜杠\n\n\n\n\n"},"C++/基础语法/指针":{"slug":"C++/基础语法/指针","filePath":"C++/基础语法/指针.md","title":"指针","links":[],"tags":[],"content":"7 指针\n7.1 指针的基本概念\n指针的作用： 用于间接访问内存\n\n指针的编号是从0开始计数的，一般用16进制表示\n可以利用指针变量保存地址\n\n7.2 指针的定义和操控\n\n定义：数据类型 * 指针变量名\nint *p;(定义了个指针)\np = &amp;a(调用了指针)\n使用：可以使用解引用的方式来找到指针指向的内存\n*p(表示解引用)\n\nint main()\n{\n    int a = 10;\n    //创立指针\n    int *p;\n    //记录变量a的地址\n    p = &amp;a;\n    //解引用\n    cout &lt;&lt; *p&lt;&lt;endl;\n    *p = 1000; //指针也可以修改内存\n    cout &lt;&lt; a;\n    \n    return 0;\n}\n7.3 指针所占的内存空间\n\n在32位操作系统下，指针占用4字节\n\nint main()\n{\n   //指针的第二种写法\n   int a = 10;\n   int *p = &amp;a;\n \n   cout &lt;&lt; &quot;*p所占的内存为&quot;&lt;&lt;sizeof(int *); //我这里似乎是64位系统，所以输出结果是8\n   \n   return 0;\n}\n7.4 空指针与野指针\n\n\n**空指针 ：**指向内存中位0位的指针\n\n\n**野指针：**初始化指针\n\n\n空指针指向的的内存是无法被访问的\n\n\n**野指针：**指针指向非法的内存空间\n\n在没有申请内存的情况使用指针访问这串内存\n\n\n\n7.5 const修饰指针\n有三种情况：\n\nconst修饰指针\\to 常量指针\n\n\n指针的指向可以更改，但指针指向的值不可以改\n\n\n\n7.6 数组与指针的关系[原创]\n\n对于一个数组而言，我们可以把它理解为一段内存地址 + 一个指针: 其中，指针名就是指向第一个内存地址的指针\n\n\ta         [内存地址1][内存地址2][内存地址3].....\n|-&gt; 指针名字|-&gt;地址1\n|-----------------------&gt; 地址2\n重新审视数组定义：\nint arr[n] --&gt; 数组大小 *1\n | \t |--&gt; 数组名称 \t\t*2\n |-&gt; 数组类型\t\t\t*3\n再来审视一下指针定义\nint *p = NULL --&gt; 指针指向的变量\n |  |-&gt;指针名称\n |-&gt;指针类型\n\n那对于一个数组而言，我们不妨把数组名字当作一个指针名，而 [ ] 当作一个解指针+指针运算的方式\n\n*(p + 0) == p[0] \n\n\n                  \n                  Tip\n                  \n                \n\n\n\n注意: [ ]是确实存在的，并且不仅是数组可以使用，但是注意在定义指针数组的时候，int *p[a]这类的操作下[ ]的含义又变得不同\n\n\n\n\n那对一个二维数组而言，其本质就是一个二重指针，里层的指针指向元素，外层的指针指向里层的指针，两次[ ][ ]表示运算两次指针+解两次指针\n指针数组与数组指针"},"C++/基础语法/数据类型":{"slug":"C++/基础语法/数据类型","filePath":"C++/基础语法/数据类型.md","title":"数据类型","links":[],"tags":[],"content":"C++规定在创建一个标识符的时候必须指定其数据类型，否则无法对该标识符分配内存\n2.1 整型\nint 作用：整型变量表示的是整数类型的数据\nC++共有4种表示整型的方式，他们的区别在于占用空间的不同\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据类型占用空间取值范围short(短整型)2字节(-2^15^—2^15^-1)int(整型)4字节(-2^31^—2^31^-1)long(长整型)windows为4字节，Linux为4字节(32x)或8字节(64x)(-2^31^~2^31^-1)long long(长长整型)8字节(-2^63^~2^63^-1)\n2.2 sizeof 关键字\n作用： 利用sizeof关键字可以统计数据所占的内存大小\n语法：sizeof( 数据类型/变量 )\n示例:\n#include &lt;iostream&gt;     \nusing namespace std;\n \nint main()\n{\n    //可以利用sizeof求出数据类型占用多少内存空间\n    short num1 =10;\n    cout&lt;&lt;&quot;short占用的内存为&quot;&lt;&lt;sizeof(num1)&lt;&lt;endl;\n    int num2 = 10;\n    cout&lt;&lt;&quot;int占用的内存为&quot;&lt;&lt;sizeof(num2)&lt;&lt;endl;\n    long long num3 =10;\n    cout&lt;&lt;&quot;long long 占用的内存为&quot;&lt;&lt;sizeof(num3)&lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n此时输出的结果如下\n\n\n2.3实型（浮点型）\n**作用：**用于表示小数\n浮点型变量分为两种：\n\n单精度float\n双精度double\n\n两者的区别在于精度和占用内存不同\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据类型占用大小精度float4字节7位有效数字double8字节15~16位有效数字\n\n\n                  \n                  NOTE\n                  \n                \n\n\n在使用float时要注意语法float num1 = 3.14f,只有带上f后才会被认定为float类型，否则会按照默认的doubt类型赋值\n\n\n\n\n表示小数时也可以用科学计数法\n\nfloat f3 = 3e2;//3*10^2\ncout&lt;&lt;f3&lt;&lt;endl;\nfloat f4 = 3e-2;//3*10^-2\ncout&lt;&lt;f4&lt;&lt;endl;\n此时输出的结果便为：\n\n2.4 字符型\n\n\n作用 字符型变量用于显示单个字符\n\n\n语法: char ch = &#039;a&#039;\n\n\n\ntips1: 显示字符型变量的时候只能用单引号，不能用双引号\ntips2:单引号内只能有一个字符，不可以是字符串\n\n\n字符型变量只占用1字节\n字符型变量将变量以ASCII码的形式储存在内存里\n\n如何查看字符型变量的ASCII码\ncout &lt;&lt; (int)[变量名] &lt;&lt; endl\n\n常用ASCII码：a-97  A-65\n\n2.5 转义字符\n作用: 表示一些不能显示出来的ASCII字符\n常用的转义字符有：\\n \\\\ \\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n转义字符作用ASCII码\\n换行符010\\\\转义一个\\092\\t水平制表符(占8个位置)009\n2.6 字符串型\n\n作用: 用于表示一串字符\n\n两种风格\n\nC语言风格：char 变量名[]= &quot;字符串值&quot;\nC++风格：string 变量名=&quot;字符串值&quot;\n\nint main()\n{\n    char str/*字符串名*/[] = &quot;hello world&quot;; //tips1:字符串名后要加[]\n    cout &lt;&lt; str &lt;&lt;endl;\n    \n    string str2 = &quot;114514&quot;;   //要包含一个头文件#include &lt;string&gt; \n    cout&lt;&lt;str2&lt;&lt;endl;\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n\n\n                  \n                  IMPORTANT\n                  \n                \n\n\nC++风格字符串需要在开头加入头文件#include\n\n\n\n2.7 布尔类型(bool)\n**作用：**作用于条件判断，代表真或假\n\nbool类型只有两个值\nTrue——真(1)\nFalse——假(0)\nbool 占用1字节的内存空间\n\n示例：\nint main()\n{\n    bool flag = true ; //true代表真，本质上是&quot;1&quot;\n    cout&lt;&lt;flag&lt;&lt;endl;\n    bool flag2 = false ;//false代表假，本质是&quot;0&quot;\n    cout &lt;&lt; flag2&lt;&lt;endl;\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n而这块代码的输出结果\n\n2.8 数据的输入\n**作用：**从键盘上获取数据\n语法：cin &gt;&gt; 变量\n示例：\nint main()\n{\n    //整型\n    int a = 0;\n    cout &lt;&lt; &quot;请键入整型变量a的值&quot;&lt;&lt;endl;\n    cin &gt;&gt; a;\n    cout &lt;&lt;a&lt;&lt;endl;\n    //浮点型\n    float f =1.14f;\n    cout&lt;&lt;&quot;请给浮点型f赋值&quot;&lt;&lt;endl;\n    cin &gt;&gt; f;\n    cout &lt;&lt;f&lt;&lt;endl;\n    //字符串型\n    string str = &quot;hello world&quot;;\n    cout&lt;&lt;&quot;输入你的字符串值&quot;&lt;&lt;endl;\n    cin &gt;&gt; str;\n    cout&lt;&lt;str&lt;&lt;endl;\n \n     \n    system(&quot;pause&quot;);\n \n    return(0);\n}\n输出结果为:\n"},"C++/基础语法/数组":{"slug":"C++/基础语法/数组","filePath":"C++/基础语法/数组.md","title":"数组","links":[],"tags":[],"content":"5 数组\n5.1 概述\n数组就是一个集合，里面存放了相同类型的数据元素\n\n**特点1：**数组中每个数据元素都是相同的数据类型\n**特点2：**数组是连续的内存位置组成的\n\n5.2 一维数组\n5.2.1 一维数组的定义方式：\n一维数组有三种定义方式：\n\n数据类型 数组名[ 数组长度 ]\n数据类型 数组名[ 数组长度 ]={ 值1,值2,…}\n数据类型 数组名[]={ 值1,值2,…}\n\n示例1：\nint main()\n{\n    // 1. `数据类型 数组名[ 数组长度 ]`\n    int arr[5];\n    arr[0] = 10;\n    arr[1] = 20;\n    arr[2] = 30;\n    arr[3] = 40;\n    arr[4] = 50;\n    int a = 3;\n    cout &lt;&lt; arr[3] &lt;&lt; endl;//这个访问的是 40 \n    cout &lt;&lt; arr[ a ] &lt;&lt; endl; //数组的下标可以通过变量来索引\n    system(&quot;pause&quot;);\n    return(0);  \n}\n示例2：\nint main()\n{\n    //2.数据类型 数组名[ 数组长度 ]={ 值1,值2,…}\n    int arr2[5] = {10,20,30,40,50};\n    for (int i = 0; i &lt; 5; i++) // i &lt; 5 中，5表示数组长度\n    {\n        cout &lt;&lt; arr2[i] &lt;&lt; endl;\n    }\n    //若初始没有补齐数据，会用0来填充空余数据\n    system(&quot;pause&quot;);\n    return(0);  \n}\n示例3：\nint main()\n{\n    //3.数据类型 数组名[]={ 值1,值2,…}\n    //定义数组时必须要给定初始长度\n    int arr3[] = {1,1,4,5,1,4};\n    for (int i = 0; i &lt; 6; i++)\n    {\n        cout &lt;&lt; arr3[i]&lt;&lt;endl;\n    }\n    system(&quot;pause&quot;);\n    return(0);  \n}\n\n数组中的数据是从0开始标记(索引)下标\n我们可以通过下标来访问数组中的元素\n\n5.2.2 一维数组数组名\n用途：\n\n可以统计整个数组在内存中所占的长度\n可以获取数组在内存中的首地址\n\n\n对1：sizeof(数组名)\n我们可以用 `sizeof(arr)/sizeof(arr[0])来获取内存的长度\n\n\n对2：cout &lt;&lt; arr &lt;&lt;endl;\n一般该地址为16进制地址\n\nint main()\n{\n    //1。查询数组所占内存大小\n    int arr[6]={1,1,4,5,1,4};\n    cout &lt;&lt; &quot;数组大小为&quot;&lt;&lt; sizeof(arr)&lt;&lt;endl;\n    cout &lt;&lt; &quot;数组长度为&quot;&lt;&lt; sizeof(arr)/sizeof(arr[0])&lt;&lt;endl;\n    //2.查看首地址\n    cout &lt;&lt;&quot;内存地址&quot;&lt;&lt; arr &lt;&lt; endl;//16进制\n    cout &lt;&lt; (long long)arr &lt;&lt;endl;//强转10进制\n    cout &lt;&lt; &amp;arr[0]&lt;&lt;endl;//数组中某个元素的内存地址\n    cout &lt;&lt; (long long)&amp;arr[0] &lt;&lt;endl;//数组中某个元素的10进制内存地址\n    //使用 long long 包容16进制精度问题\n    cout &lt;&lt; &amp;arr[1]&lt;&lt;endl;//第二个元素位置\n    cout &lt;&lt; (long long)&amp;arr[1] &lt;&lt;endl;//10进制\n    //第二个与第一个相差4字节\n    //数组名是常量，不能修改赋值\n    system(&quot;pause&quot;);\n    return(0);  \n}\n练习案例1：\n\n\n在一个数组中记录了5个数据，arr[5] ={10,30,20,70,60}\n\n\n找出这个数组中最大数\n\n\nint main()\n{\n    int arr[5]= {10,30,60,40,20};\n    int max = 0; //假设某一最大值\n    for (int i = 0; i &lt; 5; i++)//访问数组中的每一个数\n    {\n        if (arr[i] &gt; arr[max]) //比较假设值和访问值大小\n        {\n            max = i ; //若大于，则替换假设最大值\n        }\n    }\n    //循环结束时，最大值以确定\n    cout &lt;&lt; &quot;最大的数是&quot; &lt;&lt; arr[max]&lt;&lt;endl; //输出\n    \n    system(&quot;pause&quot;);\n    return(0);  \n}\n\n\n                  \n                  Note\n                  \n                \n\n\n在上面代码中，for循环内部也可以使用三目运算来找最大值\nmax = (arr[max] &gt; arr[i] ? max : i ); //使用三目运算符\n\n\n\n\n**练习案例2：**数组元素逆置\n\n声明一个5个元素的数组，并将其逆置\n示例 : 原数组 {1,3,4,2,3}  ⇒ 输出{3,2,4,3,1}\n输出逆置\n\nint main()\n{\n    int arr[5] = {1,3,4,2,3};\n    for (int i = 0; i &lt; 5; i++)\n    {\n        cout &lt;&lt; arr[4-i] ; \n    }\n    cout &lt;&lt; endl;\n \n    system(&quot;pause&quot;);\n    return(0);  \n}\n\n创立逆置数组\n\nint main()\n{\n    int arr[5] = {1,3,4,2,3};\n    int arrt[5];\n    int t; //建立逆置变量\n    for (int i = 0; i &lt; 5; i++) \n    {\n        t = (sizeof(arr)/sizeof(arr[0]))-1-i; //实现逆置变量\n        arrt[i] = arr[t]; //实现原数组向逆置数组的赋值\n    }\n    //逆置数组建立完成，以下为检查\n    for (int i2 = 0; i2 &lt; 5; i2++)\n    {\n        cout &lt;&lt; arrt[i2] &lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n原数组的逆置\n\nint main()\n{\n    int arr[5] = {1,3,4,2,3};\n    int sta = 0;\n    int end = sizeof(arr)/sizeof(arr[0])-1;\n    int temp = 0;\n    //核心\n    for ( ; sta &lt; end ; )       //当起始值位置大于末尾值位置时停止\n    {\n        temp = arr[sta];        //初始值赋值至临时内存\n        arr[sta] = arr[end];    //末尾值赋值至初始值\n        arr[end] = temp;        //初始值(临时)赋值至末尾值\n        sta++;                  //初始值后移一位\n        end--;                  //末尾值前移一位\n    }\n    //数组倒置结束\n    for (int i2 = 0; i2 &lt; 5; i2++)\n    {\n        cout &lt;&lt; arr[i2]&lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n5.2.3 冒泡排序\n**作用：**最常用的排序算法，对数组内的元素进行排序\n\n比较相邻的元素，如果第一个比第二个大，就交换他们\n对每一对相邻元素做同样工作，执行完毕后，找到第一个最大值\n重复以上步骤，每次比较次数-1，直到不需要比较\n\n示例： 将数组{4,2,3,0,5,7,1,3,9}升序排列\nint main()\n{\n    int arr[9] = {4,2,3,0,5,7,1,3,9};\n    for (int i = 0; i &lt; (sizeof(arr)/sizeof(arr[0])-1); i++)//排序的总轮数=元素个数-1\n    {  \n        for (int j = 0; j &lt;(sizeof(arr)/sizeof(arr[0])-1)-i ; j++) //每轮排序的次数 = 元素个数 -1 -当前轮数\n        {\n            if (arr[j] &gt; arr[j+1] ) //判断相邻的两个数的大小\n            {\n                //实现交换\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    //输出验证\n    for (int i2 = 0; i2 &lt; 9; i2++)\n    {\n        cout &lt;&lt; arr[i2]&lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n利用遍历实现数据筛查\n题目来源洛谷P1085 [NOIP2004 普及组] 不高兴的津津\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n{\n\tint a,b,t;\n    int m =0; \n    int arr[7];\n    for (int i = 0; i &lt; 7; i++)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        int k =a +b;\n        arr[i] = k; //将获得的数据记入数组\n    }\n     //对数组遍历，找出最大的那个数\n    for (int j = 0; j &lt; 7; j++) //假设一个最大值 arr[0]，让arr[0]和下一个数比较，若大于，则将m赋值为j\n    {\n        if (arr[m] &lt; arr[j]) \n        {\n            m = j; \n            t = arr[j];\n        }\n    }\n    if ( t &gt; 8)\n    {\n        cout &lt;&lt; m+1 &lt;&lt;endl;\n    }\n    else\n    {\n        cout &lt;&lt; 0 &lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n5.3 二维数组\n5.3.1 二维数组的定义方式：\n\n数据类型 + 数组名[行数][列数];\n数据类型 + 数组名[行数][列数] = {数据1，数据2}，{数据3，数据4};[^2]\n数据类型 + 数组名[行数][列数] = {数据1，数据2，数据3，数据4};\n数据类型 + 数组名[][列数] = {数据1，数据2，数据3，数据4};\n第三和第四组会自动区分行列数(即从第一个数据开始计数，记到列数自动换行)\n\n\n5.3.2 二维数组的赋值方式\n\narr[0][0] = 元素;\narr[0][1] = 元素;\n……\n\n如何输出一个二维数组？\n\n写一个嵌套循环，外层打印行数，内层打印列数\n\nfor (int i = 0;i &lt; count ; i++)\n{\n    for(int j = 0;j &lt; count ; j++)\n    {\n        cout &lt;&lt; arr[i][j];\n    }\n    cout &lt;&lt; endl;\n}\n\n\n                  \n                  Note\n                  \n                \n\n\n\n直观表示一个二维数组 ：int arr[3][3];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n列\\行0列1列2列0行arr[0][0]arr[0][1]arr[0][2]1行arr[1][0]arr[1][1]arr[1][2]2行arr[2][0]arr[2][1]arr[2][2]\n行列式行列式，先行后列\n\n\n\n5.3.3 二维数组数组名\n\n查看二维数组所占内存空间\n获取二维数组首地址\n具体如下\n\nint main()\n{\n    int arr[3][3] =\n    {\n        {1,1,4},\n        {5,1,4}\n    };\n    //1.查看占用内存空间大小\n    cout &lt;&lt; sizeof(arr) &lt;&lt;endl; // out : 36 (6*6)\n    cout &lt;&lt; sizeof(arr[0][0]) &lt;&lt;&quot; &quot;&lt;&lt;sizeof(arr[0])&lt;&lt;endl; //out : 4 12(单个元素 第一行)\n    //我们可以通过以上数据获得行数与列数\n    sizeof(arr)/sizeof(arr[0]); //列数\n    sizeof(arr[0])/sizeof(arr[0][0]); //列数\n    \n    //2.查看首地址\n    cout &lt;&lt; (long long)arr &lt;&lt;endl;  //out : 6422000\n    cout &lt;&lt; (long long)arr[0] &lt;&lt;endl; //二维数组地址与arr[0][0]首地址重合\n    cout &lt;&lt; (long long)arr[1] &lt;&lt;endl; //out : 6422012 差12(3*4)\n    cout &lt;&lt; (long long)&amp;arr[0][0] &lt;&lt;endl; //二维数组地址与arr[0][0]首地址重合\n    cout &lt;&lt; (long long)&amp;arr[0][1] &lt;&lt;endl; //out : 6422004 与[0][0]差4\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n5.3.3 二维数组应用案例\n考试成绩统计\n\n有三名同学(A,B,C)，在一次考试中成绩分别如下，请输出三名同学的总成绩\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n语文数学英语A100100100B9050100C607080\nint main()\n{\n    \n    int arr[3][3] =\n    {\n        {100,100,100},\n        {90,50,100},\n        {60,70,80}\n    };\n    \n    for (int i = 0; i &lt; 3; i++)\n    {\n        int temp = 0;\n        for (int j = 0; j &lt; 3; j++)\n        {\n            temp += arr[i][j];\n        }\n        cout &lt;&lt; temp &lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n5.3.4 二维数组排序\n\n核心思路：冒泡排序\n\nint main()\n{\n    int l,m;\n    cin &gt;&gt; l &gt;&gt; m;\n    int arr[m][2];\n    for (size_t i = 0; i &lt; m; i++)\n    {\n        for (size_t j= 0; j &lt; 2; j++)\n        {\n          cin &gt;&gt; arr[i][j];\n        } \n    }\n \n    for (size_t i2 = 0; i2 &lt; m-1; i2++)\n    {\n        for (size_t j = 0; j &lt; m-i2-1; j++)\n        {\n            if (arr[j][0] &gt; arr[j+1][0])\n            {\n                int temp1 = arr[j][0];\n                int temp2 = arr[j][1];\n                arr[j][0] = arr[j+1][0];\n                arr[j][1] = arr[j+1][1];\n                arr[j+1][0] = temp1;\n                arr[j+1][1] = temp2;\n            }\n        }\n    }\n \n    for (size_t i = 0; i &lt; m; i++)\n    {\n        for (size_t ij = 0; ij &lt; 2; ij++)\n        {\n            cout &lt;&lt; arr[i][ij]&lt;&lt;&quot; &quot;;\n        }\n        cout &lt;&lt;endl;\n    }\n       \n    \n    return 0;\n}\n"},"C++/基础语法/程序结构流程":{"slug":"C++/基础语法/程序结构流程","filePath":"C++/基础语法/程序结构流程.md","title":"程序结构流程","links":[],"tags":[],"content":"4 程序流程结构\nC/C++支持的三种程序运行结构：顺序结构，选择结构，循环结构\n\n顺序结构:类似于Python的运行结构，程序按顺序执行，不发生跳转\n选择结构:依据条件是否满足，有选择的执行相应功能\n循环结构:依据条件是否满足，循环多次执行某段代码\n\n4.1 选择结构\n4.1.1 if语句\n**作用：**执行满足条件的语句\n其主要有三种形式：\n\n单行格式if语句\n多行格式if语句\n多条件的if语句\n\n\n单行格式if语句:if(条件){ 条件满足执行的语句 }\n\n\n示例:\nint main()\n{\n    //单行if结构\n    //让用户输入一个分数，如果大于600，则输出&quot;恭喜&quot;\n    //1. 用户输入分数\n    int score = 0;\n    cout &lt;&lt; &quot;请输入一个分数&quot;&lt;&lt;endl;\n    cin &gt;&gt; score ;\n    //2. 打印用户分数\n    cout &lt;&lt; &quot;您的分数为:&quot;&lt;&lt;score&lt;&lt;endl;\n    //3.判断\n    if(score &gt; 600) //if条件语法后没有分号！！！\n    {\n        cout&lt;&lt;&quot;恭喜&quot;&lt;&lt;endl;\n    }\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n\n                  \n                  Important\n                  \n                \n\n\nif条件后面不要加分号\n\n\n\n\n多行格式if语句：if(条件){ 条件为真执行的语句 }else{ 条件不满足执行的语句 }\n\n\n示例:\nint main()\n{\n    //多行格式if\n    //提示用户输入分数，如果分数大于600，则输出&quot;恭喜&quot;，若没有大于600，则输出&quot;别放弃&quot;\n    int score = 0;\n    cout &lt;&lt;&quot;请输入一个分数&quot;&lt;&lt;endl;\n    cin &gt;&gt; score;\n    cout &lt;&lt; &quot;您的分数为&quot;&lt;&lt; score &lt;&lt;endl;\n    //执行判断\n    if(score &gt; 600) //大于600的情况\n    {\n        cout &lt;&lt; &quot;恭喜&quot;&lt;&lt;endl;\n    }\n    else //小于600的情况\n    {\n        cout &lt;&lt; &quot;别放弃&quot;&lt;&lt;endl;\n    }\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n多条件的if语句:if(条件1){满足条件1执行的语句}else if(条件2){满足条件2执行的语句}... else{都不满足执行的语句}\n\n\nint main()\n{\n    //多条件的if语句\n    //1.输入分数\n    int score = 0;\n    cout &lt;&lt; &quot;请输入一个分数&quot;&lt;&lt;endl;\n    cin &gt;&gt; score;\n    cout &lt;&lt; &quot;您的分数是&quot; &lt;&lt; score &lt;&lt; endl;\n    //2.条件判断(大于600)\n    if (score &gt;= 600)\n    {\n        cout &lt;&lt; &quot;恭喜&quot;&lt;&lt;endl;\n    }\n    else if (score &gt;= 500)//这里不能写(500 &lt; score &lt; 600)\n    {\n        cout &lt;&lt; &quot;别放弃&quot;&lt;&lt;endl;\n    }\n    else if (score &gt;= 400)\n    {\n        cout &lt;&lt; &quot;还可以&quot;&lt;&lt;endl;\n    }\n    else\n    {\n        cout &lt;&lt; &quot;别摆烂辣！&quot;&lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n嵌套if语句：在if语句中再嵌套一个if语句\n案例要求:\n\n在上个代码的基础上，根据分数再细化\n大于700为特等，大于650为一等，大于600为优秀\n\nint main()\n{\n    //多条件的if语句\n    //1.输入分数\n    int score = 0;\n    cout &lt;&lt; &quot;请输入一个分数&quot;&lt;&lt;endl;\n    cin &gt;&gt; score;\n    cout &lt;&lt; &quot;您的分数是&quot; &lt;&lt; score &lt;&lt; endl;\n    if (score &gt;= 600)\n    {\n        cout &lt;&lt; &quot;恭喜&quot;&lt;&lt;endl;\n        if (score &gt;= 700) //嵌套的if语句\n        {\n            cout &lt;&lt; &quot;特等&quot;&lt;&lt;endl;\n        }\n        else if (score &gt;= 650)\n        {\n            cout &lt;&lt; &quot;一等&quot;&lt;&lt;endl;\n        }\n        else\n        {\n            cout &lt;&lt; &quot;优秀&quot;&lt;&lt;endl;\n        }\n    }\n    else if (score &gt;= 500)//这里不能写(500 &lt; score &lt; 600)\n    {\n        cout &lt;&lt; &quot;别放弃&quot;&lt;&lt;endl;\n    }\n    else if (score &gt;= 400)\n    {\n        cout &lt;&lt; &quot;还可以&quot;&lt;&lt;endl;\n    }\n    else\n    {\n        cout &lt;&lt; &quot;别摆烂辣！&quot;&lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n4.1.2 三目运算符\n**作用:**通过三目运算符实现简单的判断\n语法：表达式1 ? 表达式2 : 表达式3\n解释：\n如果表达式1的值为真，执行表达式2，并返回表达式2的结果；\n如果表达式1的值为假，执行表达式3，并返回表达式3的结果；\n示例:\nint main()\n{\n    //三目运算符\n    int a =30;\n    int b =20;\n    int c =0;\n    c=(a &gt; b ? a : b);\n    cout &lt;&lt; c &lt;&lt;endl;\n \n    //在C++中，三目运算符返回的是变量，可以继续赋值\n    (a &gt; b ? a:b)=100; //a和b做大小比较，较大的变量被赋值为100\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n4.1.3 switch语句\n执行多条件分支语句\n语法：\nswitch(表达式)\n    \n{\n    case 结果1 : 执行语句;break;\n        \n    case 结果2 : 执行语句;break;\n        \n    ...\n        \n\tdefault : 执行语句;break;\n}    \n示例:\nint main()\n{\n    //给电影评分\n    //9-10 经典\n    //7-8 非常好\n    //5-6 不错\n    // &lt;5 不好\n \n    cout &lt;&lt; &quot;请给电影打分&quot;&lt;&lt;endl;\n    int score = 0;\n    cin &gt;&gt; score ;\n    cout &lt;&lt; &quot;您的打分为&quot;&lt;&lt;score&lt;&lt;endl;\n    switch (score)\n    {\n    case 10 :\n        cout &lt;&lt; &quot;经典&quot;&lt;&lt;endl;\n        break; //退出当前分支\n    case 9 :\n        cout &lt;&lt; &quot;经典&quot;&lt;&lt;endl;\n        break;\n    case 8 :\n        cout &lt;&lt; &quot;非常好&quot;&lt;&lt;endl;\n        break;\n    case 7 :\n        cout &lt;&lt; &quot;非常好&quot;&lt;&lt;endl;\n        break;\n    case 6 :\n        cout &lt;&lt; &quot;一般&quot;&lt;&lt;endl;\n        break;\n    case 5 :\n        cout &lt;&lt; &quot;一般&quot;&lt;&lt;endl;\n        break;\n    default:\n        cout &lt;&lt; &quot;不好&quot;&lt;&lt;endl;\n        break;\n    }\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n\n记得要写break;\n\n\n缺点:switch判断的时候只能是整型或字符型，不可以是一个区间\n\n\n优点:结构清晰，执行效率高(速度快)\n\n4.2 循环结构\n4.2.1 while循环语句\n**作用:**满足循环条件，执行循环语句\n语法:while(循环条件){循环语句}\n\n解释:只要循环条件为真，就执行循环语句\n示例:\nint main()\n{\n    //在屏幕中打印0-9这10个数字\n    \n    int num = 0;\n    while (num &lt; 10)\n    {\n        cout &lt;&lt; num &lt;&lt;endl;\n        num++;\n    }\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n\n如果while 后条件为(1)，则为无限循环，要避免死循环的出现\n\n练习:猜数游戏\nint main()\n{\n    //添加随机数种子\n    srand((unsigned int)time(NULL));    \n    int num2 = rand()%100 + 1 ; \n    //cout &lt;&lt; num22 &lt;&lt;endl;\n    int val = 0;\n    cout &lt;&lt; &quot;请输入一个数开始猜数游戏&quot;&lt;&lt;endl;\n    while (val != num2)\n    {\n        cin &gt;&gt; val ;\n        if (val &gt; num2 )\n        {\n            cout &lt;&lt; &quot;猜大辣，再来一次吧&quot;&lt;&lt;endl;\n        }\n        else if (val &lt; num2)\n        {\n            cout &lt;&lt; &quot;猜小辣，再来一次吧&quot;&lt;&lt;endl;\n        }\n        \n    }\n    cout &lt;&lt; &quot;厉害，对辣&quot;&lt;&lt;endl;\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n4.2.2 do…while循环\n**作用：**满足循环条件，执行循环语句\n语法：do{循环语句}while(循环条件);\n\n\n                  \n                  Note\n                  \n                \n\n\n与while不同的是，do…while会先执行一次循环语句，再判断循环条件\n\n\n\n\n示例：\nint main()\n{\n    //do while 循环\n    int num =0;\n    do\n    {\n        cout &lt;&lt; num &lt;&lt;endl;\n        num++;\n    } while (num &lt; 10);\n    system(&quot;pause&quot;);\n    return(0);\n \n}\n**练习案例：**水仙花数\n\n水仙花数是一个三位数，它的每个位上的三次幂之和等于它本身\n例：1^3^+5^3^+3^3^=153\n\n//注意：要有#include&lt;cmath&gt;\nint main()\n{\n    //定义初始值，其中fnum3,2,1分别代表百十个位，这个三位数要和初始值fnum相等\n    int fnum1 = 0;\n    int fnum2 = 0;\n    int fnum3 = 1;\n    float fnumt = 0;\n    int fnum = 100;\n    do\n    {\n        \n        fnum++;\n        fnum1++;\n        //三位数输出，个十百位分别输出\n        if (fnum1 - 1  == 9)\n        {\n        fnum1 = 0;\n        fnum2++;\n        }\n        if (fnum2 - 1 == 9)\n        {\n        fnum2 = 0;\n        fnum3++;\n        }\n        if (fnum3 - 1 == 9)\n        {\n            fnum3 = 0;\n        }\n        \n        fnumt = pow(fnum1,3) + pow(fnum2,3) + pow(fnum3,3);\n        if ( fnumt == fnum)\n        {\n            cout &lt;&lt;&quot;水仙花&quot;&lt;&lt; fnum &lt;&lt; endl;\n        }\n        // cout &lt;&lt; fnum &lt;&lt; endl;\n        // cout &lt;&lt; fnumt &lt;&lt; endl;\n        // cout &lt;&lt;&quot;个位&quot;&lt;&lt; fnum1 &lt;&lt; endl;\n        // cout &lt;&lt;&quot;十位&quot; &lt;&lt;fnum2 &lt;&lt; endl;\n        // cout &lt;&lt;&quot;百位&quot; &lt;&lt;fnum3 &lt;&lt; endl;\n     \n    } while (fnum &lt; 1000);\n    system(&quot;pause&quot;);\n    return(0);\n \n}\n\n\n                  \n                  Important\n                  \n                \n\n\n如何获取一个三位数的个十百位？\n\n例:153\n个位:153%10 = 3    对数字取模于10可以获得个位\n十位:153/10 = 15 \\to15 % 10 = 5  C++中整除只留整数部分即 (153/10)%10\n百位:153/100 = 1\n\n\n\n\n示例：\nint main()\n{\n    int num = 100;\n    do{\n        num++;\n        if(num == pow(num%10,3)+pow((num/10)%10,3)+pow(num/100,3))\n        {\n            cout &lt;&lt; num &lt;&lt;endl;\n        }\n    }while(num &lt; 999);\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n4.2.3 for 循环\n**作用：**满足循环条件，执行循环语句\n语法：for(起始表达式;条件表达式;末尾循环体){循环语句;}\n\n起始表达式不参加循环\n条件表达式确定循环条件\n一次循环执行后执行末尾循环体\n\n示例：\nint main()\n{\n    for (int i = 0; i &lt; 10; i++)\n    {\n        cout &lt;&lt; i &lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n\n                  \n                  Note\n                  \n                \n\n\n对for(a;b;c){d}来看，执行顺序如下\n\n先执行一次 a\n判断 b\n若b为真，重复2，3，4，5；否则退出循环\n执行 d\n执行 c\n\n\n\n\n\nfor 循环结构简单，比较常用\n\n**练习案例：**敲桌子\n\n输出1~100，若该数个位含有7，或10位含有7，或该数字是7的倍数，则我们输出敲桌子，其余数字直接打印\n\nint main()\n{\n    for (int i = 0; i &lt; 100; i++)\n    {\n        if (i%10 == 7)\n        {\n            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt;endl;\n        }\n        else if ((i/10)%10 == 7)\n        {\n            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt;endl;\n        }\n        else if ( i%7 == 0 )\n        {\n            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt;endl;\n        }\n        else\n        {\n            cout &lt;&lt; i &lt;&lt;endl;\n        }        \n    }\n}\n\n\n                  \n                  Note\n                  \n                \n\n\nif比较语句中我们可以用逻辑运算符来提高if语句的精确性\n比如上面的示例中多个if便可以写成if(i % 10 == 7 || i%7==0 || (i/10)%10==7 )\n\n\n\n4.2.4 嵌套循环\n\n在循环体中再次嵌套循环，用于解决实际问题\n\n示例\nint main()\n{\n    for (int i = 0; i &lt; 10 ; i++) //外层循环\n    {\n        for (int j = 0; j &lt; 10; j++) //内层循环\n        {\n            cout &lt;&lt; &quot;*&quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n // 外层走一次，内层走一周   \n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n**案例：**乘法口诀表\n\n打印九九乘法表\n\nint main()\n{\n    //九九乘法表，实际上就是 行 X 列 = 数字，即将行和列表示出来即可\n    for (int i = 0; i &lt; 10; i++) // i 代表 行\n    {\n        for (int j = 1; j &lt; i+1 ; j++) // j 代表 列 \n        {\n            cout &lt;&lt; j &lt;&lt;&quot;X&quot;&lt;&lt; i &lt;&lt;&quot;=&quot;&lt;&lt;i*j&lt;&lt;&quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }   \n    system(&quot;pause&quot;);\n    return(0);\n}\n输出呈现：\n\n\n4.3 跳转语句\n4.3.1 break 语句\n**作用：**跳出选择结构或循环结构\nbreak使用的时机：\n\n出现在switch语句中，终止case并跳出switch\n出现在循环语句中，作用是跳出当前循环语句\n出现在嵌套循环中，作用是跳出最近的内层循环语句\n\n示例1：\nint main()\n{\n    for (int i = 0; i &lt; 10 ; i++)\n    {\n        cout &lt;&lt; i &lt;&lt; endl;\n        if (i == 5)\n        {\n            break;\n        }\n        \n    } \n    system(&quot;pause&quot;);\n    return(0);  \n}\n示例2\nint main()\n{\n    for (int i = 0; i &lt; 10 ; i++)\n    {\n        for (int j = 0; j &lt; 10; j++)\n        {\n            if (j == 5)\n            {\n                break;\n            }\n            cout &lt;&lt; &quot;*&quot;;\n        }\n        cout&lt;&lt; endl; \n    } \n    system(&quot;pause&quot;);\n    return(0);  \n}\n4.3.2 countinue 语句\n**作用:**在循环语句中，跳过本次循环中余下的未执行的代码，继续执行下一次循环\n示例：\nint main()\n{\n    for (int i = 0; i &lt;= 100; i++)\n    {\n        if (i%2 == 0)\n        {\n            continue;\n        }\n        \n        cout &lt;&lt; i &lt;&lt; endl;\n    }\n    system(&quot;pause&quot;);\n    return(0);  \n}\n\n实现了0~100奇数的输出\n\n4.3.3 goto 语句\n**作用：**可以无条件跳转语句\n语法：goto 标记\n\n标记一般用纯大写英文表示\ngoto 语法尽量不要经常使用，以免造成代码逻辑混乱\n标记定义 T：\n\n"},"C++/基础语法/类":{"slug":"C++/基础语法/类","filePath":"C++/基础语法/类.md","title":"类","links":[],"tags":[],"content":"9 类\n\n在面向对象编程（OOP）中，对象就是类的实例，也就是变量\n\nclass Class_Name\n{\npublic:\n    string str;\n    int adds;\n    void add_age(int add_s)\n    {\n        //..../\n    } // 内联函数\n    void getval();\nprivate:\n    int age;\n};\n\n对内联函数，也可以使用 inline 来在类的外部写\ninline \n"},"C++/基础语法/结构体与链表":{"slug":"C++/基础语法/结构体与链表","filePath":"C++/基础语法/结构体与链表.md","title":"结构体与链表","links":[],"tags":[],"content":"8 结构体\n自定义的数据类型，允许用户储存不同的数据类型\n8.1 结构体的定义\n语法：struct 结构体名{结构体成员列表};\n\n有三种创建变量的方式:\n\nstruct 结构体名 变量名\nstruct 结构体名 变量名 = {成员1 ， 成员2 ， ……}\n定义结构体时顺便创建变量\n例：\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &#039;\n\n\n’\nusing namespace std;\n// 创建数据类型\nstruct QAQ {\nstring s1;\nint n1;\nint n2;\n// 下面是定义时候定义\n} k3;\nint main()\n{\n// 定义结构体数据 1\nQAQ k1;\nk1.s1 = “aaa”;\n// 定义结构体数据 2\nQAQ k2 = { “114”, 5, 1 };\nk3.s1 = “1919”;\nk3.n1 = 810;\nreturn 0;\n}\n\n### 8.2 结构体数组\n**定义结构体放入数组方便维护**\n- **语法：**`struct 结构体名 数组名[元素个数] = {}`\n```cpp\n#include &lt;bits/stdc++.h&gt;\n#define endl &#039;\n&#039;\nusing namespace std;\n// 创建数据类型\nstruct QAQ {\n  string s1;\n  int n1;\n  int n2;\n} s[10];\nint main()\n{\n  s[1] = { &quot;QAQ&quot;, 1, 2 };\n  cout &lt;&lt; s[1].s1;\n  // 或者\n  QAQ kk[5]; //第二种方法构建\n  cin &gt;&gt; kk[3].s1;\n  cout &lt;&lt; kk[3].s1;\n  return 0;\n}\n\n8.3 数组结构体\n\n结构体可以用数组表示，数组当然也可以放在结构体中\nint a[n]类型\nstruct test1\n{\n    string s;\n    int a[9];\n};\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    test1 st[t];\n    for (size_t i = 0; i &lt; t; i++) {\n        cin &gt;&gt; st[i].s;\n        for (size_t j = 0; j &lt; 9; j++) {\n            cin &gt;&gt; st[i].a[j];\n        }\n    }\n    return 0;\n}\n注意上述 int a[n]中的 n 为一个确定常数\nvector&lt;int&gt;类型\nstruct test1\n{\n    string s;\n    vector&lt;int&gt; a;\n};\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    test1 st[t];\n    for (size_t i = 0; i &lt; t; i++) {\n        cin &gt;&gt; st[i].s;\n        for (size_t j = 0; j &lt; 3; j++) {\n            int p;\n            cin &gt;&gt; p;\n            st[i].a.push_back(p);\n        }\n    }\n    for (auto &amp;&amp;i : st) {\n        cout &lt;&lt; i.s &lt;&lt; &quot; &quot;;\n        for (auto &amp;&amp;j : i.a) {\n            cout &lt;&lt; j &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n在上述构造方法中都没有对结构体里的数组进行初始化，下面是初始化的方法\n对 int a[n]而言：\n\n直接 结构体里int a[n] = {0};即可\n对 vectior&lt;int&gt;而言：\n采取显式调用即可\n\nvector&lt;int&gt; a = vector&lt;int&gt;(n,0);\n其中n为常数\n\n8.4结构体的构造函数\n结构体构造函数的形式与用法\n\n在 C++ 中，结构体（struct）的构造函数和类（class）的构造函数没有本质区别。构造函数是特殊的成员函数，用于在创建对象时初始化成员变量。构造函数的名称必须与结构体的名称相同。\n\n构造函数的形式\n1. 默认构造函数\n不带参数的构造函数，用于初始化成员变量为默认值。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n std::string name;\n int age;\n \n // 默认构造函数\n Person() : name(&quot;unknown&quot;), age(0) {}  // 使用初始化列表\n};\n \nint main() {\n Person p;  // 自动调用默认构造函数\n std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Age: &quot; &lt;&lt; p.age &lt;&lt; &quot;\n&quot;;\n return 0;\n}\n2. 带参数的构造函数\n构造函数可以接受参数，用于动态初始化成员变量。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n std::string name;\n int age;\n \n // 带参数的构造函数\n Person(const std::string&amp; n, int a) : name(n), age(a) {}\n};\n \nint main() {\n Person p(&quot;Alice&quot;, 25);  // 调用带参数的构造函数\n std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Age: &quot; &lt;&lt; p.age &lt;&lt; &quot;\n&quot;;\n return 0;\n}\n3. 构造函数重载\n通过不同的参数列表定义多个构造函数，满足不同的初始化需求。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n std::string name;\n int age;\n \n // 默认构造函数\n Person() : name(&quot;unknown&quot;), age(0) {}\n \n // 带参数的构造函数\n Person(const std::string&amp; n, int a) : name(n), age(a) {}\n \n // 只初始化名字\n Person(const std::string&amp; n) : name(n), age(18) {}  // 默认年龄为18\n};\n \nint main() {\n Person p1;                      // 默认构造\n Person p2(&quot;Bob&quot;, 30);           // 带参数\n Person p3(&quot;Charlie&quot;);           // 只提供名字\n \n std::cout &lt;&lt; p1.name &lt;&lt; &quot;, &quot; &lt;&lt; p1.age &lt;&lt; &quot;\n&quot;;\n std::cout &lt;&lt; p2.name &lt;&lt; &quot;, &quot; &lt;&lt; p2.age &lt;&lt; &quot;\n&quot;;\n std::cout &lt;&lt; p3.name &lt;&lt; &quot;, &quot; &lt;&lt; p3.age &lt;&lt; &quot;\n&quot;;\n \n return 0;\n}\n输出\nunknown, 0\nBob, 30\nCharlie, 18\n\n4. 使用初始化列表\n初始化列表用于直接初始化成员变量，避免在构造函数体内赋值。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n std::string name;\n int age;\n \n // 使用初始化列表\n Person(const std::string&amp; n, int a) : name(n), age(a) {}\n};\n \nint main() {\n Person p(&quot;Diana&quot;, 22);  // 初始化时直接调用\n std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Age: &quot; &lt;&lt; p.age &lt;&lt; &quot;\n&quot;;\n return 0;\n}\n初始化列表的优点：\n\n提高效率：避免默认构造后再赋值。\n支持 const 和引用类型的初始化。\n\n特殊形式\n1. 委托构造函数（C++11 起支持）\n一个构造函数可以委托给另一个构造函数以复用初始化逻辑。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n    std::string name;\n    int age;\n \n    // 默认构造函数\n    Person() : Person(&quot;unknown&quot;, 0) {}  // 委托到另一个构造函数\n \n    // 带参数的构造函数\n    Person(const std::string&amp; n, int a) : name(n), age(a) {}\n};\n \nint main() {\n    Person p1;              // 默认构造\n    Person p2(&quot;Eve&quot;, 28);   // 带参数构造\n \n    std::cout &lt;&lt; p1.name &lt;&lt; &quot;, &quot; &lt;&lt; p1.age &lt;&lt; &quot;\n&quot;;\n    std::cout &lt;&lt; p2.name &lt;&lt; &quot;, &quot; &lt;&lt; p2.age &lt;&lt; &quot;\n&quot;;\n \n    return 0;\n}\n2. 删除的构造函数（C++11 起支持）\n可以显式删除某些构造函数，防止被意外调用。\n#include &lt;iostream&gt;\n \nstruct Person {\n    int age;\n \n    // 禁止隐式转换或默认构造\n    Person() = delete;  // 删除默认构造函数\n    Person(int a) : age(a) {}\n};\n \nint main() {\n    // Person p1;  // 编译错误：默认构造函数被删除\n    Person p2(30);  // 必须传入参数\n    std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; p2.age &lt;&lt; &quot;\n&quot;;\n    return 0;\n}\n构造函数的应用场景\n\n初始化成员变量\n\n为结构体或类的成员变量赋初始值，避免对象处于未定义状态。\n\n\n动态控制初始化\n\n可以根据参数灵活地初始化不同状态的对象。\n\n\n封装复杂逻辑\n\n在构造函数中封装一些初始化逻辑，简化外部代码。\n\n\n提高代码安全性\n\n使用委托构造或删除某些构造函数可以避免意外使用。\n\n\n\n总结\n\n构造函数是结构体中用来初始化成员变量的核心工具。\n通过默认构造、参数化构造、初始化列表等形式，可以满足多样化的初始化需求。\n推荐使用 初始化列表，特别是在初始化复杂类型（如 std::vector、引用、const 变量）时，效率更高。\n\n链表\n\n什么是链表：\n\n链表是一种用于存储数据的数据结构，通过如链条一般的指针来连接元素。它的特点是插入与删除数据十分方便，但寻找与读取数据的表现欠佳。\n\n\n链表的优势：对数据的处理：插入，删除  ——&gt; O(1) 但也因为这样，寻找、读取数据的效率不如数组高，在随机访问数据中的操作次数是 O(n)\n\n\n与数组相反的是，数组在随机访问数据下时间复杂度为O(1)，但插入删除数据为O(n)\n\n单向链表与双向链表的创建\n\n单向链表：单向链表包括两大数据类型，即数据域和指针域\n\nstruct Node\n{\n    int value;\n    Node *next; // 定义了一个指向该结构体(链表单位)的一个指针\n    Node(int val) : value(val), next(nullptr){}\n};\n这个结构体函数做了什么？\n\n\n初始化了一个新创建的结点，这个结点传入的参数默认赋值给了value，同时将结构体指针域默认赋值为了nullptr,表示其暂时不指向任何其他结点\n\n\n\n双向链表\n\n\n双向链表：也同样是数据域+指针域，但不同的是，指针域有左右(或上下)之分，用来链接上一个结点，当前结点，下一个结点\n\n\nstruct Node {\n    int value;\n    Node *left;\n    Node *right;\n    Node(int val) : value(val) , left(nullptr) , right(nullptr){}\n};\n\n向链表里写入与删去数据\n流程大致如下\n\n初始化待插入的数据 node；\n将 node 的 next 指针指向 p 的下一个结点；\n将 p 的 next 指针指向 node。\n但在这之前，我们要创建一个链表头\nNode *head = nullptr\n我们的操作都会在这个头链表上开始\n\n在头部插入数据\n时间复杂度O(1)\nvoid insert_head_node(Node *newnode, Node *&amp;head)\n{\n    newnode-&gt;next = head;\n    head = newnode;\n}\n在某一个pos值上插入元素\nvoid insert_pos_node(Node *newnode, int pos, Node *&amp;head)\n{\n    if (pos == 0) {\n        newnode-&gt;next = head;\n        head = newnode;\n        return;\n    }\n    Node *current = head;\n    int currentposition = 0;\n    while (current != nullptr &amp;&amp; currentposition &lt; pos - 1) {\n        current = current-&gt;next;\n        currentposition++;\n    }\n    newnode-&gt;next = current-&gt;next;\n    current-&gt;next = newnode;\n}\n在尾部插入元素\n在单向链表尾部插入元素，时间复杂的O(n)\nvoid insert_end_node(Node *Newnode, Node *&amp;p)\n{\n    // Node *Newnode = new Node(i);\n    if (p == nullptr) {\n        p = Newnode;\n        return;\n    }\n    Node *current = p;\n    while (current-&gt;next != nullptr) {\n        current = current-&gt;next;\n    }\n    current-&gt;next = Newnode;\n}\n删除某一结点\n\n删除某一特定值的结点\n\nvoid delnode(int i, Node *&amp;p)\n{\n    //链表为空\n    if (p == nullptr) return;\n    //头结点为目标值\n    while (p != nullptr &amp;&amp; p-&gt;val == i) {\n        Node *temp = p;\n        p = p-&gt;next;\n        delete temp;\n        t--;\n    }\n    //中间或尾部结点为目标\n    Node *current = p;\n    while (current != nullptr &amp;&amp; current-&gt;next != nullptr) {\n        if (current-&gt;next-&gt;val == i) {\n            Node *temp = current-&gt;next;\n            current-&gt;next = current-&gt;next-&gt;next;\n            delete temp;\n            t--;\n        }\n        else {\n            current = current-&gt;next;\n        }\n    }\n}\n\n删除某一位置的结点\n\nvoid posdel(int pos, Node *&amp;head)\n{\n    if (head == nullptr || pos &lt; 0) return;\n    if (pos == 0) {\n        Node *temp = head;\n        head = head-&gt;next;\n        delete temp;\n        return;\n    }\n    Node *current = head;\n    for (int i = 0; i &lt; pos &amp;&amp; current != nullptr; i++) {\n        current = current-&gt;next;\n    }\n    if (current == nullptr || current-&gt;next == nullptr) return;\n    Node *temp = current-&gt;next;\n    current-&gt;next = current-&gt;next-&gt;next;\n    delete temp;\n}"},"C++/基础语法/运算符":{"slug":"C++/基础语法/运算符","filePath":"C++/基础语法/运算符.md","title":"运算符","links":[],"tags":[],"content":"3 运算符\n**作用：**用于执行代码的计算\n主要有一下几种运算符：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符类型作用算术运算符用于处理四则运算赋值运算符用于将表达式的值赋给变量比较运算符用于表达式的比较，返回一个真值或假值逻辑运算符用于根据表达式的值返回真值或假值\n\n3.1 算术运算符\n**作用：**用于处理四则运算\n包括一下符号：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符术语示例结果+正数+3+3-负数-4-4+加号4+59-减号6-33*乘号6*742/[^1]除号94/713%取模(取余)10%31++前置递增a=2 b=++aa=3 b=3++后置递增a=2 b=a++a=3 b=2—前置递减a=2 b=—aa=1 b=1—后置递减a=2 b=a—a=1 b=2\n示例1四则运算的示例\nint main()\n{\n    int a1 = 10;\n    int b1 = 7;\n    cout&lt;&lt;a1 + b1 &lt;&lt;endl;\n    cout&lt;&lt;a1 - b1 &lt;&lt;endl;\n    cout&lt;&lt;a1 * b1 &lt;&lt;endl;\n    cout&lt;&lt;a1 / b1 &lt;&lt;endl; //这里为整除运算，结果也会为整数\n \n    float a2 ;\n    float b2 ;\n    cout&lt;&lt;&quot;请输入两个浮点数&quot;&lt;&lt;endl;\n    cin &gt;&gt; a2;\n    cin &gt;&gt; b2;\n    cout&lt;&lt; &quot;a2除以b2的值为&quot;&lt;&lt;a2 / b2&lt;&lt;endl; //这里是非整除\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n取模运算本质就是取余数\n两个小数之间不能做取模运算\n\n前置递增与后置递增\n\n前置，后置递增都是使变量进行加一的操作\n前置递增:先对变量进行递增，再进行表达式运算\n后置递增:先进行表达式的运算，再对变量递增\n\nint main()\n{\n    //前置运算\n    int a = 10;\n    int b = 3;\n    int r1 = ++a * b; \n    cout&lt;&lt;&quot;r1=&quot;&lt;&lt; r1 &lt;&lt;endl; \n \n    //后置运算\n    int a2 = 10;\n    int b2 = 3;\n    int r2 = a2++ * b2; \n    cout&lt;&lt;&quot;r2=&quot;&lt;&lt; r2 &lt;&lt;endl;\n    cout&lt;&lt;&quot;a2=&quot;&lt;&lt;a2&lt;&lt;endl; \n \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n\n\n我们不难发现，在上述代码运算过程中我们的”a”变量先被加1再参与到了运算之中，而我们的”a2”变量则是再运算结束后才被加1\n\n\n\n3.2赋值运算符\n**作用：**将表达式的值赋给变量\n主要包括以下几个符号：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符术语示例结果=赋值a=10a=10+=加等于a=10 a+=2a=12-=减等于a=10 a-=2a=8*=乘等于a=10 a*=2a=20/=除等于a=10 a/=2a=5%=取模等于a=10 a%=2a=0\n3.3 比较运算符\n**作用：**用于比较表达式的真假，并返回一个真值或假值\n主要有以下的符号：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符术语示例结果==相等于4 == 30!=不等于4 != 31&lt;小于4 &lt; 30&gt;大于4 &gt; 31⇐小于等于4 ⇐ 30&gt;=大于等于4 &gt;= 31\ntips：再代码中由于有优先级的影响，我们可以这么提升运算优先级 cout &lt;&lt; (a == b)&lt;&lt; denl;\n3.4 逻辑运算符\n**作用：**用于根据表达式的值返回真值或假值\n主要有以下符号:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符术语示例结果！非!a如果a为假，则!a为真；如果a为真，则!a为假&amp;&amp;与a&amp;&amp;b如果a和b都为真，则结果为真，否则为假||或a||b如果a和b中有一个为真，则结果为真，二者都为假的时候，结果为假\n3.4.1 逻辑非\nint main()\n{\n    //逻辑非\n    int a= 10 ;\n    cout &lt;&lt; !a &lt;&lt; endl;\n    //运算结果为 0 (解释:在C++中，只要结果不为0，都视为真，故输出结果为假)\n    cout &lt;&lt; !!a &lt;&lt; endl;\n    //结果为1，取了两次反（从真变假再变真）\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n总结:真变假，假变真\n\n3.4.2 逻辑与\nint main()\n{\n    // 逻辑与\n    int a = 10;\n    int b =10;\n    cout &lt;&lt; (a&amp;&amp;b) &lt;&lt; endl; //此处也要优先运算\n    //运算结果为 1 (真)\n    a = 10;\n    b = 0;\n    cout &lt;&lt; (a&amp;&amp;b) &lt;&lt; endl;\n    //运算结果为 0 (假)\n    a = 0;\n    b = 0;\n    cout &lt;&lt; (a&amp;&amp;b)&lt;&lt;endl;\n    //运算结果为 0 (假)\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n总结: 同真为真，其余为假\n\n3.4.3 逻辑或\nint main()\n{\n    //逻辑或\n    int a = 10;\n    int b = 10;\n    cout &lt;&lt; (a||b)&lt;&lt;endl;\n    //结果为1\n \n    a = 0;\n    b = 10;\n    cout &lt;&lt; (a||b)&lt;&lt;endl;\n    //结果仍为1\n    a=0;\n    b=0;\n    cout &lt;&lt; (a||b)&lt;&lt;endl;\n    //结果为0\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n总结: 同假为假，其余为真\n\n"},"Latex/Latex初学":{"slug":"Latex/Latex初学","filePath":"Latex/Latex初学.md","title":"Latex初学","links":[],"tags":[],"content":""},"Linux/常见命令/chomd":{"slug":"Linux/常见命令/chomd","filePath":"Linux/常见命令/chomd.md","title":"chomd","links":["Linux/常见命令/ls"],"tags":[],"content":"基本作用\nchomd主要作用是修改文件权限或者目录权限\n权限详解\n在Linux中，权限被分为三组，每组包含三种权限:\n\n所有者 (Owner / User - u): 文件的创建者或被指定为所有者的用户。\n组 (Group - g): 与文件关联的用户组中的所有用户。\n其他用户 (Others / World - o): 除了所有者和组成员之外的所有其他用户。\n每组权限组都包含以下三种基本权限：\n\n\n读取 (Read - r):\n\n对于文件: 允许查看文件内容。\n对于目录: 允许列出目录中的文件（但必须同时有执行权限才能进入目录）。\n\n\n写入 (Write - w):\n\n对于文件: 允许修改、保存或删除文件。\n对于目录: 允许在目录中创建、删除或重命名文件（但必须同时有执行权限才能进入目录）。\n\n\n执行 (Execute - x):\n\n对于文件: 允许将文件作为程序或脚本运行。\n对于目录: 允许进入（cd）目录并访问其内容。\n我们可以使用ls -l来查看文件权限\n\n\n\n\n两种用法\n1.符号模式\n符号模式可以使用字符来增量的修改权限\n语法：\nchmod [who][operator][permissions] file/directory\n\nwho (作用对象)：\n\nu (user): 所有者\ng (group): 组\no (others): 其他用户\na (all): 所有用户 (u, g, o 的总和)\n如果省略 who，则默认作用于 a (all)，但受 umask 影响。\n\n\noperator (操作符)：\n\n+: 添加指定的权限。\n-: 移除指定的权限。\n=: 设置指定的权限，并移除未指定的其他权限。\n\n\npermissions (权限)：\n\nr: 读取 (Read)\nw: 写入 (Write)\nx: 执行 (Execute)\n例子：\n\n\n\nchmod u+x script.sh \n#为文件所有者增加执行权限\nchmod a=rwx script2.sh \n#为所以用户添加读写执行的权限\nchmod u+w directory/\n#为目录所有者添加写权限\n\n数字模式\n数字模式使用八进制数字表示每组权限\n每个权限都有自己的对应值\n\nr(读) = 4\nw(写) = 2\nx(执行) = 1\n-(无权限) = 0\n通过将每组权限的数字值相加，可以得到一个三位八进制数字。这三位数字分别代表所有者、组和其他用户的权限。\n\n权限组合的数字值：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n权限组合数字值---0--x1-w-2-wx3r--4r-x5rw-6rwx7\n语法：\nchmod [xxx] file/director\n其中xxx是一个三位8进制数字\n\n第一位数字：所有者的权限 (Owner)\n第二位数字：组的权限 (Group)\n第三位数字：其他用户的权限 (Others)\n例：\n\nchmod 644 file\n\n6 (rw-) 给所有者：读、写\n4 (r—) 给组：读\n4 (r—) 给其他用户：读\n这是普通文件常见的权限设置，所有者可读写，其他人只读。\n\n"},"Linux/常见命令/find":{"slug":"Linux/常见命令/find","filePath":"Linux/常见命令/find.md","title":"find","links":[],"tags":[],"content":"Find命令在linux里用于在指定的目录下搜索文件和目录,可以根据各种条件来查找\n\n基本用法\n以下是一些基本的用法\nfind [路径] [表达式]\n\n[路径]:开始搜索的目录,如果不指定则默认为当前目录\n[表达式]: 告诉find你需要查找什么文件(文件名,类型,大小写) 以及找到之后要执行什么操作\n\n\n常用搜索条件\n按名称搜索\n参数 -name\n用于根据文件名称搜索,支持 shell 通配符\n\n搜索名为 test.txt 的文件:\n\nfind . -name &quot;test.txt&quot;\n\n在当前目录与子目录查找 test.txt\n\n\n搜索所有 .log 结尾的文件\n\nfind /var/log -name &quot;*.log&quot;\n\n在 /var/log 目录下查找所有 .log 文件\n\n\n忽略大小写搜索\n\nfind . -iname &quot;report.pdf&quot;\n\n会匹配 Report.pdf REPORT.pdf …\n\n\n按类型搜索\n参数 -type\n用来指定要搜索的是文件、目录、符号链接等。\n\nf：普通文件\nd：目录\nl：符号链接 (symbolic link)\n搜索名字为 imicola 的目录\n\nfind . -type d -name imicola\n\n按大小搜索\n参数 -size\n可以根据文件大小搜索文件\n单位:\n\nc 字节bytes\nk 千字节 即KB\nM 即MB\nG 即GB\n\n\n找到文件后执行操作 (-exec)\n语法规则 : ... -exec [cmd] {} \\;\n\n[cmd] 是执行的命令\n{} 是占位符,会将find找到的每一个文件路径替换\n\\; 是 -exec 命令的结束符,必须存在\n\nfind /tmp -name &quot;*.tmp&quot; -exec rm {} \\;\n\n找到所有 .tmp后缀文件并删除\n\n"},"Linux/常见命令/grep":{"slug":"Linux/常见命令/grep","filePath":"Linux/常见命令/grep.md","title":"grep","links":[],"tags":[],"content":""},"Linux/常见命令/ls":{"slug":"Linux/常见命令/ls","filePath":"Linux/常见命令/ls.md","title":"ls","links":[],"tags":[],"content":"基本作用\nls命令的作用是列出指定目录包含的文件，如果用户没有指定，则列出当前工作目录下的文件\n-a\n一般情况下，ls不会输出以.开头的文件，如果想要知道这些文件，可以使用 ls -a,会显示所有文件，也可以使用ls -A,这样会在ls -a的基础上不显示.he\n-l\n对输出\ndrwxr-xr-x 2 imicola users 4096 Mar 22 20:16 astrbot\n1. 文件类型和权限 (drwxr-xr-x)\n这是最左边的10个字符，它们描述了文件类型以及用户、组和其他用户的访问权限。\n\n第一个字符 (d): 表示文件类型。\n\nd: 目录 (directory)\n-: 普通文件 (regular file)\nl: 符号链接 (symbolic link)\nb: 块设备文件 (block device file) (例如硬盘)\nc: 字符设备文件 (character device file) (例如终端或串行端口)\np: 命名管道 (named pipe)\ns: 套接字 (socket)\n\n\n接下来的九个字符 (rwxr-xr-x): 这九个字符分为三组，每组三个字符，分别代表 所有者、所属组 和 其他用户 的权限。每个三字符组的顺序都是 读 (r)、写 (w) 和 执行 (x)。如果某个权限没有被授予，对应的位置会显示为连字符 (-)。\n\n第一组 (rwx): 所有者 (owner) 的权限。\n\nr: 读 (read) 权限\nw: 写 (write) 权限\nx: 执行 (execute) 权限\n\n\n第二组 (r-x): 所属组 (group) 的权限。\n第三组 (r-x): 其他用户 (others) 的权限。\n\n\n以 drwxr-xr-x 为例：\n\nd: 这是一个目录。\nrwx: 文件所有者拥有读、写和执行权限。\nr-x: 所属组的成员拥有读和执行权限，但没有写权限。\nr-x: 其他用户拥有读和执行权限，但没有写权限。\n\n\n\n2. 硬链接数 (2)\n这列显示了指向文件或目录的 硬链接数量。\n\n对于文件，它表示有多少个文件名指向同一个物理文件。\n对于目录，它表示该目录本身以及其直接包含的子目录数量（每个子目录都有一个 . 和 .. 链接，加上其本身的名称）。\n\n3. 文件所有者 (imicola)\n这表示文件的 所有者用户名。该用户对文件拥有第一组权限 (例如 rwx)。\n4. 所属组 (users)\n这表示文件所属的 组名。属于该组的用户对文件拥有第二组权限 (例如 r-x)。\n5. 文件大小 (4096)\n这表示文件或目录的 大小，通常以字节为单位。对于目录，这个大小通常不是其内部所有文件大小的总和，而是目录本身存储其内容（如文件名和子目录信息）的大小。\n6. 最后修改时间 (Mar 22 20:16)\n这表示文件或目录的 最后修改时间。它包括月份、日期和时间。\n7. 文件名或目录名 (astrbot)\n这表示文件或目录的 名称。"},"Linux/折腾/neovim":{"slug":"Linux/折腾/neovim","filePath":"Linux/折腾/neovim.md","title":"neovim","links":[],"tags":[],"content":"\nvim是一个传统命令行文字编辑器\nneovim是vim的改进，在vim的核心逻辑上有着更强的社区扩展与插件扩展性的终端IDE\n\n"},"Linux/折腾/从零开始安装linux":{"slug":"Linux/折腾/从零开始安装linux","filePath":"Linux/折腾/从零开始安装linux.md","title":"从零开始安装linux","links":[],"tags":[],"content":"\nlinux是一种独立于win,macOS的操作系统，对嵌入式，代码工作，开发实验有强大的支撑作用\n在开始安装之前可以先选择你的需求：主要分为虚拟机安装与双系统共存\n\n虚拟机安装优点\n\n简单易上手，在windows下就能实现大部分linux的功能\n具有强大的可修改性，遇到不喜欢的删掉重新安装即可\n存在及其强大的回滚与测试环境(毕竟没人会在实体机上 rm -rf / )\n可以更灵活的分配虚拟机资源\n\n缺点\n\n对系统占用大，没办法完全发挥linux体量小，占用小的优点\n虚拟机中的图形性能可能不如直接在物理硬件上运行，特别是对于需要高性能图形处理的应用\n虚拟机可能无法提供与物理机相同的实时响应能力，尤其是在高负载情况下\n虚拟机可能不能为你提供完全兼容的硬件配置\n\n实体机(双系统)安装的优点\n\n完全发挥linux的轻量级，省资源的优点\n对硬件几乎完全适配\n安装双系统对windows启动和linux启动能提供更深刻的认识\n双系统将win和linux从硬件层面隔离\n\n缺点\n\n麻烦\n如果选用Arch系的linux发行版有可能会一次更新直接崩溃\n系统回滚麻烦\n需要你有一个U盘\n\n1.0 选择你的linux版本\n\n\n两大选择：Ubuntu 或 Arch系\n\n\narch系的有\n\n原生arch linux\n基于arch linux 的发行版 manjaro [笔者装的就是这个]\n\n\n\n国产新秀deepin\n\n\n\n\n                  \n                  TIP\n                  \n                \n\n\n新手建议装Ubuntu或deepin,特别是deepin(有开箱即用的优点，甚至原生支持中文输入法[笔者觉得manjaro的中文输入法是真的难用])\nUbuntu和arch系的区别就是软件/系统更新的区别\n\nUbuntu每两年发布一个LTS（长期支持）版本，提供长达5年的安全更新和维护\nArch采用滚动发布模型，意味着用户总是能够使用最新的软件和内核\n\\to [虽然滚动更新模式可以让用户始终保持最新，但有时候更新可能会破坏系统的稳定性]\nUbuntu提供了一个直观的图形用户界面，使得新用户可以轻松上手\nArch Linux允许用户从安装开始就自定义他们的系统，提供了极大的灵活性\n!!!在安装难度上 Ubuntu &lt; arch发行版manjaro &lt;&lt;&lt;&lt; 原生arch linux\n据说arch linux 的网络配置都要手搓命令行和网关配置\n\n\n\n\n2.0 虚拟机安装\n由于笔者没在虚拟机上装过，所以可能有不准确的信息，欢迎和笔者报错\n2.1 下载VMware\n\n\nVMware Workstation Pro\n\n\n\n注意：在这里不要选择安装带有 linux 字样的软件，这里的linux表示在linux上运行的软件，因为我们是在windows上运行的，所以我们要安装 Windows版本的\n\n\n\n安装时可能出现要求许可证的情况，可以选择购买或下载个人版\n\n\n\n以下内容出现在本文纯属计算机二进制的意外组合造成的结果\n\n4A4RR-813DK-M81A9-4U35H-06KND\nNZ4RR-FTK5H-H81C1-Q30QH-1V2LA\nJU090-6039P-08409-8J0QH-2YR7F\n4Y09U-AJK97-089Z0-A3054-83KLA\n4C21U-2KK9Q-M8130-4V2QH-CF810\nMC60H-DWHD5-H80U9-6V85M-8280D\nZA30U-DXF84-4850Q-UMMXZ-W6K8F\nAC590-2XW97-48EFZ-TZPQE-MYHEA\nYF39K-DLFE5-H856Z-6NWZE-XQ2XD\nAC15R-FNZ16-H8DWQ-WFPNV-M28E2\nCZ1J8-A0D82-489LZ-ZMZQT-P3KX6\nYA11K-6YE8H-H89ZZ-EXM59-Y6AR0\n\n\n\n\n2.2 下载Linux系统iso(系统映像文件)\n\n\nUbuntu\n\n\nArch linux[^1 ]\n\n\nmanjaro\n\n\n\n建议选择KDE Plasma或GNOME\njust 桌面配置，后续可以改\n\n\n\ndeepin\n\n\n2.3 配置虚拟机\n\n\n打开VMware\n\n\n创建新的虚拟机[选择(自定义)]\n\n\n\n选择“安装程序光盘映像文件”，点击输入框旁边的“浏览”按钮\n\n\n\n\n\n根据下载路径,找到下载好的镜像安装包,双击选择\n\n\n注意安装位置！！！不许安装在C盘！！！\n\n\n每个处理器的内核数量修改成 2，单击“下一步”\n\n\n内存选择建议 4 GB，单击“下一步”\n\n\n网络类型选择桥接1\n\n\n默认两步\n\n\n硬盘容量默认是 20 GB，按自己需求选择，不建议太小\n\n\n接着默认下去\n\n\n2.3 以Ubuntu系统为例 安装过程的配置\n\n\n打开虚拟机\n\n\n稍等片刻后，进入如下图的界面\n\n\n\n\n改中文\n默认安装\n\n\n\n\n下图所示的界面检测到本台电脑（虚拟机）没有操作系统，询问是否要安装操作系统，默认选项“格式化磁盘然后安装Ubuntu”就是安装操作系统的选项，只是会清空虚拟机所有的磁盘*（是本台虚拟机的磁盘，不是宿主机的磁盘，所以不要大惊小怪）*，直接点“Install Now”即可\n\n\n时区选上海\n\n\n然后输入姓名、电脑名、账户和密码 一定要记得你的密码，很多终端操作都会用到这个密码\n\n\n漫长安装\n\n\n安装完成后会提示你重启，重启即可\n\n\n有可能会遇到升级成 Ubuntu Pro， Ubuntu 系统的改善建议之类的提升，跳过即可\n\n\n3.0 双系统安装\n\n\n                  \n                  Important\n                  \n                \n\n\n双系统的安装复杂程度比虚拟机难出一个量级，且有潜在的对系统危险性的操作，错误地执行这些操作可能会给你的电脑带来无法进入系统之类的结果\n在尝试安装双系统之前，请警惕这一过程可能带来的风险：操作失误可能导致数据丢失或系统无法启动。确保在开始之前备份所有重要数据，并且完全理解每一步操作的含义。如果你不熟悉分区、格式化或BIOS/UEFI设置，请先在虚拟机上练习或寻求专业人士的帮助。此外，安装过程中可能会覆盖启动项，确保你了解如何修复或恢复启动问题。\n\n\n\n3.1操作之前\n\n下载软件\n\n傲梅分区助手[用于为磁盘分区，创建系统所需要的磁盘空间，修改为GPT引导]\nRufus[用于将iso写入u盘 建议下载老版本3.15]\ndiskgenius[用于删除旧的EFI分区]\n\n\n\n3.1.1检查自己即将装系统的磁盘，确保其是GPT引导\n\n\n如何操作？\n\n右键win标识弹出这个窗口，选择磁盘管理\n\n\n\n\n选择将要装系统的磁盘，右键选择属性，选择“卷”\n\n\n\n在卷里查看自己的引导方式\n\n\n\n如果是GPT，很好，你过关!\n\n\n如果不是，执行下面操作\n1. 打开傲梅分区助手\n2. 右键选中磁盘\n3. 选择转化为GPT硬盘 你是MBR就会有转化为GPT硬盘，这里笔者的已经是GPT硬盘了\n\n\n\n\n等待转化完成\n\n3.1.2关闭windows快速启动\n\n\n\n\n\nwin + X打开终端管理员\n\n\n输入powercfg -h on确保休眠模式打开\n\n\n关闭终端\n\n\n打开控制面板\n\n\n\n\n选择硬件和声音\n选择电源设置\n\n\n\n选择更改当前不可用的设置\n\n\n\n关闭快速启动\n打开终端管理员\n输入 powercfg /a检查\n重启\n\n\n\n\n3.1.3进入Bios/UEFI [!操作失误有风险]\n\n\n上网寻找如何进入自己电脑品牌的Bios\n进入bios\nSecureBoot 改成 Disabled，禁用安全启动(部分机型需设置 BIOS 密码才可以修改 Secure Boot，找到Set Supervisor Password 设置密码)\n退出biso\n重启进入windows\n\n\n3.1.4EFI扩容\n\n\n                  \n                  Important\n                  \n                \n\n\nEFI区含有windows启动的引导文件，我们扩容的EFI实际上是删去原来的EFI分区建立一个新的Fat32分区并建立引导文件，操作不当可能会导致无法进入Windows系统内\n\n\n\n\n参考了b站BV1CT411c7n4的方法\n\n\n\n\n从C盘划分区域用于扩大EFI分区\n\n\n\n打开磁盘管理\n\n\n\n压缩一个卷[大小一定要超过320M][建议1G]\n\n\n\n搜索cmd\n选择以管理员身份运行\n\n按照下面输入\ndiskpart\nlist disk\nselsct disk 0\nlist partition\ncreate partition efi\nformat quick fs = fat32\nassign letter = P [输入这个时请确保P盘符没有被占用，如果被占用，则修改]\nlist volume\nlist partition [检查新建的分区是否存在,一般没问题]\nexit\nbcdboot C:\\windows /s P: /f UEFI [注意这里的P一定要与上文建立的新盘符相同]\nexit\n\n\n\n现在新的UEFI/boots启动已经完成\n重启\n删去原来的EFI分区\n启动diskgenius\n选择大小为260/100M的带有fat32标识的磁盘分区\n选择删除分区[请确保新的EFI分区已经建立]\n\n重启\n如果正常进入系统说明扩容成功\n\n\n\n现在隐藏盘符P\n打开傲梅分区助手\n\n\n执行操作并退出\n\n\n\n3.2 开始操作\n3.2.1 安装前操作\n3.2.1.1 制作启动盘\n\n下载你需要的linux版本的iso文件,[linux下载](###2.2 下载Linux系统iso(系统映像文件))\n插入U盘\n用Rufus制作启动盘\n\n\n\n修改引导类型选项，选择非可引导，修改分区类型，选择GPT\n\n点击“选择”，选择你下载的iso文件\n等待\n点击开始\n等待结束\n结束后退出\n\n\n\n\n3.2.1.2 为linux划分磁盘\n\n\n打开 磁盘管理\n\n\n从你要安装盘中选择一个空间大的盘选择压缩盘[不能是C盘!!!]\n\n\n压缩大小看个人实际需求，建议大于45G,笔者划分了128G[把博德之门删掉正好]\n\n\n压缩完成后无需格外操作，退出\n\n\n3.3 关机进入U盘启动安装linux\n\n\n                  \n                  Tip\n                  \n                \n\n\n这里以安装manjaro为例子\n\n\n\n\n首先高级重启电脑\n路径：Windows设置--更新和安全--高级选项--恢复--高级启动--立即重新启动\n\n3.4进入U盘启动界面开始安装\n成功从U盘启动后，首先会进入配置界面，唯一需要注意的是driver的选择\ndriver选择free还是nofree因电脑配置而异，以下仅供参考：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCPU显卡选择Intel无独显freeAMD无独显freeAMDNVIDIAno freeIntelAMDfreeIntelNVIDIAno free\n设置完毕后，enterBoot进入桌面\n\n\n然后会让你选择开始安装，建议先调整为中文，联网[在桌面右下角]\n\n\n\n\n\n时区选上海，键盘样式默认即可\n\n\n\n\n\n                  \n                  Important\n                  \n                \n\n分区\n\n选择手动分区\n\n找到你划分空间的那个盘\n\n选择你划分出来的磁盘空间[一般叫做未分配区域]\n选择创建:\n创建如下四个区域\n\n\nswap区域，一般8G,文件系统选择linuxswap\n\n\n\nboot区域，一般500M~1G,文件ext4，挂载点/boot\n\n创建root根目录，大小在20G~40G，建议大一点\n\n建立/home挂载点\n\nimportant\n建立挂载点\n返回C盘所在的硬盘空间\n找到带有FAT32的大小为1G的分区\n点击编辑\n\n全部完成后检查一遍，点击下一步\n输入用户名，密码，选择“为管理员账户使用相同的密码”记住密码！！！\noffice建议不装\n所有完成后点击安装\n\n\n3.3 安装完成后的操作\n\n安装完成后可以重新启动，然后就会看到UEFI引导，选择系统进入\n可以看这个完成安装后的初始化\n\n\nby imicola\n参考文献：\n\n【Liunx】manjaro双系统安装（折腾）教程\n教你从零开始搭建双系统——Linux(Manjaro)和Win双系统\nManjaro安装、配置、调试超详细攻略\n基于VMware虚拟机的Ubuntu22.04系统安装和配置（新手保姆级教程）\n对EFI系统分区扩容\n[201020] Manjaro（KDE桌面环境）小白向完全安装教程（附Linux简要介绍） \nWin10和Manjaro双系统安装、双系统gubr正确引导进入任意一个\n\n\n注释\n\n关于arch linux的安装，这篇博客可以提供一些指引作用\n\nFootnotes\n\n\n校园网可能无法使用桥接功能，可以买个路由器来解决，原理就是用路由器的 DHCP 功能，来管理分配 IP 地址，这样就可以使用桥接网络了，嫌麻烦也可以选择使用主机网络 ↩\n\n\n"},"TODO/大一下暑期计划/forACM":{"slug":"TODO/大一下暑期计划/forACM","filePath":"TODO/大一下暑期计划/forACM.md","title":"forACM","links":[],"tags":[],"content":"\n其实突然发现，对ACM竞赛式的学习内容其实是不成规律且离散的，但是可能就是这样的学习才是扩宽视野的一种方式吧\n训练计划\n牛客暑期多校联赛\n\n其实这玩意好像不是很重要(难度过大了)，但是毕竟都交钱了，还是得去打的\n\n\nAtcoder\n\n听lzy说Atc的题对比cf更注重算法实现与基础，而不是和cf一样都是猜猜题\n\n\ncodeforces\n\n打比赛还是要打的，主要是练习手感和写代码的感觉\n\n\n"},"TODO/大一下暑期计划/forCS":{"slug":"TODO/大一下暑期计划/forCS","filePath":"TODO/大一下暑期计划/forCS.md","title":"forCS","links":[],"tags":[],"content":"课程学习\n\n\n MIT-Missing-Semester\n\n\n这是一个学习计算机工具与一些开发工具的课程，属于非系统性质的学习，尽可能需要一些Linux或shell命令行操作的储备知识\n\n建议用一段集中时间学习，大概安排15-18小时进行学习\n安排在第一周[7.16 - 7.20]\n课程安排\n\n 课程概览与 shell\n Shell 工具和脚本\n 编辑器 (Vim)\n 数据整理\n 命令行环境\n 版本控制(Git)\n 调试及性能分析\n 元编程\n 安全和密码学(可能会跳过这节内容)\n 大杂烩\n\n\n\n\n\n MIT6.100L: Introduction to CS and Programming using Python\n\n作为老生长谈的Python学习，虽然知道重要性但是一直没机会没时间去学习，所以打算利用暑假的时间学习。\n作为一门真正的系统课，可能要耗费一定的时间，打算分配三周即[7.21-8.10]来学习，同时这段时间我打算开始学习计算机组成原理\nCsdiy认为该课程难度不大，所以选择了这样的一个作为python入门\n课程安排(B站有精翻版本，建议食用)\n\n Lecture 1: Introduction\n Lecture 2: Strings, Input/Output, Branching\n Lecture 3: Iteration\n Lecture 4: Loops over Strings, Guess-and-Check, Binary\n Lecture 5: Floats and Approximation Methods\n Lecture 6: Bisection Search\n Lecture 7: Decomposition, Abstraction, Functions\n Lecture 8: Functions as Objects\n Lecture 9: Lambda Functions, Tuples, and Lists\n Lecture 10: Lists, Mutability\n Lecture 11: Aliasing, Cloning\n Lecture 12: List Comprehension, Functions as Objects, Testing, Debugging\n Lecture 13: Exceptions, Assertions\n Lecture 14: Dictionaries\n Lecture 15: Recursion\n Lecture 16: Recursion on Non-Numerics\n Lecture 17: Python Classes\n Lecture 18: More Python Class Methods\n Lecture 19: Inheritance\n Lecture 20: Fitness Tracker Object-Oriented Programming Example\n Lecture 21: Timing Programs, Counting Operations\n Lecture 22: Big Oh and Theta\n Lecture 23: Complexity Classes Examples\n Lecture 24: Sorting Algorithms\n Lecture 25: Plotting\n Lecture 26: List Access, Hashing, Simulations, and Wrap-Up\n\n\n\n\n\n[ ]\n\n"},"TODO/大一下暑期计划/前言":{"slug":"TODO/大一下暑期计划/前言","filePath":"TODO/大一下暑期计划/前言.md","title":"前言","links":[],"tags":[],"content":"\n在期末考试绩点炸裂之后，对保研这一路径感觉顿时失去的前途的光芒，所以之后的课程学习都会更注重工程与实际而非理论学习\n其实有的时候会有纠结绩点与实际上我们需要学习的内容的冲突性，比如日语这在未来工作就业中几乎如同远牙一样几乎没有优势区间，除非留学，但是留学与在国外打工对经济实力的压力还是很大的。但就是一个在国内几乎无用的小语种学科有4.0的学分，\n国内的本科教育属于 教学任务驱动式 ,学生在完成60的及格分数，老师在完成自己的 教学指标 。而讽刺的事情是，保研或考研 是一个学生走向更好工作的门槛，但是这种门槛却设置在国内崩溃式的本科教育与其量化指标GPA上。而学习工业的，公司需要的，技术有时候却是脱离量化考核的\n"},"attachments/高数历年试卷":{"slug":"attachments/高数历年试卷","filePath":"attachments/高数历年试卷.md","title":"高数历年试卷","links":[],"tags":[],"content":"哈尔滨理工大学 2023-2024 学年第二学期高等数学期末考试试题 A卷\n一、选择题（1-5小题，每小题4分，共20分）\n\n\n曲线x = t, y = 2t, z = t^2在点(1, 2, 1)处的切线方程为（ ）\n(A)\\frac{x-1}{1} = \\frac{y-2}{2} = \\frac{z-1}{2}\n(B)\\frac{x-1}{1} = \\frac{y-2}{2} = \\frac{z-1}{3}\n(C)\\frac{x-1}{1} = \\frac{y-2}{2} = \\frac{z-1}{1}\n(D)\\frac{x-1}{1} = \\frac{y-2}{2} = \\frac{z}{1}\n\n\n设区域\\Omega为0 \\leq z \\leq \\sqrt{1 - x^2 - y^2}，则\\iiint_\\Omega [y(x^2 + z^2) + 6] \\, dx\\,dy\\,dz =（）\n(A)2\\pi\n(B)4\\pi\n(C)6\\pi\n(D)12\\pi\n\n\n级数\\sum_{n=1}^\\infty \\frac{5^n}{n^{2}} x^n的收敛域为（ ）\n(A)(-\\frac{1}{5},\\frac{1}{5})\n(B)(- \\frac{1}{5}, \\frac{1}{5}]\n(C)[-\\frac{1}{5},\\frac{1}{5}]\n(D)[-\\frac{1}{5},\\frac{1}{5})\n\n\n设\\Omega为平面x + y + z = 1与三个坐标面围成的闭区域，则\\iiint_\\Omega y \\, dx\\,dy\\,dz =（ ）\n(A)\\frac{1}{24}\n(B)2\n(C)24\n(D)\\frac{1}{2}\n\n\n可降阶微分方程y&#039;&#039;&#039; = e^x的通解为（ ）\n(A)y = e^x + C_1 x + C_2\n(B)y = e^x + C_1 x^2 + C_2\n(C)y = C_1 e^x + C_1 x^2 + C_3\n(D)y = e^x + C_1 x^2 + C_2 x + C_3\n\n\n\n二、填空题（6-10小题，每小题4分，共20分）\n\n\n过点M(1, -3, 2)且垂直于直线\\frac{x+2}{1} = \\frac{y+3}{2} = \\frac{z-2}{3}的平面方程为\n\n\n若曲线积分\\int_L (\\arctan x + 2xy) \\, dx + (kx^2 + \\sin y) \\, dy在单连通区域G内与路径无关，则k =\n\n\n函数f(x) = \\frac{\\mathrm{d}}{\\mathrm{d}x}(e^{x^{2}}-1)在x = 0处展开成幂级数为\n\n\n\\begin{align*}\ne^{x} &amp;= \\sum\\limits_{n=0}^{\\infty} \\frac{x^{n}}{n!}\\\\\ne^{x^{2}} - 1 &amp;= x^{2}+ \\frac{x^{2^{2}}}{2!} + \\cdots\\\\\n\\\\\n\n&amp;= \\sum\\limits_{n = 1}^{\\infty} \\frac{x^{2^{n}}}{n!} \\\\\n&amp;= \\sum\\limits_{n = 1}^{\\infty} \\frac{x^{2n}}{n!} \\\\\n\\frac{d}{dx}(e^{x^{2}} - 1) &amp;= \\sum\\limits_{n = 1}^{\\infty} \\frac{(2n)x^{2n-1}}{n!}(某人在这里写下过\\sum\\limits_{n = 1}^{\\infty} \\frac{\\ln(2n)x^{2n}}{n!}这样惊世骇俗的表达式)\n\\end{align*}\n\n\n曲线积分\\oint_L (|x| + |y|) \\, ds，其中L: |x| + |y| = 1，结果为\n\n\n已知f(x)是以2\\pi为周期的周期函数，且\n\n\n    f(x) = \n    \\begin{cases} \n    x + \\pi, &amp; -\\pi \\leq x &lt; 0 \\\\\n    \\pi - x, &amp; 0 \\leq x &lt; \\pi \n    \\end{cases}\n设其傅里叶级数的和函数为$S(x)$，则$S\\left(\\frac{9\\pi}{2}\\right) + S(0) =$\n\n\n三、计算解答题（11-16小题，每小题8分，共48分）\n\n\n设向量\\vec{a} = \\{1, 2, 1\\},\\vec{b} = \\{k, 1, 3\\}，且\\vec{a} \\cdot \\vec{b} = 5，求k和\\vec{a} \\times \\vec{b}。\n\n\n设z = u^2 + v^2,u = x + y,v = 2x - 4y，求\\frac{\\partial z}{\\partial x},\\frac{\\partial z}{\\partial y},dz。\n\n\n计算二重积分\\iint_D xy \\, dx\\,dy，其中D由直线y = 2,x = 2,y = 2x围成的有界闭区域。\n\n\n设L为y = \\sin x上从点O(0, 0)到点M(\\pi, 0)的一段弧，计算曲线积分：\n\n\n\\int_L (x + 3y) \\, dx + (y^2 - x) \\, dy\n\n\n求一阶线性微分方程\\frac{dy}{dx} - y = 3e^x，初始条件y|_{x=0} = 1的解。\n\n\n求二阶常系数微分方程y&#039;&#039; - 3y&#039; + 2y = 6的通解。\n\n\n\n四、综合题（17小题，8分）\n\n某工厂要用钢板制作一个容积为a^3立方米的无盖长方体容器，若不计钢板厚度，当长、宽和高各取何尺寸时，才能使制作材料最省？\n\n\n五、证明题（18小题，4分）\n\n证明：级数\\sum_{n=1}^\\infty (-1)^n \\frac{n + 2024}{n(n+1)} \\cos\\left(\\frac{n\\pi}{3}\\right)绝对收敛。\n\n哈尔滨理工大学 2023-2024 学年第二学期高等数学期末考试试题 B卷\n一、选择题（1-5小题，每小题4分，共20分）\n\n\n向量\\vec{a} = (2,1,1)，\\vec{b} = (1,0,1)，则\\text{Prj}_{\\vec{b}} \\vec{a} =（ ）\n(A)2\n(B)2\\sqrt{2}\n(C)\\frac{2}{3}\n(D)3\n\n\n设闭区域\\Omega由0 \\leq z \\leq \\sqrt{1 - x^2 - y^2}确定，则\\iiint_\\Omega 2 \\, dx\\,dy\\,dz =（ ）\n(A)2\\pi\n(B)\\frac{4\\pi}{3}\n(C){6\\pi}\n(D)12\\pi\n\n\n级数\\sum_{n=1}^\\infty \\frac{x^n}{3^n \\cdot 3^{n}} x^n的收敛半径为（ ）\n(A)\\frac{1}{3}\n(B)3\n(C)6\n(D)\\frac{1}{6}\n\n\n设\\Omega为平面x + y + z = 1与三个坐标面围成的有界闭区域，则\\iiint_\\Omega x \\, dx\\,dy\\,dz =（ ）\n(A)\\frac{1}{24}\n(B)2\n(C)24\n(D)\\frac{1}{2}\n\n\n可降阶微分方程y&#039;&#039;&#039; = x的通解为（ ）\n(A)y = \\frac{1}{24}x^4 + C_1x^2 + C_2x + C_3\n(B)y = \\frac{1}{6}x^4 + C_1x^2 + C_2x + C_3\n(C)y = C_1x^2 + C_2x + C_3\n(D)y = C_1x^3 + C_2x^2 + C_3x + C_4\n\n\n\n二、填空题（6-10小题，每小题4分，共20分）\n\n\n过点M(1, -3, 2)和N(1, 1, 1)的直线方程为\n\n\n若正项级数\\sum_{n=1}^\\infty \\frac{1}{n^p}收敛，则常数p的取值范围为\n\n\n曲线积分\\oint_L (x^2 + y^2) \\, ds，其中L为圆周x^2 + y^2 = 1，结果为\n\n\n设f(x, y, z)在空间闭区域\\Omega = \\{x^2 + y^2 + z^2 \\leq r^2\\}上连续，且f(0,0,0) = 3，则\n\n\n   \\lim_{r \\to 0^+} \\frac{1}{\\frac{4}{3}\\pi r^3} \\iiint_\\Omega f(x,y,z) \\, dx\\,dy\\,dz = \\ ?\n\n设f(x, y) = y^2 + x^2y，则\\frac{\\partial f}{\\partial x} \\bigg|_{x=1, y=1} =\n\n\n三、计算解答题（11-16小题，每小题8分，共48分）\n\n\n设\\vec{a} = (1, 2, 1)，\\vec{b} = (1, 1, 1)，求(\\vec{a} + 2\\vec{b}) \\cdot \\vec{a}和\\vec{a} \\times \\vec{b}。\n\n\n设u = x + y，v = x + yv，z = u^2 + v^2，求\\frac{\\partial z}{\\partial x}，\\frac{\\partial z}{\\partial y}，dz。\n\n\n计算二重积分\\iint_D xy \\, dx\\,dy，其中D由两坐标轴及直线x + y = 1围成的闭区域。\n\n\n设L为正向圆周x^2 + y^2 = 1，利用格林公式计算\n\n\n    \\oint_L (2xy - 4y) \\, dx + x^2 \\, dy\n\n\n求一阶线性微分方程y&#039; - \\frac{y}{x} = xe^x的通解。\n\n\n求二阶常系数微分方程y&#039;&#039; - 3y&#039; + 2y = 12的通解。\n\n\n\n四、综合题（17小题，8分）\n\n某工厂生产两种商品的产量分别为x、y，成本函数为f(x, y) = 12x^2 - 8xy + y^2，在约束条件x + 2y - 4 = 0下求成本的最小值。\n\n\n五、证明题（18小题，4分）\n\n证明：级数\\sum_{n=1}^\\infty \\frac{1}{n^2} \\tan\\left(\\frac{1}{n}\\right)收敛。\n\n哈尔滨理工大学 2022-2023 学年第二学期高等数学期末考试试题 A卷\n一、选择题（1-5小题，每小题4分，共20分）\n\n\n方程y&#039; = e^{y - x^2}，初始条件y(0) = 0的解为（ ）\n(A)e^y = \\frac{x^2}{2} + 1\n(B)e^y = \\frac{x^2}{2} + Ce^x\n(C)e^y - e^x = 2\n(D)e^y = \\frac{x^2}{2} + C\n\n\n设区域D: x^2 + y^2 \\leq 1，则积分\\iint_D (xy + 3)^2 \\, d\\sigma =（ ）\n(A)2\\pi\n(B)\\pi\n(C)2\n(D)0\n\n\n已知直线L过原点，且在平面（过三点P_0(0,0,0)、P_1(2,2,0)、P_2(0,1,-2)）上，与直线L_1: \\frac{x+1}{3} = \\frac{y-1}{2} = \\frac{z}{1}垂直，则直线L的方程为（ ）\n(A)\\frac{x-2}{2} = \\frac{y+3}{-4} = \\frac{z-1}{1}\n(B)\\frac{x}{0} = \\frac{y}{1} = \\frac{z}{-2}\n(C)\\frac{x}{1} = \\frac{y}{2} = \\frac{z}{3}\n(D)\\frac{x+1}{-3} = \\frac{y}{1} = \\frac{z}{2}\n\n\n曲线x = t^2, y = -t^2, z = t^3 + 1在点(1, -1, 2)处的切向量为（ ）\n(A)\\{1, -2, 6\\}\n(B)\\{-1, 2, 6\\}\n(C)\\{2, -1, 6\\}\n(D)\\{1, -2, 6\\}\n\n\n下列曲线积分中，与路径无关的是（ ）\n(A)\\int_L 3x^2y^3 \\, dx + 3x^3y^2 \\, dy\n(B)\\int_L x \\, dy - y \\, dx\n(C)\\int_L x^2y^3 \\, dx + y^2 \\, dy\n(D)\\int_L 3x^2y \\, dx + x^3 \\, dy\n\n\n\n二、填空题（6-10小题，每小题4分，共20分）\n\n\n二阶常系数微分方程y&#039;&#039; - y&#039; - 6y = 0的通解为\n\n\n函数z = x^2 - 3xy + 3y在点(1, 0)处沿方向\\vec{l} = \\{1, 1\\}的方向导数为\n\n\n已知f(x)是以2\\pi为周期的函数，且\n\n\n f(x) = \n \\begin{cases} \n x + 1, &amp; -1 \\leq x &lt; 0 \\\\\n 1 - x, &amp; 0 \\leq x &lt; 1 \n \\end{cases}\n设其傅里叶级数的和函数为s(x)，则s\\left(\\frac{9}{2}\\right) =\n\n\n已知向量\\vec{a}, \\vec{b}满足\\|\\vec{a}\\| = 2, \\|\\vec{b}\\| = 2, \\vec{a} \\cdot \\vec{b} = 2，则\\|\\vec{a} \\times \\vec{b}\\| =\n\n\n设L为下半圆周y = -\\sqrt{1 - x^2}，则\\int_L (x^2 + y^2) \\, ds =\n\n\n\n三、计算解答题（11-16小题，每小题8分，共48分）\n\n\n计算二重积分\\iint_D (x + y)^2 \\, dx\\,dy，其中D是由两坐标轴及直线x + y = 2围成的闭区域。\n\n\n设L为正向圆周x^2 + y^2 = a^2，计算曲线积分：\n\n\n \\oint_L \\frac{(x + y) \\, dx - (x - y) \\, dy}{x^2 + y^2}\n\n\n求一阶线性微分方程y&#039; - 2xy = 4x e^{x^2}的通解。\n\n\n求过点A(1, 2, 1)且垂直于平面\\pi_1: 2x - y + 3z + 1 = 0和平面\\pi_2: x - 2y - 2z + 4 = 0的平面方程。\n\n\n求级数\\sum_{n=1}^\\infty \\frac{(x - 1)^n}{n \\cdot 2^n}的收敛域。\n\n\n计算三重积分\\iiint_\\Omega z^2 \\, dx\\,dy\\,dz，其中\\Omega为单位球体x^2 + y^2 + z^2 \\leq 1。\n\n\n\n四、综合题（17小题，8分）\n\n设长方体的长、宽、高分别为x, y, z，求在约束条件x + y + z = 12下，使得体积V = xyz最大。\n\n\n五、证明题（18小题，4分）\n\n证明：级数\\sum_{n=1}^\\infty (-1)^n \\frac{\\sin\\left(\\frac{n\\pi}{3}\\right)}{n^3}绝对收敛。\n\n哈尔滨理工大学 2022-2023 学年第二学期高等数学期末考试试题 B卷\n一、选择题（1-5小题，每小题4分，共20分）\n\n\n方程y&#039; = e^{y - x}，初始条件y(0) = 0的解为（ ）\n(A)e^y = x + 1\n(B)e^y = \\frac{x^2}{2} + C\n(C)e^y - e^x = 0\n(D)e^y = \\frac{x^2}{2} + C e^x\n\n\n设区域D: x^2 + y^2 \\leq 1，则积分\\iint_D (\\arcsin(xy))^2 \\, d\\sigma =（ ）\n(A)2\\pi\n(B)\\pi\n(C)2\n(D)0\n\n\n若\\lim_{n \\to \\infty} u_n = 0，则级数\\sum_{n=1}^\\infty u_n的敛散性为（ ）\n(A) 绝对收敛\n(B) 发散\n(C) 条件收敛\n(D) 敛散性无法判定\n\n\n曲线x = t, y = -t^2, z = t + 1在点(1, -1, 2)处的切向量为（ ）\n(A)\\{1, 1, 4\\}\n(B)\\{1, 6\\}\n(C)\\{1, -4, 1\\}\n(D)\\{1, -1, 4\\}\n\n\n下列曲线积分中，与路径无关的是（ ）\n(A)\\int_L 3x^2y^3 \\, dx + 3x^3y^2 \\, dy\n(B)\\int_L x \\, dy - y \\, dx\n(C)\\int_L x^2y^2 \\, dx + y^3 \\, dy\n(D)\\int_L \\frac{2x}{y^3} \\, dx + \\frac{3x^2}{y^4} \\, dy\n\n\n\n二、填空题（6-10小题，每小题4分，共20分）\n\n\n二阶常系数微分方程y&#039;&#039; + 3y&#039; - 4y = 0的通解为\n\n\n函数u = x^2yz在点(1, 1, 1)处沿方向\\vec{l} = \\{2, -3, 1\\}的方向导数为\n\n\n已知函数f(x)以2\\pi为周期，且\n\n\n  f(x) = \n  \\begin{cases} \n  x, &amp; -\\pi \\leq x &lt; 0 \\\\\n  0, &amp; 0 \\leq x &lt; \\pi \n  \\end{cases}\n则其傅里叶级数的系数a_0 =\n\n\n向量\\vec{a} = (1, -1, 2)，\\vec{b} = (-1, 4, 2)，则\\vec{a}在\\vec{b}上的投影为\n\n\n设L为圆周x^2 + y^2 = 1上从点(-1, 0)到(1, 0)的上半弧段，则\\int_L 2 \\, ds =\n\n\n\n三、计算解答题（11-16小题，每小题8分，共48分）\n\n\n计算二重积分\\iint_D xy^2 \\, dx\\,dy，其中D是由直线x + 2y = 2与坐标轴围成的闭区域。\n\n\n设L为正向圆周x^2 + y^2 = a^2，计算曲线积分：\n\n\n  \\int_L \\frac{x \\, dy - y \\, dx}{x^2 + y^2}\n\n\n求一阶线性微分方程y&#039; + 3y = e^{2x}的通解。\n\n\n求过点A(1, 1, 3)且垂直于平面\\pi_1: 2x - y + 3z + 1 = 0和平面\\pi_2: x - 2y - z + 4 = 0的平面方程。\n\n\n求级数\\sum_{n=1}^\\infty \\frac{(x - 2)^{2n}}{n \\cdot 2^{2n}}的收敛域。\n\n\n计算三重积分\\iiint_\\Omega z \\, dx\\,dy\\,dz，其中\\Omega由抛物面z = x^2 + y^2与平面z = 1围成。\n\n\n\n四、综合题（17小题，8分）\n\n利用拉格朗日乘数法将正数 12 分成三个正数，使得u = 3x^2yz取得最大值。\n\n\n五、证明题（18小题，4分）\n\n证明：级数\\sum_{n=1}^\\infty \\sin\\left(\\frac{1}{n^2}\\right)收敛。\n"},"index":{"slug":"index","filePath":"index.md","title":"index","links":["C++/基础语法/C++语言入门","C++/STL/STL","ACM/算法/Readme","ACM/算法/DP-动态规划/","ACM/题解/","基础入门/MIT-Missing-Semester/前言","Linux/折腾/从零开始安装linux","归档/大一下期末/高数复习","归档/大一下期末/离散复习","杂项/正则表达式","Latex/Latex初学","TODO/大一下暑期计划/前言"],"tags":[],"content":"\n  🌿 欢迎来到我的数字花园🌿\n  在这里，我耕耘知识，静待花开。\n\n\n  \n  \n    🚀 C++ 程序设计\n    从入门到进阶，探索C++的强大功能与优雅实现。\n    \n      基础语法\n      STL 标准库\n    \n  \n  \n  \n    🧠 ACM 与算法\n    算法竞赛的笔记、解题思路与实战总结。\n    \n      算法笔记\n      动态规划\n      题解汇总\n    \n  \n  \n  \n    💻 计算机基础\n    探索计算机世界的基石，掌握高效工具与核心知识。\n    \n      MIT Missing Semester\n      Linux 探索\n    \n  \n  \n  \n    📚 大学归档\n    课程学习的资料沉淀与期末复习笔记。\n    \n      高等数学\n      离散数学\n    \n  \n  \n  \n    🛠️ 杂项与工具\n    一些零散的知识点、工具学习笔记和待办事项。\n    \n      正则表达式\n      Latex\n      暑期计划\n    \n  \n"},"基础入门/MIT-Missing-Semester/Shell":{"slug":"基础入门/MIT-Missing-Semester/Shell","filePath":"基础入门/MIT-Missing-Semester/Shell.md","title":"Shell","links":["Linux/常见命令/ls"],"tags":[],"content":"shell是什么？\n在开始之前，我们需要了解 shell 是什么？\n\nshell是一种文字交互界面，与GUI(用户图形化界面)不同，shell允许你执行程序，输入并获取某种半结构化的输出\n\n在以下的演示中，我们使用manjaro in wsl来使用shell,这里我们使用bash，既Bourne Again SHell来作为演示终端\n使用shell\n当我们打开终端时候，我们会看到类似下面的提示符\n[imicola@LAPTOP-1R3FN2QL ~]$ \n这是 shell 最主要的文本接口\n这个提示符告诉我们一些基本信息：\n\nimicola 是笔者用户名\nLAPTOP-1R3FN2QL 是电脑名称\n~ 表示工作目录，至于’~‘,实际上表示的是一整个目录结构，但是经常使用便被简写1\n$ 表示目前身份不是root用户\n\n我们可以输入命令并被shell解析，比如我们输入\n[imicola@LAPTOP-1R3FN2QL ~]$ date\nSun Jun  1 02:45:48 PM CST 2025\nshell就会告诉我们时间与日期\n我们同样可以使用shell去输入带有参数的命令，比如对echo命令，这个命令会打印你给它的参数，如下\n[imicola@LAPTOP-1R3FN2QL ~]$ echo hello\nhello\n则echo或输出hello\n\n当我们输入的参数本身带有空格的时候我们可以使用”hello world”来为echo传入一个字符串参数，我们还可以使用 hello\\ world来转译空格符号\n\n\n\n                  \n                  扩展:shell是如何找到命令并且运行的 \n                  \n                \n\n\n\n类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 环境变量 $PATH，它会列出当 shell 接到某条指令时，进行程序搜索的路径\n我们可以使用来查询我们的环境变量有什么\n\n[imicola@LAPTOP-1R3FN2QL ~]$ echo $PATH\n\n比如当我们执行echo指令时候，shell会在环境变量里通过$PATH搜索由：划分的一系列目录，基于名字搜索这个程序，当找到该程序后便执行程序\n我们也可以使用which指令确定某个程序名代表的是哪个具体的程序，这样可以绕过$PATH直接执行这个程序\n\n\n\n\n在shell中导航\n在谈论这些之前我们先需要认识导航是什么？\n\n我们从一个目录定位到另一个目录的行为称之为导航\n对于每个目录，其存在一个路径，在linux和macOS上使用/分割，在Windows上使用\\分割\n在linux或macOS上 / 也表示一个路径，代表系统的根目录，所有的文件夹都处于这个目录下\n对于Windows，每个盘都有一个根目录，如C:\\，D:\\\n对于本课程，我们从linux下考虑\n如果某个路径以/开头，则其为绝对路径，其他的都是相对路径。\n相对路径指的是相对于当前工作目录的路径\n当前工作目录可以使用命令pwd获取\n\n[imicola@LAPTOP-1R3FN2QL ~]$ pwd\n/home/imicola\n此外，切换目录可以使用cd命令。在路径中 .表示当前目录..表示上级目录\n[imicola@LAPTOP-1R3FN2QL ~]$ pwd\n/home/imicola\n[imicola@LAPTOP-1R3FN2QL ~]$ cd /home\n[imicola@LAPTOP-1R3FN2QL home]$ pwd\n/home\n[imicola@LAPTOP-1R3FN2QL home]$ cd ..\n[imicola@LAPTOP-1R3FN2QL /]$ pwd\n/\n[imicola@LAPTOP-1R3FN2QL /]$ cd ./home\n[imicola@LAPTOP-1R3FN2QL home]$ pwd\n/home\n[imicola@LAPTOP-1R3FN2QL home]$ cd imicola\n[imicola@LAPTOP-1R3FN2QL ~]$ pwd\n/home/imicola\n[imicola@LAPTOP-1R3FN2QL ~]$ ../../bin/echo hello\nhello\n注意到shell会实时显示当前的路径信息，我们也可以通过配置shell提示符来显示各种有用的信息，比如笔者自己配置的zsh显示效果如下：\n\n一般来说，当我们运行某个程序的时候，如果没有指定文件路径，则该程序会在当前目录下执行，比如我们需要知道一个目录下存在什么文件/文件夹，我们可以使用ls命令\n[imicola@LAPTOP-1R3FN2QL ~]$ ls\nastrbot  autojump  data  gewechat  imicola\n除非我们使用第一个参数指定目录，否则ls会告诉我们这个目录下的文件\n\n大多数的命令接受标记和选项（带有值的标记），它们以 - 开头，并可以改变程序的行为。通常，在执行程序时使用 -h 或 --help 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。\n\n比如ls -l可以更加详细的列出目录下文件或文件夹的信息\n15:52:39 with imicola in ~ …\n➜ ls -l\ntotal 20\ndrwxr-xr-x 2 imicola users 4096 Mar 22 20:16 astrbot\ndrwxr-xr-x 6 imicola users 4096 May 27 22:25 autojump\ndrwxr-xr-x 9 root    root  4096 Mar 22 20:43 data\ndrwxr-xr-x 3 imicola users 4096 Mar 27 15:45 gewechat\ndrwxr-xr-x 3 imicola users 4096 Mar 23 21:37 imicola\n对于 ls -l 输出的参数的含义，可以参考Linux命令ls\n同时我们应该掌握这些命令：\n\nmv(用于重命名或移动文件)\ncp(拷贝文件)\nmkdir(新建文件夹)\n\n我们可以使用man这个程序来获取程序参数、输入输出的信息，了解其工作方式\n在程序之间创建链接\n在shell中，程序有两个主要的”流”——输入流和输出流\n\n当程序试图读取信息的时候，它会从输入流中读取\n当程打印信息的时候，它会将信息输出到输出流中\n通常一个程序的输入和输出流都是终端，即将键盘作为输入流，显示器作为输出流，但我们也可以重定向这些流\n我们可以使用 &lt; file 和 &gt; file.这两个命令将程序的输入输出重定向到文件\n\n19:38:20 with imicola in ~/imicola/learn_test …\n➜ echo hello &gt; hello.txt &amp;&amp; cat hello.txt\nhello\n \n19:38:53 with imicola in ~/imicola/learn_test …\n➜ cat &lt; hello.txt &gt; hello2.txt\n \n19:39:37 with imicola in ~/imicola/learn_test …\n➜ cat hello2.txt\nhello\n\n这里解释第二条命令：我们将hello.txt的内容用cat读取然后输出流定向到hello2.txt\n\n\n==还可以使用 &gt;&gt; 来向一个文件追加内容==。使用管道(pipes)，我们能够更好的利用文件重定向。|操作符允许我们将一个程序的输出和另外一个程序的输入连接起来\n\n19:39:43 with imicola in ~/imicola/learn_test …\n➜ ls -l / | tail -n1\ndrwx------   2 root    root    4096 Apr  1 17:31 wslIjmBcD\n\ntall 命令表示显示最后几行(不加参数默认20行)，-n &lt;行数&gt; 表示显示几行，在这里我们将根目录的ls -l传入tall并且输出最后一行\n\nroot\nroot是类unix系统下的一类用户，也称根用户，一般情况下，我们不会直接以根用户的身份登录系统，因为这可能会导致某些错误，取而代之的是我们一般使用sudo命令来执行一些操作，在遇到一些权限问题或者拒绝访问时候，我们可以使用sudo命令进行访问\n\n\n                  \n                  以root用户登录系统 \n                  \n                \n\n\n在linux下，以root用户身份登录系统是非常危险的事情，请确保你确实需要再登录。\n我们可以使用\nsu root\n命令登录，这会要求你输入root用户密码\n\n\n\nFootnotes\n\n\n实际上这个~指向的是/home/user目录 ↩\n\n\n"},"基础入门/MIT-Missing-Semester/shell工具与脚本":{"slug":"基础入门/MIT-Missing-Semester/shell工具与脚本","filePath":"基础入门/MIT-Missing-Semester/shell工具与脚本.md","title":"shell工具与脚本","links":["基础入门/MIT-Missing-Semester/Shell","杂项/短路运算符","杂项/正则表达式","Linux/常见命令/find","fd","Linux/常见命令/grep","基础入门/MIT-Missing-Semester/数据整理"],"tags":[],"content":"shell脚本\n对于shell语言，我们已经在Shell里介绍了基本情况，但是如果我们想更进一步执行更复杂的操作的时候，单纯的一行一行的终端就难以满足我们。此时我们可以使用shell脚本来帮助我们执行\nshell脚本在复杂性上进一步提高\n大多数shell都有自己的一套脚本语言，包括变量,控制流和自己的语法规则，同时shell脚本针对shell所进行的工作进行了优化。\n在本章节我们会专注与bash脚本，因为它最流行也是用途最广泛的shell脚本语言\n基本语法规则\n\n在bash中为变量赋值的语法是=，例如: foo=bar,访问变量中储存的数值，其语法为$foo\n\n值得注意的是，对于foo = bar(使用空格隔开)是不能工作的，因为解释器会调用foo 并将 =和 bar 作为参数传入\n所以在使用shell脚本务必要注意空格的使用，因为空格会起到分割参数的功能。\n\n\nbash中的字符串通过 &#039; 和 &quot; 分隔符来定义，但是其含义并不一致\n\n用 &#039; 定义的字符串被成为原义字符串，其中字符串不会被转译\n用 &quot; 定义的字符串会将变量值进行替换\n\n\n\n22:28:21 with imicola in ~ …\n➜ homo=114\n \n22:28:53 with imicola in ~ …\n➜ echo &#039;$homo&#039;\n$homo\n \n22:29:28 with imicola in ~ …\n➜ echo &quot;$homo&quot;\n114\n\nbash通过 # 来进行注释\n\n和其他大多数编程语言一样，bash也支持 if , case , while 和 for这些控制流关键字，同样的，bash 也支持函数\nif\n\n在介绍if语法之前，我们需要知道\n\n在shell中，表示判断的命令通常是test或别称[ ,在实际应用中我们更喜欢使用其扩展 [[ 功能更加强大\n在一行书写多个命令的时候，需要使用 ; 分割。在 if , case 等结构中，then，do 等关键词前不需要 ; 但是如果在同一行，则需要\nif 使用 then...fi来定义代码快\nif语句用于执行条件判断，根据执行结构执行不同的代码块\n基本语法\n\n\n\nif condition; then\n\t# 如果condition为真(返回0),则执行以下命令\n\tcommand1\n\tcommand2\nfi\n\n带else\n\nif condition; then\n\t# condition 为真\n\tcommand1\nelse\n\t# condition 为假\n\tcommand2\nfi\n\n带elif\n\nif condition1; then\n\t# condition1为真\n\tcommandA\nelif condition2; then\n\t# condition1为假且condition2为真\n\tcommandB\nelse\n\t# 如果condition1 和 condition2均为假\n\tcommandC\nfi\n常用的条件判断：\n\n数值比较：\n\n[[ $a -eq $b ]]：等于 (equal)\n[[ $a -ne $b ]]：不等于 (not equal)\n[[ $a -gt $b ]]：大于 (greater than)\n[[ $a -ge $b ]]：大于等于 (greater than or equal)\n[[ $a -lt $b ]]：小于 (less than)\n[[ $a -le $b ]]：小于等于 (less than or equal)\n\n\n字符串比较：\n\n[[ &quot;$str1&quot; = &quot;$str2&quot; ]] 或 [[ &quot;$str1&quot; == &quot;$str2&quot; ]]：等于\n[[ &quot;$str1&quot; != &quot;$str2&quot; ]]：不等于\n[[ -z &quot;$str&quot; ]]：字符串为空 (zero length)\n[[ -n &quot;$str&quot; ]]：字符串非空 (non-zero length)\n\n\n文件测试：\n\n[[ -f &quot;file&quot; ]]：文件存在且是普通文件 (file)\n[[ -d &quot;dir&quot; ]]：文件存在且是目录 (directory)\n[[ -e &quot;path&quot; ]]：文件或目录存在 (exists)\n[[ -r &quot;file&quot; ]]：文件可读 (readable)\n[[ -w &quot;file&quot; ]]：文件可写 (writable)\n[[ -x &quot;file&quot; ]]：文件可执行 (executable)\n\n\n\n\ncase\ncase语法通常根据一个变量的值来进入指定的代码块，标准语法如下：\ncase experession in\n\tpattern1) # 如果experession匹配1\n\t\tcommandA\n\t\t;; # 匹配结束符\n\tpattern2)\n\t\tcommandB\n\t\t;;\n\tpattern3 | pattern4) # 可以使用 | 连接多个匹配项 \n\t\tcommandC\n\t\t;;\n\t*) # deflut情况\n\t\tcommandD\n\t\t;;\nesac\n\nwhile\n基本语法\nwhile condition; do\n\tcommand1\n\tcommand2\ndone\n\nfor\n基本语法\nfor item in list; do\n # 每次循环，item会取 list 中的一个元素\n # item是变量，list是提取的东西\n command1\n command2\ndone\n扩展语法\n类似与C语言\nfor(( initalization; condition; incement )); do\n\t# 循环体\n\tcommand1\ndone\n\n\n                  \n                  遍历文件行 \n                  \n                \n\n\n虽然不是标准的 for 循环语法，但通过管道和 while read 结合可以遍历文件的每一行。\nwhile TFS= read -r line; do\necho &quot;读取到行：$line&quot;\ndone &lt; &quot;filename.txt&quot;\n\n\n\n函数与参数\n我们通过下面这个例子了解函数\nmcd(){\n\tmkdir -p &quot;$1&quot;\n\tcd &quot;$1&quot;\n}\n这个函数表示创建一个文件夹并且cd进入这个文件夹\n这里的$1是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数，错误代码和相关变量，下面列举一些例子\n\n\n$0 - 脚本名\n$1 - $9 -脚本的参数。$1是第一个参数，以此类推\n$@ -所有参数\n$# -参数个数\n$? -前一个命令的返回值\n$$ -当前脚本的进程识别码\n!! -完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !! 再尝试一次。\n$_ -上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。\n\n\n更完整的列表可以在这里参考\n\n在命令中通常使用 STDOUT 来返回输出值，使用 STDERR 来返回错误以及错误码\n对错误码而言，返回值为0表示正常执行，其他所有非0返回值都表示有错误发生\n退出码可以搭配 &amp;&amp; (与操作符) 和 || (或操作符) 使用，用来进行条件判断，决定是否可以执行其他程序。\n注意，上述两个操作符号都属于短路运算符\n命令替换\n我们可以使用命令替换的方式来将变量的形式替换为命令的输出\n比如当我们通过$(cmd)来执行 cmd 指令的时候，他的输出结果会换掉 $(cmd)\n\n例如我们执行 for file in $(ls) shell会先执行 ls 然后遍历得到的这些返回值\n\n\n\n                  \n                  Tips\n                  \n                \n\n\n还有一个小众的特性叫做进程替换(process substitution),基本规则是 &lt;(cmd)\n当我们使用这个的时候 &lt;(cmd)会执行cmd并将结果输出到一个临时文件里,并将 &lt;(cmd)替换成临时文件名\n\n\n\n对于这个例子,我们可以通过下面的例子来解释 $(cmd)的作用\n#!/bin/zsh\n \necho &quot;程序运行开始于 $(date)&quot;\necho &quot;程序 $0 在 $# 个参数下运行与进程 $$&quot;\n \nfor file in &quot;$@&quot;\ndo\n    grep 114514 &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null\n    if [[ $? -ne 0 ]]; then\n        echo &quot;文件 $file 不存在114514,将在最后添加&quot;\n        echo &quot;114514&quot; &gt;&gt; &quot;$file&quot;\n    fi\ndone\n\n这个脚本会遍历你输入的所有文件参数并且寻找114514,如果没有找到则会在末尾添加一行114514\n\n通配\nshell的通配字符主要应用在文件路径的展开上,需要注意的是,通配不是正则表达式,而是更简单的快速选择文件的符号\n\n? 匹配一个字符\n\n如 file?.txt匹配file1.txt,fileA.txt等\n\n\n* 匹配任意字符\n\n如 *.py 匹配所有 .py 结尾的文件\n\n\n[] 匹配方括号中的任意一个字符\n\n如 [abc].txt 匹配 a.txt,b.txt,c.txt\n\n\n{} 列表生成,即扩展为逗号分隔的字符串列表\n\n如 {test1,test2}.txt 会被扩展成 test1.txt test2.txt\n\n\n\nshell 工具\n查看命令如何使用\n一般而言在shell中如果要查找某一个命令如何使用以及它可以使用的参数,我们一般使用指令\n\nman cmd\n但是有的时候英文解释看不懂,一般情况可以通过翻译以及搜索引擎了解,但是目前准确率相对较高且直接明了的方式是 询问ai\n\n查找文件\n查找文件我们一般使用find命令和fd命令,可以点击查看具体用法\n查找代码\n查找代码与文件内容我们一般使用 grep 命令,是用于对输入文本进行匹配的通用工具,同时我们也会在数据整理这节课上升入探讨\n查找 shell 命令\n对于以前输入的命令,shell一般会储存在 ~/.xxx_history\n我们可以使用history指令与 grep 寻找之前的指令,对于zsh与使用zsh框架的 oh-my-zsh都会可以使用上下键来查看历史记录\n\n对于大多数shell来说,可以使用 Ctrl + R 来对历史记录进行回溯搜索\n同时使用 oh-my-zsh的插件可以实现基于历史的补全\n\n文件夹导航\n对于一般而言 cd 足以在文件夹中进行导航,当我们想看见树状结构与文件目录的我们可以使用 tree 指令\n对于快速导航我们可以使用 auto jump这样的命令,快速跳跃到我们需要的目录里"},"基础入门/MIT-Missing-Semester/前言":{"slug":"基础入门/MIT-Missing-Semester/前言","filePath":"基础入门/MIT-Missing-Semester/前言.md","title":"前言","links":[],"tags":[],"content":"虽说这篇笔记是cs入门基础，但是笔者在写下这笔记的时候，大一都快结束了。并且笔者并非计算机科班出生的，秉着学习是高尚品格和提升计算机基础学习目的，所以打算自学这一篇课程\n课程是来自MIT的MIT-Missing-Semester,主要讲述的是大学老师不会提起但是一些非常重要的学问，在MIT课程简介上主要有以下的课程\n\nshell是什么\nshell工具与脚本\nvim和编辑器\n数据整理\n命令行环境\n版本控制(git)\n调试及性能分析\n元编程\n安全与密码学\n大杂烩\n\n对于这门课程入门，我给出的建议需要拥有一些折腾精神，这样在吸收新的知识的时候也不会感到枯燥无味\n主要是一些工具的使用，在实践性上会大于理论的东西，所以学起来难度也不会很大(至少比离散数学这种难绷课程好学多了)\n建议前置学习：\n\n基本计算机常识原理\n虚拟机的配置(能打开就行)\n"},"基础入门/MIT-Missing-Semester/数据整理":{"slug":"基础入门/MIT-Missing-Semester/数据整理","filePath":"基础入门/MIT-Missing-Semester/数据整理.md","title":"数据整理","links":[],"tags":[],"content":""},"基础入门/MIT-Missing-Semester/编辑器(vim)":{"slug":"基础入门/MIT-Missing-Semester/编辑器(vim)","filePath":"基础入门/MIT-Missing-Semester/编辑器(vim).md","title":"编辑器(vim)","links":["Linux/折腾/neovim"],"tags":[],"content":"写作与写代码其实是两件非常不同的事情,当我们写代码的时候其实大部分时间都在思考代码结构与编写模块上,这使得我们经常在文件之间切换,浏览,阅读,编辑代码\n作为程序员选择一个适合自己的代码编辑器是十分重要的\n\n学习一个编辑器\n学习一个编辑器的过程包以下的步骤\n\n阅读教程并摸索\n坚持使用这个编辑器来完成自己的编辑工作\n折腾一些更高效率的操作(插件/按键重映射)\n\n学习编辑器后效率是曲线上升的,最开始可能会降低编写代码效率,但是随着使用时间的上升,大约在20小时之后,编写代码的效率便会回到原来的水平,然后效率会越用越高\n\nvim\nvim起源于vi编辑器,是互联网初期发展时期的产物,同时现在也在不断更新与完善,出现了许多基于vim的编辑器比如neovim这类功能更加强大的编辑器,但是底层思想依旧没有改变\nvim哲学\n课程上这一节叫做vim的哲学,但是我认为这个应该叫vim的优势区间\n在我们编程的时候我们会把大量的时间花费字啊阅读和编辑代码而不是从0 to 1 的书写上.所以,vim的多模态功能便起到了作用\n\nvim对插入文字以及操控文字有着不同的摸索\nvim是可编程的,其本身的一些接口都是一个程序语言\nvim几乎只使用纯粹的键盘来进行编辑工作,避免了使用鼠标来提升编辑速度\n\n\n编辑模式\n\n\n                  \n                  Tips\n                  \n                \n\n\n在vim的按键中,我们需要区分大小写即X与x的区别,前者需要我们键入 Shift + x 而后者只需要键入 x 即可\n同时还有约定俗称的表示方法如 &lt;C-v&gt; 表示 Ctrl + v,有时候也会写成 ^v\n以及&lt;CR&gt;表示回车\n\n\n\nvim的设计以大多数时间都在阅读,浏览和进行少量改动为基础,因此其具有多种操作模式\n\n正常模式: 在文件中四处移动光标进行修改\n插入模式: 插入文本\n替换模式: 替换文本\n可视化模式(又可以细分为一般,行,块模式): 选择文本块\n命令模式: 执行命令\n\n在不同模式中敲击键盘按键的意义也不一样,当你在插入模式中按下 x 时候会输入字母x,但是在正常模式下会删除当前光标所在的字母,而在可视化模式下会删除所选择的文本块\n在默认设置下,vim会在左下角显示当前的模式.启动时候的默认模式是正常模式.\n我们可以按下 ESC 从任何其他的模式退回到正常模式,而在正常模式下\n\n按 i 进入插入模式(insert)\n按 R 进入替换模式(Replace)\n按 v 进入(一般)可视化模式(view)\n\n按 V 进入(行)可视化模式\n按 C-v 进入(块)可视化模式\n\n\n按 : 进入命令模式\n\n基本操作\n插入文本\n在正常模式下按 i 进入插入模式,在轻度使用vim进行编辑工作的话,前面操作 + 会插入文本 + 会保存退出其实已经完全够用了把vim用成记事本\n缓存,标签页,窗口\nvim会维护一系列打开的文件,然后这些被打开的文件被称为”缓存”. 一个Vim会话包含一系列标签页,每个标签页包含一系列窗口(分隔窗口),窗口只是缓冲区的视图。一个缓存可以在多个窗口打开，甚至在同一个标签页内的多个窗口打开\nVim默认打开一个标签页,这个标签页也包含一个窗口\n命令行\n在正常模式下键入 : 进入命令模式,在键入 :后,光标会跳转到屏幕下方的命令行(当然如果你使用了插件或者Lazyvim可能会有所不同)\n一些常见的vim命令\n\n:q 退出(关闭窗口)(随机字符串生成器)\n:w 写入(保存)\n:wq 保存并退出\n:e{文件名称} 打开要编辑的文件\n:ls 显示打开的缓存\n:help {标题} 打开帮助文档\n\n:help :w 打开 :w命令的帮助文档\n:help w 打开 w 移动的帮助文档\n\n\n\nvim接口\nvim的设计思想表示vim的界面本身就是一个程序语言,键入操作(以及其助记名)本身就是命令.这些命令可以组合使用.这就使得移动和编辑变得更加高效,特别是一旦形成了肌肉记忆\n移动\n多数的时候在我们会在正常模式下,使用移动命令在缓存中进行移动.在Vim中移动也被称为”名称”,因为其指向文本块\n\n基本移动: hjkl (左上下右)\n词: w 下一个词, b 词初, e词尾\n行: 0 行初, ^ 第一个非空格字符, $ 行尾\n屏幕: H 屏幕首行, M 屏幕中间, L 屏幕底部\n翻页: &lt;C-u&gt; 上翻, &lt;C-d&gt; 下翻\n文件: gg 文件头, G文件尾\n行数: :{行数}&lt;CR&gt; 或者 {行数}G\n杂项: %(找到配对,比如找到括号对以及注释对之类的)\n查找: f{字符},t{字符},F{字符},T{字符}\n\n查找/到 → 向前/向后的字符\n,/; 用于导航匹配\n\n\n搜索: /{正则表达式}, n/N 用于导航匹配\n\n选择\n现在我们可以使用键盘代替我们的鼠标,我们可以采用编辑命令与移动命令来组合完成对文本的编辑,vim的编辑命令也被称为”动词”,因为动词可以施动与名词\n\ni 进入编辑模式\n\n对于操作/编辑文本可以使用退格键完成\n\n\nO/o 在 之上/之下 插入\nd{移动命令} 删除{移动命令}的行列\n\n例如 dw 删除词, d$ 删除到行尾 , d0 删除到行头\n\n\nc{移动命令} 改变{移动命令}\n\n等价与d{移动命令}后加i\n例如,cw 等价于 dwi\n\n\nx 删除字符 (等价于 dl)\ns 替换字符 (等价于 xi)\n可视化模式 + 操作\n\n选择文字, d 删除 或 c 改变\n\n\nu 撤销 , &lt;C-r&gt; 回撤\ny 复制\np 粘贴\n还有一些不在此处列出\n\n计数\n我们可以使用一些数字来结合名词或者动词\n\n3w 向后移动三个词\n5j 向下移动5行\n7dw 删除7个词\n\n修饰语\n你可以使用修饰语来改变”名词”的意义,修饰语有 i 表示在内部, a 表示周围\n\nci( 改变当前括号内的内容\nci[ 改变当前方括号的内容\nda&#039; 删除一个单引号字符串,包括周围的单引号\n"},"归档/大一下期末/大学物理/动量定理与能量定理":{"slug":"归档/大一下期末/大学物理/动量定理与能量定理","filePath":"归档/大一下期末/大学物理/动量定理与能量定理.md","title":"动量定理与能量定理","links":[],"tags":[],"content":"冲量与力\n冲量是力在时间上的累计\n\\vec{I} = \\int F(t)\\,dt\n典型题目:\n\n已知F(t)求k秒内的冲量大小\n\nI = \\int_{0}^{k}F(t)\\,dt \n动量定理与动能定理\n动量定理:\n在合外力为0的情况下:\n有:\np = \\sum\\limits_{i=1}^{n}m_{i}v_{i} = k\n其中k为常矢量\n更一般的形式:\n\\begin{align*}\nm_{0}v_{0} &amp;= m_{0}v_{0}&#039; + m_{1}v_{1} \\tag{1}\\\\\nm_{0}v_{0} &amp;= (m_{0}+ m_{1})v_{\\text{共}}\\tag{2}\\\\\n\\end{align*}\n其中 (1) 表示弹性碰撞的情况 (2) 表示完全非弹性碰撞的情况\n\n有一个速度为v,质量为m的钢球,射向质量为m&#039;的靶,靶的中心有一个小孔,孔中有一个弹簧\n"},"归档/大一下期末/大学物理/运动学与动力学":{"slug":"归档/大一下期末/大学物理/运动学与动力学","filePath":"归档/大一下期末/大学物理/运动学与动力学.md","title":"运动学与动力学","links":[],"tags":[],"content":"直线运动\n给出位移-时间方程求速度方程与加速度方程\n\\begin{align*}\nx(t)&#039; &amp;=  v(t)\\\\\nv(t)&#039; &amp;= a(t)\n\\end{align*}\n给出运动方程，求轨迹方程\n\\begin{align*}\nr(\\vec{i},\\vec{j}) &amp;= P(t)\\vec{i} \\ + Q(t)\\vec{j}\\\\\n&amp;\\begin{cases}\nx &amp;= P(t)\\\\\ny &amp;= Q(t)\\\\\n\\end{cases}\n\\end{align*}\n将t代换为x(y) 即可联立解出轨迹方程\n给出加速度求运动方程\n给出a(t) 求 x(t)\n\\begin{align*}\na &amp;= \\frac{dv}{dt} = a(t)\\\\\ndv &amp;= a(t) \\, dt\\\\\nv &amp;= \\int a(t) \\, dt\\\\\n\\\\\nv &amp;= \\frac{dr}{dt} =v(t)\\\\\ndr &amp;= v(t) \\, dt\\\\\nr &amp;= \\int v(t) \\, dt \n\\end{align*}\n圆周运动\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n切向加速度a_t法向加速度a_nv : 线速度\\omega : 角速度s : 线量\\theta : 角量a_t=\\dfrac{\\mathbf{d}v}{\\mathbf{d}t}a_n=\\dfrac{v^{2}}{r}同时,对角量和线量可以通过v = \\omega r来联系同时有总加速度 a = \\sqrt{a_{n}^{2}+a_{t}^{2}}\n动力学\n牛顿定理:\n牛二书写注意\n\\begin{align*}\n\\vec{F} &amp;=  \\frac{d\\vec{P}}{dt}\\\\\n\\vec{F} &amp;= \\frac{m(d\\vec{v})}{dt}\\\\\n\\vec{F} &amp;= m\\vec{a}\n\\end{align*}\n运动学容易与动力学一起考\n如:\n\n给你一个力与时间的函数F(t)求x(t)\n\n\\begin{align*}\nF(t) &amp;= ma(t)\\\\\na(t) &amp;= \\frac{F(t)}{m}\\\\\na(t) &amp;= \\frac{dv}{dt} \\\\\nv(t) &amp;= \\int a(t)\\, dt \\\\\nv(t) &amp;= \\frac{dx}{dt}\\\\\nx(t) &amp;= \\int v(t)\\, dt\\\\\n\\end{align*}\n\n给定F(t)和v_0求t_{1} \\to t_{2}移动距离\n\n\\begin{align*}\n同上题求出 : \\quad &amp; v(t)\\\\\nx &amp;= \\int_{t_{1}}^{t_{2}} v(t)\\, dt\n\\end{align*}"},"归档/大一下期末/大学物理/默写公式":{"slug":"归档/大一下期末/大学物理/默写公式","filePath":"归档/大一下期末/大学物理/默写公式.md","title":"默写公式","links":[],"tags":[],"content":"\n波动方程的形式\n\n\n基本形式\n\ny(x,t) = A\\cos\\left[\\omega\\left(t \\mp + \\frac{x}{u} \\right)+ \\phi\\right]\n\n扩展为\n\ny(x,t) = A\\cos\\left[\\omega\\left(t \\ \\mp \\frac{x \\pm x_0}{u} \\right)+ \\phi\\right]\n\n一般形式\n\ny(x,t) = A\\cos (kx \\, \\mp \\omega t \\, + \\phi )\n其中:\n\n\\omega = \\frac{2\\pi}{T} 为角频率\nk = \\frac{2\\pi}{\\lambda} 为波数\n\n\n\n静电场的基本公式\n\n\n电势\n\n\\begin{align*}\n\\varphi &amp;=  k \\frac{Q}{r} \\\\\n\\\\\n\\text{其中:} k &amp;= \\frac{1}{4\\pi \\epsilon} \n\\end{align*}\n\n电势差\n\nU = \\varphi_{1} - \\varphi_{0}\n如果知道电场:\nU = \\int_{a}^{b} E \\ dl\n如果知道电场力做功\nU = \\frac{W}{q}\ntips:我们可以依据这些写出电场力做功的表现形式:\nW = \\int_{A}^{B} qE \\ \\mathbf{d}l\n\n电场强度E\n\nE = \\frac{F}{q_{0}}= \\frac{1}{4\\pi \\epsilon_{0}}\\ \\frac{Q}{r^{2}} \n或者更常见的\nE = \\frac{Q}{4\\pi r^{2} \\epsilon_{0}}\n\n\n高斯定理\n这里我们只讨论几种特殊的对称高斯面\n\n\n球面\n选取半径为 r 的球面作为高斯面有\n\n\\oint_{S}E\\ \\mathbf{d}S = \\frac{Q}{\\epsilon_{0}} \n环路积分可以化简为:\n4\\pi r^{2}E = \\frac{Q}{\\epsilon_{0}}\n\n圆柱面\n选取底面半径为 r 的圆柱面作为高斯面有\n\n\\oint_{S}E\\ \\mathbf{d}S = E \\ (2\\pi rL) \n其中 L 为长度,通常会与 q = \\lambda L 抵消(\\lambda为单位长度电荷)\n即:\n\\oint_{S}E\\ \\mathbf{d}S = 2\\pi rLE = \\frac{\\lambda L}{\\epsilon_{0}}\n\n平面对称电荷分布\n例如无限大均匀带电平面、均匀带电无限厚平板。此时选择圆柱形或长方体高斯面（高斯箱），使其穿过平面。\n\n\\oint_{S}E \\ \\mathbf{d}S = E \\ (2A)\nA 为高斯箱底面面积\n\n证明一个物体在做简谐运动:\n\n回复力与位移成正比且相反\n加速度与位移成正比且相反\n\n\n旋转矢量法\n\n\\omega \\Delta t = \\theta\n默认\\omega逆时针旋转\n沿着转动方向看x变换是正向还是负向\n旋转矢量要看单个质元的情况\n\n\n电容器并联:\nC = C_{1}+ C_2\n电容器串联:\n\\frac{1}{C} = \\frac{1}{C_{1}} + \\frac{1}{C_{2}}\n电容器电容量计算:\nC = \\frac{Q}{U} \n\n在一个封闭系统中,电荷量保持不变,则可以有\n\nU_{PQ} = \\frac{C_{整体}}{C_{PQ}} Q \n\n圆柱形电容器内部的电场强度 E 随着半径 r 的变化而变化，其表达式为：\nE(r) = \\frac{Q}{2\\pi \\epsilon \\epsilon_{0}R_{1}R_{2}} \\cdot  \\frac{R_{1}R_{2}}{r} = \\frac{V}{r\\ln{\\frac{R_{2}}{R_{1}}}}\n\nQ是电容器上储存的电荷量\n\\epsilon_0是真空介电常数 (8.85×10^{−12}{F}/{m})\n\\epsilon是电介质的相对介电常数\nV是电容器两端的电压\nR_1是内导体半径\nR_2是外导体半径\n当 r = R_1时候有V = V_{max}\n\n对于平行板电容器\nE = \\frac{V}{d}\n\nV是两端电压\nd是两端距离\n\n球形电容器\nE(r) = \\frac{Q}{4\\pi \\epsilon \\epsilon_{0}r^{2}} = \\frac{V}{r^{2}} \\cdot \\frac{R_{1}R_{2}}{R_{2}-R_{1}}\n\n当 r = R_1时候有V = V_{max}\n\n"},"归档/大一下期末/离散复习":{"slug":"归档/大一下期末/离散复习","filePath":"归档/大一下期末/离散复习.md","title":"离散复习","links":["归档/大一下期末/离散数学/集合","归档/大一下期末/离散数学/关系","归档/大一下期末/离散数学/映射","归档/大一下期末/离散数学/谓词逻辑与命题推理","归档/大一下期末/离散数学/近世代数","归档/大一下期末/离散数学/布尔逻辑与格","归档/大一下期末/离散数学/图论与树","归档/大一下期末/离散数学/数理逻辑"],"tags":[],"content":"Transclude of 集合\n\nTransclude of 关系\n\nTransclude of 映射\n\nTransclude of 谓词逻辑与命题推理\nTransclude of 近世代数\nTransclude of 布尔逻辑与格\n\nTransclude of 图论与树\n\nTransclude of 数理逻辑"},"归档/大一下期末/离散数学/关系":{"slug":"归档/大一下期末/离散数学/关系","filePath":"归档/大一下期末/离散数学/关系.md","title":"关系","links":[],"tags":[],"content":"\n\n                  \n                  写法习惯注意 \n                  \n                \n\n\n本文以下内容表示x,y的一个二元关系R的写法表现为(x,y) \\in R\n也有如同 xRy 表示二元关系的\n\n\n\n五种关系\n由集合S上的元素构成二元关系R\n\n自反\n\n定义：对于 \\forall x \\in S 都有 (x,x) \\in R\n证明思路：\n\n设x \\in S\n根据基于R的具体定义构造x与x的关系并且满足于R\n因此(x,x) \\in R\n\n\n\n\n对称\n\n定义：\\forall x,y \\in S,如果 (x,y) \\in R,那么(y,x) \\in R\n证明思路：\n\n设x，y \\in S且(x,y) \\in R\n根据(x,y) \\in R 与R的具体定义，推导出y与x也满足关系 R\n因此(y,x) \\in R\n\n\n\n\n传递\n\n定义：\\forall x,y,z \\in S,如果(x,y) \\in R且(y,z) \\in R 那么 (x,z) \\in R\n证明思路：\n\n设 x,y,z \\in S 且 (x,y) \\in R \\quad \\text{and}\\quad (y,z) \\in R\n根据R推导出x与z也满足关系\n因此(x,z) \\in R\n\n\n\n\n反对称\n\n定义：\\forall x,y \\in A 如果(x,y)\\in R且(y,x)\\in R 那么x = y\n证明思路：\n\n设x,y \\in S 且 (x,y) \\in R 且 (y,x) \\in R\n根据R推导出如果假设成立则必须有x = y\n因此 x = y,故R是反对称的\n\n\n\n\n\n等价类\n等价类代表某一特性在这个等价关系中是 等价的\n如在x \\equiv y \\ (\\mod 3)关系下有三个等价类：\n[0] = \\{x \\ | x \\mod 3 = 0,x \\in I\\}\n[1] = \\{x \\ | x \\mod 3 = 1,x \\in I\\}\n[2] = \\{x \\ | x \\mod 3 = 2,x \\in I\\}\n等价关系与偏序关系\n若一个二元关系R满足自反 对称 传递 则这个二元关系为等价关系\n若一个二元关系R满足自反 反对称 传递 则这个二元关系为偏序关系\n关系的运算\n关系的复合运算一般使用矩阵形式展开\nA_{ij} = \\begin{cases}\n1 &amp; (i,j) \\in R \\\\\n0 &amp; (i,j) \\notin R\n\\end{cases}\n\n复合关系 R \\circ S 则使用R矩阵与S矩阵进行矩阵乘法\n逆关系矩阵为原矩阵的转置\n"},"归档/大一下期末/离散数学/图论与树":{"slug":"归档/大一下期末/离散数学/图论与树","filePath":"归档/大一下期末/离散数学/图论与树.md","title":"图论与树","links":[],"tags":[],"content":"\n\n                  \n                  Tips\n                  \n                \n\n\n考虑历年题目，按重要程度书写\n\n\n\n最小生成树问题\n\n通常以一个带权无向图的形式出现（图可能代表城市、村庄、矿井采集点等）\n问题直接明了：“求总成本最低的补给线路”、“设计总造价最小的修路方案”、“计算最小成本”等。\n要求：不仅要算出最小的总权值，通常还需要画出或列出构成最小生成树的边集。\n\n算法：\n\n克鲁斯卡尔算法：按权值从小到大选择边，只要不形成回路就加入，直到链接完所有定点为止\nPrim算法：从一个顶点开始，每次选择连接已选顶点集和未选顶点集的权值最小的边\n一般而言选择第一种算法，更加直观清晰\n\n主要模型建模\n\n哈密顿回路/路径：\n\n场景：“圆桌会议”,“旅行商问题”\n问题：“能否安排座位使得相邻的人都能交谈？”,“能否找到一条路径访问所有点一次？”\n方法：将人/地点视为 顶点，将可以交流/连接的关系视为 边，问题转化为寻找一条经过所有顶点的回路。\n判断是否存在哈密顿回路方法：\n\n这是一个完全NP问题，我们可以依据下面一些条件初步判断\n\n若顶点数大于3：\n\nDirac定理：若每个顶点的度数 deg(v) \\geq \\frac{n}{2}则为哈密顿图\nOrc定理 ：若对两个不相邻的顶点u,v 有deg(v) + deg(u) \\geq n则是哈密顿图\n\n\n这是一个充分条件，有时候不满足上述两条也可能构成哈密顿图，需要自己再看看\n\n\n\n\n\n\n图的着色 (Graph Coloring)\n\n场景：“考试时间安排”、“会议安排”、“地图着色”。\n问题：“最少需要多少时间段才能考完所有课程？”\n方法：将课程/事件/国家视为顶点，如果两个课程有学生同时选修（即存在冲突），则在对应顶点间连一条边。问题转化为求该图的色数（最少需要多少种颜色给顶点着色，使得相邻顶点颜色不同）。\n\n这是一个著名的NP完全问题，在考试情景下不可能过分困难\n勇敢尝试\n\n\n\n\n匹配 (Matching)\n\n场景：“配对问题”、“任务分配”\n问题：“能否选出4组不同的配对，用完所有8种颜料？\n建模方法：将颜料/人员视为顶点，能互相搭配的关系视为边。问题转化为寻找图中的 完美匹配（一个覆盖所有顶点的边子集，且边与边之间不共享顶点）。\n\n完美匹配存在的性质\n\n当一个图的顶点数量|V|为偶数时候才有可能存在完美匹配\n最大匹配是指图中边数最多的匹配\n如果一个最大匹配包含了图中的所有顶点，那么它就是一个完美匹配\n如果一个图有偶数个顶点且存在哈密顿回路，那么这个图一定存在完美匹配\n\n\n\n\n\n\n\n理论证明：平面图与欧拉公式\n主要考虑\n\n欧拉公式：v - e + f = 2 \n其中，v:顶点数,e:边数, f:面数(不用忘记外部面)\n\n推论1： 对于v ≥ 3的简单连通平面图e ≤ 3v - 6\n推论2： 如果简单连通平面图中没有长度为3的回路（即没有三角形），e ≤ 2v - 4\n面度数推论 ：根据握手定理我们可以得出\\sum\\limits_{i=1}^{f}deg(F_{i}) = 2e\n即所有面的度数之和等于2倍的边数\n\n\n"},"归档/大一下期末/离散数学/布尔逻辑与格":{"slug":"归档/大一下期末/离散数学/布尔逻辑与格","filePath":"归档/大一下期末/离散数学/布尔逻辑与格.md","title":"布尔逻辑与格","links":[],"tags":[],"content":"本篇依旧是在代数系统(A,*)上进行讨论\n\n偏序集\n\n也就是判断给定(A,*)是不是偏序关系\n\n证明自反，反对称，传递\n\n\n\n\n格\n\n对任意两个元素a,b \\in A都存在最小上界(a \\lor b)和最大下界(a \\land b)\n\n\n有界格\n\n在格的基础上存在最大元素(记作1)和最小元素(记作0)\n\n\n有补格\n\n在有界格(A,*,0,1)基础上，对\\forall \\ a \\in A 有 \\exists \\ a&#039; \\in A \\Rightarrow a \\land a&#039; = 0 \\quad and \\quad a \\lor a&#039; = 1\n补元不一定是唯一的\n\n\n分配格\n\n满足以下两个等价的分配律中的任意一个\n\n\\forall a,b,c \\in A \\Longrightarrow a\\lor(b\\land c)=(a\\lor b)\\land(a\\lor c)\n\\forall a,b,c \\in A \\Longrightarrow a\\land(b\\lor c)=(a\\land b)\\lor(a\\land c)\n\n\n\n\n布尔代数\n\n(B,\\land,\\lor,&#039;,0,1)是一个布尔代数，如果它是一个有补分配格\n\n\n"},"归档/大一下期末/离散数学/数理逻辑":{"slug":"归档/大一下期末/离散数学/数理逻辑","filePath":"归档/大一下期末/离散数学/数理逻辑.md","title":"数理逻辑","links":[],"tags":[],"content":"\n数理逻辑只需要记住三个公式(会不会自求多福吧因为我也不会)\n一\n\nP \\to Q \\iff \\neg \\ P\\ \\lor\\ Q\n\n二\n\n\\begin{align*}\n\\neg(\\exists \\ x)P(x) \\iff&amp; (\\forall\\  x)\\neg P(x)\n\\\\\n\\neg (\\forall \\ x)P(x) \\iff&amp; (\\exists \\ x)\\neg P(x) \n\\end{align*}\n\n三 ：量词分配：\\forall只能对\\land分配 \\exists只能对\\lor分配\n\n\\begin{align*}\n\\forall x (P(x) \\land Q(x)) \\iff \\forall x P(x) \\land \\forall x Q(x) \\\\\n\\exists x (P(x) \\lor Q(x)) \\iff \\exists x P(x) \\lor \\exists x Q(x)\n\\end{align*}"},"归档/大一下期末/离散数学/映射":{"slug":"归档/大一下期末/离散数学/映射","filePath":"归档/大一下期末/离散数学/映射.md","title":"映射","links":[],"tags":[],"content":"单射与满射\n映射最重要的两个概念：单射，满射\n有一个映射 f 满足 X \\to Y\n\n对单射证明：\n\n\\forall x_1,x_{2}\\in A 如果 x_{1} \\ne x_{2} \\Longrightarrow f(x_{1}) \\ne f(x_{2}) 则f为单射\n\n\n对满射的证明：\n\n\\forall y \\in Y \\quad \\text{if} \\  \\exists x \\in X \\Longrightarrow f(x) = y 则 f 为满射\n\n\n对双射的证明：\n\n如果映射 f 同时满足单射和满射，则 f 为双射\n\n\n\n映射的复合\n我们可以将集合的复合看为函数的复合\n\n求映射的复合\n\n将两个映射看为函数复合\n\n\n\n\n事实上，我们可以完全等价 (f \\circ g)(x) \\iff f(g(x))\n在我们解决一些问题上也会应用这个概念\n\n\n已知 f : X\\to Y \\ , \\ g : Y\\to Z 且 g \\circ f 为满射，证明g为满射\n\n思路：\n\n\\forall z \\in Z 有 \\exists x \\in X使得 (g \\circ f)(x) = z\n(g \\circ f)(x) \\iff g(f(x))\n因为x \\in X且f : X\\to Y 则f(x) \\in y\n令f(x) = y_{0} 且g: Y \\to Z,则有g(y_{0}) \\in Z\n即证\n\n\n\n\n\n映射的逆\n映射存在逆的充要条件是映射是双射\n\n如何求逆？\n\n令f(x) = y 则 f^{-1}(y)就是将f(x) = y中x，y互换\n\n\n"},"归档/大一下期末/离散数学/谓词逻辑与命题推理":{"slug":"归档/大一下期末/离散数学/谓词逻辑与命题推理","filePath":"归档/大一下期末/离散数学/谓词逻辑与命题推理.md","title":"谓词逻辑与命题推理","links":[],"tags":[],"content":"谓词符号化\n一般而言这类题目不难，思路是设出R(x):x为xxx,S(x):x为xxx\n然后注意对\\forall,\\exists的使用\n\n谓词符号化：所有的人都是要死的，苏格拉底是人，所以苏格拉底是要死的。\n\n设M(x):x是人\n设R(x):x会死\n设s:s是苏格拉底\n有：因为(\\forall x)(M(x) \\to R(x)) \\land M(s)故R(s)\n\n\n谓词符号化:所有的大学生都会说英语，有一些大学生会说法语\n\n设E(x):x会说英语\n设F(x):x会说法语\n设S(x):x是大学生\n有1.(\\forall x)(S(x) \\to E(x)) 2.(\\exists x)(S(x) \\land F(x))\n注意，在使用\\exists时候，我们需要使用合取来表示含义而不是蕴含\n同时两个陈述并列的时候应该不要使用\\lor链接\n\n\n\n命题推理\n以题目形式表现\n\n证明下列推理形式的有效性:今天或者是晴天,或者会下雨。如果是晴天,我就会去打球;如果我去打球,那么我就不读书。所以如果我在读书,那么天就在下雨。\n\n命题符号化\n\n设p为今天是晴天\n设q为今天是雨天\n设b表示我去打球\n设r表示我在读书\n\n\n符号化有:\n\n\n\n\\begin{align*}\n&amp; p \\lor q \\, ,\\quad p \\to b \\, , \\quad b \\to \\neg r &amp;\\Rightarrow \\qquad r \\to q \\\\\n\\\\\n&amp; (1) \\quad r &amp;P(附加) \\\\\n&amp; (2) \\quad b \\to \\neg r &amp;P\\\\\n&amp; (3) \\quad \\neg b &amp;T(1)(2)I\\\\\n&amp; (4) \\quad p \\to b &amp;P\\\\\n&amp; (5) \\quad \\neg p &amp;T(3)(4)I\\\\\n&amp; (6) \\quad p \\lor q &amp;P\\\\\n&amp; (7) \\quad q &amp;T(5)(6)I\\\\\n&amp; (8) \\quad r \\to q &amp;CP\n\\end{align*}\n\n\n主要逻辑规则\n\n如果有p \\to q和p,则可以推出q\n如果有p \\to q和\\neg q,则可以推出\\neg p\n如果有p \\lor q和\\neg q 则可以推出p,反之亦然\n如果有p和q,则可以推出p \\land q ,反之亦然\n如果有p \\to q和q\\to r，则可以推出p \\to q\n如果有(p \\to q) \\land (r \\to s)和p \\lor r，则可以推出q \\land s\n\n\n\n反证法例子\n\n一个具体的例子:证明 p \\to q \\Rightarrow \\neg q \\to \\neg p\n\n\n\n\\begin{align*} \n&amp; (1) \\quad p \\to q &amp; P \\\\ &amp; (2) \\quad \\neg (\\neg q \\to \\neg p) &amp; P \\quad (\\text{反证假设}) \\\\ &amp; (3) \\quad \\neg q \\land \\neg (\\neg p) &amp; T(2) \\quad (\\text{由 } \\neg (A \\to B) \\equiv A \\land \\neg B \\text{}) \\\\ &amp; (4) \\quad \\neg q \\land p &amp; T(3) \\quad (\\text{由双重否定 } \\neg(\\neg p) \\equiv p \\text{}) \\\\ &amp; (5) \\quad p &amp; T(4) \\quad (\\text{由合取消除}) \\\\ &amp; (6) \\quad \\neg q &amp; T(4) \\quad (\\text{由合取消除}) \\\\ &amp; (7) \\quad q &amp; T(1)(5) \\quad (\\text{由 } p \\to q \\text{ 和 } p \\text{，通过肯定前件}) \\\\ &amp; (8) \\quad q \\land \\neg q &amp; T(6)(7) \\quad (\\text{由 } q \\text{ 和 } \\neg q \\text{，得到矛盾}) \\\\ &amp; (9) \\quad \\neg \\neg (\\neg q \\to \\neg p) &amp; IP(2-8) \\quad (\\text{由矛盾，推导出假设的否定}) \\\\ &amp; (10) \\quad \\neg q \\to \\neg p &amp; DN(9) \\quad (\\text{由双重否定，得到原结论}) \\end{align*} $$\n- 显然反证法没有CP好用"},"归档/大一下期末/离散数学/近世代数":{"slug":"归档/大一下期末/离散数学/近世代数","filePath":"归档/大一下期末/离散数学/近世代数.md","title":"近世代数","links":[],"tags":[],"content":"群\n一个代数系统通常包括一个集合A和一个关系* 记作(A,*)\n群\n\\begin{cases}\n半群\n\\begin{cases}\n封闭性 \\\\ 结合律\n\\end{cases}\n\\\\ \\\\ \\downarrow\\\\ \\\\\n幺半群 : \\exists \\ 单位元\n\\\\ \\\\ \\downarrow \\\\ \\\\\n对每个元素有逆元\n\\end{cases}\n当然还有阿贝尔群(群的基础上添加交换律)和循环群(有生成元)\n现在我们主要讲讲如何考虑单位元和逆元，封闭性和结合律的证明都是通过任取元算(\\forall x,y,z \\in A),通过*证明满足x*y \\in A和x*(y*z) = (x*y)*z即可\n\n单位元\n\n定义：\\exists e \\in A,使得\\forall a \\in A都有a*e = a且 e*a = a\n证明思路：\n\n猜测或找到一个候选的单位元e\n证明这个e确实在集合G中\n对\\forall a \\in A：\n\n证明 a*e = a\n证明 e*a = a\n\n\ntips: 如果运算是交换的，证明上述一个即可\n\n\n\n\n逆元\n\n定义：\\forall a \\in A 都 \\exists\\ a^{-1} \\in A使得 a*a^{-1} = e \\quad and \\quad a^{-1}*a = e\n证明思路\n\n任取a\\in A (\\forall a \\in A)\n找到或猜测a的候选逆元a^{-1}，这通常是基于运算的定义和单位元\n证明a^{-1} \\in G\n证明a*a^{-1} = e\n证明a^{-1}*a = e\n\n\n\n\n"},"归档/大一下期末/离散数学/集合":{"slug":"归档/大一下期末/离散数学/集合","filePath":"归档/大一下期末/离散数学/集合.md","title":"集合","links":[],"tags":[],"content":"\n给定两个集合A,B和全集S求：\n\n交集A \\cup B\n\nA与B的所有元素\n\n\n并集\n\nA与B中都有的元素\n\n\n差集A - B\n\n将A中元素减去B中存在的\n\n\n对称差A \\bigtriangleup B\n\nA \\bigtriangleup B = (A - B) \\cup (B-A)\n\n\nA的余集\n\n全集中非A的部分,即 S - A\n\n\n笛卡尔积A \\times B\n\nA \\times B = \\{(a,b)|a \\in A \\, , \\, b \\in B\\}\n最后形式上应该如\\{(a_{1},b_{1}),  (a_{1},b_{2}),(a_{1},b_{3}),(a_{2},b_{1}) \\cdots (a_{3},b_{3}) \\}\n笛卡尔积对交并差有结合律\n\n\n2^A 即A所有子集构成的集合 注意不要忘记\\varnothing和本身\n\n\n证明两个集合相等\n\n互为子集法\n例：集合A为偶数集合，集合B\\{x|x \\mod 2 = 0,x \\in Z \\}\n具体步骤\n\n任取元素 ： 设 x \\in A\n性质处理 ： 则 x 为偶数，即 \\exists k \\ , \\ x = 2k\n证明子集 ： 2k \\mod 2 = 0即x \\in B ,故A \\subseteq B\n反向证明 ： 设 y \\in B 有 y \\mod 2 = 0,即 y 为偶数，故 B \\subseteq A\n证明相等 ： 因为 A \\subseteq B 且 B \\subseteq A,故 A = B\n\n\n\n\n证明对称差满足结合率\n\n即证明 ： A \\bigtriangleup (B \\bigtriangleup C) = (A \\bigtriangleup B) \\bigtriangleup C\n证明思路：\n\nA \\bigtriangleup B = (A - B) \\cup (B - A)\n将上式左右打开即可证明\n\n\n\n\n容斥原理\n\n\\left|\\sum\\limits_{i=1}^{n}A_{i}\\right| = \\sum\\limits_{i=1}^{n}|A_{i}| - \\sum\\limits_{i=1}^{\\frac{n}{2}}|A_{2i+1}A_{2(i+1)}| + \\cdots (-1)^{n-1}\\left| \\bigcup_{i = 1}^{n}A_{i} \\right| \n\n\n"},"归档/大一下期末/高数复习":{"slug":"归档/大一下期末/高数复习","filePath":"归档/大一下期末/高数复习.md","title":"高数复习","links":["归档/大一下期末/高等数学/空间几何与解析几何","归档/大一下期末/高等数学/多元函数微分","归档/大一下期末/高等数学/重积分","归档/大一下期末/高等数学/曲线积分","归档/大一下期末/高等数学/无穷级数","归档/大一下期末/高等数学/微分方程"],"tags":[],"content":"Transclude of 空间几何与解析几何\n\nTransclude of 多元函数微分\n\nTransclude of 重积分\n\nTransclude of 曲线积分\n\nTransclude of 无穷级数\n\nTransclude of 微分方程"},"归档/大一下期末/高等数学/多元函数微分":{"slug":"归档/大一下期末/高等数学/多元函数微分","filePath":"归档/大一下期末/高等数学/多元函数微分.md","title":"多元函数微分","links":[],"tags":[],"content":"偏导数与全微分\n\n基本求偏导数\n\n \\frac{\\partial F(x,y)}{\\partial x} = \\mathrm{d}F_{x}\n即:将y看作常数对F中的x求导\n同理,对y求偏导就是将x看为常数\n\n\n复合函数求导\n\n链式法则\n可以画出z(u,v),u(x,y),v(x,y)中\\frac{\\partial z}{\\partial x},\\frac{\\partial z}{\\partial y}的变量依赖关系的关系图\n也可以直接写出\\frac{\\partial{z}}{\\partial{x}} = \\frac{\\partial{z}}{\\partial{u}} \\frac{\\partial{u}}{\\partial{x}} + \\frac{\\partial{z}}{\\partial{v}} \\frac{\\partial{v}}{\\partial{x}} 对\\frac{\\partial{z}}{\\partial{y}}也是一样的\n\n\n隐函数求导\n\n对隐函数F(x,y,z)有\n\\frac{\\partial{z}}{\\partial{x}} = - \\frac{F_{x}}{F_{z}}\n\\frac{\\partial{z}}{\\partial{y}} = -\\frac{F_{y}}{F_{z}}\n也可以两边同时对x或y求偏导\n\n\n全微分\n\n\\mathrm{d}z = \\left(\\frac{\\partial{z}}{\\partial{x}}\\mathrm{d}x \\  + \\frac{\\partial{z}}{\\partial{y}}\\mathrm{d}y \\right)\n\n\n\n方向导数与梯度\n\n梯度\n\n梯度向量是就是求所有变量对原函数的偏导然后放入到向量中\n对\\nabla f而言f(x,y,z), \\nabla f = \\left(\\frac{\\partial{f}}{\\partial{x}},\\frac{\\partial{f}}{\\partial{y}},\\frac{\\partial{f}}{\\partial{z}}\\right)\n\\nabla f(P_{0}) = \\left(\\frac{\\partial{f}}{\\partial{x}}(P_{0}),\\frac{\\partial{f}}{\\partial{y}}(P_{0}),\\frac{\\partial{f}}{\\partial{z}}(P_{0})\\right)\n\n\n方向导数\n\n\\frac{\\partial{f}}{\\partial{l}} = \\nabla f(P_{0}) \\cdot \\frac{\\vec{u}}{|u|}\n方向导数最大(变化率最大)时候\n\n方向为：\\nabla f(P_{0})\n最大值：|\\nabla f(P_{0})|\n\n\n方向导数最小(变化率最小)时候\n\n方向为：-\\nabla f(P_{0})\n最小值：-|\\nabla f(P_{0})|\n\n\n变化为0时候\n\n方向为：任意与-\\nabla f(P_{0})垂直的向量\n\n\n\n\n\n极值与最值\n\n无条件极值f(x,y)\n\n解方程组 \\begin{cases} \\frac{\\partial{f}}{\\partial{x}} = 0 \\\\ \\frac{\\partial{f}}{\\partial{y}} = 0 \\end{cases}\n一般而言上面方程组会解出一个(或多个)点A(x_{0},y_{0}) 称为驻点\n接下来需要我们求所有二阶偏导数\n\nf_{xx} = \\frac{\\partial^{2}{f}}{\\partial{x^{2}}} \\quad f_{yy}= \\frac{\\partial^{2}{f}}{\\partial{y^{2}}}  \\quad f_{xy} = \\frac{\\partial^{2}{f}}{\\partial{x}\\partial{y}}\n接下来计算黑塞矩阵的行列式D = \\begin{pmatrix}f_{xx}(x,y)  &amp; f_{xy}(x,y) \\\\ f_{xy}(x,y)  &amp;  f_{yy}(x,y) \\end{pmatrix}\n\n\n将每个驻点带入D有D|_{xy}\n\n如果D|_{xy} &gt; 0 且 f_{xx}(x_{0},y_{0}) &gt; 0 则函数有局部最小值\n如果D|_{xy} &gt; 0 且 f_{xx}(x_{0},y_{0}) &lt; 0 则函数有局部最大值\n如果D|_{xy} \\leq 0 则没有局部最值\n\n\n\n\n有条件的极值\n\n已知f(x,y,z)在约束条件\\omega(x,y,z) = a的极值\n构造拉格朗日方程 F(x,y,z,\\lambda) = f(x,y,z) + \\lambda(\\ \\omega(x,y,z) - a\\ )\n求解方程组\\begin{cases} \\frac{\\partial{f}}{\\partial{x}} = 0 \\\\ \\frac{\\partial{f}}{\\partial{y}} = 0 \\\\ \\frac{\\partial{f}}{\\partial{z}}= 0 \\\\ \\frac{\\partial{f}}{\\partial{\\lambda}} = 0 \\end{cases} \n解出方程组中 x,y,z 就可以得到极值点\n\n\n"},"归档/大一下期末/高等数学/微分方程":{"slug":"归档/大一下期末/高等数学/微分方程","filePath":"归档/大一下期末/高等数学/微分方程.md","title":"微分方程","links":[],"tags":[],"content":"一阶微分方程\n\n可分离变量的一阶微分方程\n\n可以直接分离变量，将x,y移动到等式左右两侧对两侧积分就行\n\n例：y&#039; = \\frac{y}{x}\n有\\frac{1}{y}dy = \\frac{1}{x}dx\n\n\n\n\n可降阶的微分方程\n\ny^{(n)} = f(x)\n直接逐项积分就可以\n\n\n一阶齐次线性微分方程\n\n一般形式y&#039; = f\\left(\\frac{x}{y}\\right)\n思路：换元u = \\frac{x}{y}\n则有y = ux \\Longrightarrow y&#039; = u + u&#039;x\n将y和y&#039;带入原方程u + u&#039;x = f(u)\n\n按分离变量法求出u的表达式\n代回y = ux即可\n\n\n\n\n一阶非齐次线性方程\n\n一般形式：y&#039;+ P(x)y = Q(x)\n\n求积分因子\\mu(x) = e^{\\int P(x) dx}\n通项公式：y = \\frac{1}{\\mu(x)}\\left(\\int\\mu(x)Q(x) dx + C\\right)\n\n\n\n\n\n全微分方程\n\n全微分方程一般形式\nP(x,y)dx + Q(x,y)dy = 0\n当\\frac{\\partial{Q}}{\\partial{x}} = \\frac{\\partial{P}}{\\partial{x}}时候满足一个存在一个U(x，y)为解\n求解思路\n\n先对P(x,y)关于x积分有：U(x,y) = \\int P(x,y)\\ dx + h(y) \\qquad (1)\n对U(x,y)求关于y的偏导\\frac{\\partial{U}}{\\partial{y}} =\\frac{\\partial}{\\partial{y}}\\left(\\int P(x,y)dx\\right)+ h&#039;(y)\n因为对U求对y偏导后必须等于Q(x,y),z则我们可以比较出h&#039;(y)的表达式\n对h’(y)积分得出h(y)\n代回(1)式就可以得出方程\n\n\n\n高阶微分方程\n\n高阶齐次方程\n\na_{n}y^{(n)} + a_{n-1}y^{(n-1)} + \\cdots + a_{1}y^{(1)} + a_{0} = 0\n\n求解思路\n写出特征方程：a_{n}r^{n} + a_{n-1}r^{n-1} + \\cdots a_{0}r^{0} = 0\n求出所有r\n根据r的结构写出通解\nr都不相同时候y = C_1e^{r_{1}x}+ C_{2}e^{r_{2}x} + \\cdots C_{n}e^{r_{n}x}\n存在k重根r_p，对这个k重根有C_{1}e^{r_{p}x} + C_2xe^{r_{p}x} + \\cdots C_{k}x^{k-1}e^{r_{p}x}\n存在复数根，对这个复数根a+bi 有e^{ax}(C_{1}\\cos(bx) + C_{2}\\sin(bx))\n\n\n\n\n高阶常系数非齐次线性方程\n\n一般形式(考纲)：a_{n}y^{(n)} + a_{n-1}y^{(n-1)} + \\cdots + a_{1}y^{(1)} + a_{0} = f(x)且f(x) = e^{\\lambda x}P_m(x)\n解题思路\n\n通解形式为y = y_{p} + y_{h}其中y_{p}是其齐次方程的通解，y_{h}为一个特解\n我们主要考虑y_{h}\n我们推测y_{h}(x) = e^{\\lambda x}Q_m(x)\n\n注意如果\\lambda为特征方程的根，则需要修正y_{h}(x) = x^{k}e^{\\lambda x}Q_m(x)\n\n\n其中Q_{m}(x)是形如Ax^{n} + Bx^{n-1} + \\cdots + Nx^{0}的多项式\n对y_{h}(x)求导一直求到n阶导\n将y_{h}^{(n)} \\cdots y代入原式子与P_{m}(x)比较解出A \\cdots N的值\n代入y_{h}即可\n\n\n\n\n"},"归档/大一下期末/高等数学/无穷级数":{"slug":"归档/大一下期末/高等数学/无穷级数","filePath":"归档/大一下期末/高等数学/无穷级数.md","title":"无穷级数","links":[],"tags":[],"content":"\n无穷级数判别\n\n正项级数 \\sum\\limits a_{n},\\sum\\limits b_{n}\n\n比值判别法\n设L = \\lim_{x\\to\\infty} \\frac{a_{n+1}}{a_{n}}\n\n若0 &lt; L &lt; 1则级数收敛\n若L &gt; 1则发散\n若L = 1则失效\n\n\n比较判断法\n\n设L = \\lim_{x\\to\\infty} \\frac{a_{n}}{b_{n}}\n\n如果L为有限正数则\\sum\\limits a_{n}与\\sum\\limits b_n敛散性质相同\n如果L \\to \\infty 且\\sum\\limits b_{n}发散则\\sum\\limits a_{n}发散\n如果L = 0且\\sum\\limits b_n收敛，则\\sum\\limits a_n收敛\n\n\n\n\n\n\n交错级数\n\n一般形式\\sum\\limits (-1)^{n} a_{n}\n莱布尼茨判别法\n\n\\lim_{x \\to \\infty} a_{n} = 0\na_{n-1} &lt; a_{n}\n\n\n满足上面两个则级数为收敛的\n\n\n绝对收敛\n\n当\\sum\\limits |a_{n}|收敛，则级数绝对收敛\n\n\n\n\n幂级数收敛域\n\n用比值判别法\n\nR = \\lim_{n \\to \\infty}\\left|\\frac{a_{n}}{a_{n + 1}}\\right|\nR即为收敛半径(-R,R)\n将两个端点代入看能否取值\n\n\n根值判别法\n\nR = \\lim_{n \\to \\infty} \\sqrt[n]{|a_n|}\nr = \\frac{1}{R}即为收敛半径(-r,r)\n将两个端点代入看能否取值\n\n\n\n\n展开为幂级数\n\n利用五个已知的常用展开式\ne^{x}= \\sum\\limits_{n = 0}^{\\infty} \\frac{x^{n}}{n!}\n\\frac{1}{1 - x} = \\sum\\limits_{n = 1}^{\\infty} x^{n}\\qquad ,x \\in (-1,1)\n\\frac{1}{1 + x} = \\sum\\limits_{n = 1}^{\\infty} (-1)^{n}x^{n}\\qquad ,x \\in (-1,1)\n\\ln(1 + x) = \\sum\\limits_{n = 1}^{\\infty} (-1)^{n - 1}\\frac{x^{n}}{n}\n\n\n傅立叶级数展开\n\n有一个f(x)以2\\pi为周期\n和函数S(x_{0}),其中有间断点x_{k}\n\n当x_{0} \\ne x_{k} 时 S(x_{0}) = f(x)\n当x_{0}= x_{k} 时 S(x_{0}) = \\frac{f(x_{0^{+}}) + f(x_{0^{-}})}{2}\n\n\n展开式a_{0} = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)dx\n\n\n"},"归档/大一下期末/高等数学/曲线积分":{"slug":"归档/大一下期末/高等数学/曲线积分","filePath":"归档/大一下期末/高等数学/曲线积分.md","title":"曲线积分","links":[],"tags":[],"content":"\n第一类曲线积分(对弧长的积分)\n\n一般形式\\int_{L}f(x,y) \\ ds\n第一步：参数化曲线L\n\n在直角坐标系下\n\n对平面曲线f(x,y)通常可以表示为x(t),y(t)，t \\in [t_{1},t_{2}]\n\n\n在极坐标系下\n\n我们可以先使用极坐标转换将L转换为极坐标下的方程R(\\rho,\\theta)，然后表示为\\rho = \\rho(\\theta)的形式\n\n\n参数化主要是将x,y都用t来表示，比如y = x^{2} + e^{x} 就可以令x = t,则y(t) = t^{2} + e^{t} \\ ,\\ x(t) = t\n\n\n微分元素ds\n\n在直角坐标系下ds = \\sqrt{(x&#039;(t))^2 + (y&#039;(t))^{2}} \\, dt\n在极坐标系下ds = \\sqrt{\\rho^{2}(\\theta) + (\\rho&#039;(\\theta))^{2}}\n\n\n被积函数变化\n\n将f(x,y) \\to f(x(t)\\ ,\\ y(t))\n极坐标系 f(x,y) \\to f(\\rho(\\theta)\\cos\\theta\\ ,\\ \\rho(\\theta)\\sin\\theta)\n\n\n总公式\n\n直角坐标系下\\int_{L}f(x,y) \\ ds = \\int_{t_{1}}^{t_{2}} f(\\, x(t)\\ ,\\ y(t)\\, )\\sqrt{(x&#039;(t))^{2} + (y&#039;(t))^{2}}\\ dt\n极坐标系下\\int_{L}f(x,y)\\ ds = \\int_{\\theta_{1}}^{\\theta_{2}} f(\\rho(\\theta)\\cos\\theta,\\rho(\\theta)\\sin\\theta)\\sqrt{\\rho^{2}{(\\theta)} + (\\rho&#039;(\\theta))^{2}}\\ d\\theta\n\n\n\n\n第二类曲线积分(对坐标的积分)\n\n一般形式 \\int_{L}P(x,y)\\ dx + Q(x,y)\\ dy\n\n参数化\n\n对平面曲线f(x,y)通常可以表示为x(t),y(t)，t \\in [t_{1},t_{2}]\n\n\n微元dx,dy\n\ndx = x&#039;(t)dt\\ ,\\ dy = y&#039;(t)dt\n\n\n\n\n总公式\n\n\\int_{L}P(x,y)\\ dx + Q(x,y)\\ dy = \\int_{t_{1}}^{t_{2}} \\left[P(x(t),y(t))x&#039;(t) + Q(x(t),y(t))y&#039;(t)\\right] \\ dt\n\n\n\n\n格林公式\n\n如果曲线正向(逆时针)则可以使用格林公式\n\\int_{L}P(x,y)dx + Q(x,y)dy = \\iint_{D}(\\frac{\\partial{Q}}{\\partial{x}} - \\frac{\\partial{P}}{\\partial{y}})dxdy\n如果不是闭合曲线，我们可以“造”一个曲线使其闭合\n\n例：正向曲线L = \\sin x , \\ x\\in [0,\\pi]\n我们可以添加一条与L曲线方向相同的曲线y = 0,\\ x\\in [0,\\pi]\n此时有\\int_{L_{0}}P(x,y)dx + Q(x,y)dy = \\int_{L}P(x,y)dx + Q(x,y)dy + \\int_{l}P(x,0) dx\n而第一个式子我们可以就用格林公式了\n\n\n格林公式有”洞”的情况\n\n我们对外部的线积分I_{0}使用正常的格林公式积分\n对内部的线积分I_{1}我们必须保证其与外线方向相反的方向来保证使用格林公式的方向性\n此时我们计算的积分I = I_{0} + I_{1}但由于I_{1}是顺时针的，所以用格林公式时候会改变符号\n即I = I_{1}-I_{0}\n\n\n\n\n路径无关条件\n\n若一个曲线积分\\int_{L}P(x,y)dx + Q(x,y)dy与路径无关则有\n\\frac{\\partial{Q}}{\\partial{x}} = \\frac{\\partial{P}}{\\partial{y}}\n\n\n"},"归档/大一下期末/高等数学/空间几何与解析几何":{"slug":"归档/大一下期末/高等数学/空间几何与解析几何","filePath":"归档/大一下期末/高等数学/空间几何与解析几何.md","title":"空间几何与解析几何","links":["/"],"tags":[],"content":"向量运算\n\n点乘\n\n\\vec{a} \\cdot \\vec{b} = |a||b|cos&lt;\\vec{a},\\vec{b}&gt;\n若表示为坐标形式可以有:a_{1}\\cdot b_{1} + a_{2} \\cdot b_{2} + a_{3} \\cdot b_{3}\n如果两个 非零向量 点乘为0,说明这两个向量垂直\n点乘求出的是一个数\n\n\n叉乘(向量积)\n\n有 \\mathrm{a} \\times \\mathrm{b} = \\begin{pmatrix}i &amp;j &amp;k \\\\ a_{1}&amp;a_{2}&amp;a_{3} \\\\ b_{1} &amp; b_{2} &amp;b_{3} \\end{pmatrix}\n按第一行展开即可得出结果向量 (n_{i},n_{j},n_{k})\n或者使用高中叉乘法直接求出 (n_{i},n_{j},n_{k}) 数值\n\n\n求投影\n\n标量投影\n\n\\text{comp}_{\\mathrm{b}}\\rm{a} = \\frac{a \\cdot b}{|b|}\n有时候也写成 \\text{prj}_{\\vec{b}}\\vec{a}\n\n\n向量投影\n\n\\text{proj}_{\\vec{b}}\\vec{a} = \\left(\\frac{a\\cdot b}{|b|^{2}}\\right)\\,b\n\\text{proj}_{\\vec{b}}\\vec{a} = \\left(\\frac{a\\cdot b}{|b|}\\right)\\, \\frac{b}{|b|}\n\n\n\n\n\n\n平面与直线方程\n\n求平面方程(点法式)\n\n平面方程一般形式\n\n点法式 ： A(x - x_{0}) + B(y - y_{0)}+ C(z - z_{0})\n\n(A,B,C)为平面法向量\n(x_{0},y_{0},z_{0})是平面上一个点\n\n\n\n\n求过三点的平面P_{1},P_{2},P_{3}\n\n构造不共线的两个向量：P_{1}P_{2} = (x_{2}-x_{1},y_{2}-y_{1},z_{2}-z_{1}) P_{2}P_{3} = (x_{3}-x_{2},y_{3}-y_{2},z_{3}-z_{2})\n计算法向量 \\vec{n} = P_{1}P_{2} \\cdot P_{2}P_{3}\n带入点法式\n\n\n求过某一点且垂直于某直线的平面\n\n垂直与直线 → 法向量与直线方向向量平行 → 法向量就是方向向量\n带入点法式\n\n\n求过一点且垂直于两平面的平面\n\n垂直两平面，可以找到两平面的法向量n_{1},n_{2}\n所求平面法向量就是 n = n_{1}\\times n_{2}\n带入点法式\n\n\n\n\n求直线方程\n\n直线方程一般形式\n\n对称式 \\frac{x-x_{0}}{A} = \\frac{y-y_{0}}{B} = \\frac{z - z_{0}}{C}\n\n(A,B,C)为直线方向向量\n(x_{0},y_{0},z_{0})为直线所过的一个点\n\n\n参数式：\\begin{cases} x = At + x_{0} \\\\ y=Bt+y_{0} \\\\ z=Ct+z_{0} \\end{cases}\n可以理解为\\frac{x-x_{0}}{A} = \\frac{y-y_{0}}{B} = \\frac{z - z_{0}}{C} = t 后拆开的三个式子,那互相转换也显而易见了\n\n\n过点两点的直线\n\nA = (x_{1},y_{1},z_{1})\\, , \\, B = (x_{2},y_{2},z_{2})\n求两直线方向向量 \\vec{n} = \\overrightarrow{AB}\n带入某一个点使用对称式\n\n\n求已知两平面的交线\n\n可以找到两平面的法向量n_{1},n_{2}\n直线方向向量 \\vec{n} = n_{1} \\times n_{2}\n联立两个平面\n令x = 0(或y = 0等手段)找出y，z\n则这个直线过(0,y,z)\n带入对称式\n\n\n\n\n求曲线的切线与法平面 ^2c491e\n\n已知曲面\\Omega(x,y,z) =  x(t),y(t),z(t),求在(x_{0},y_{0},z_{0})处的切线方程(法平面)\n\n令x(t) = x_{0}求出t_{0}\n求x&#039;(t_{0}),y&#039;(t_{0}),z&#039;(t_{0}),即切线方向向量(法向量)\n代回(x_{0},y_{0},z_{0})用对称式得出结果\n或用点法式求出法平面\n\n\n\n\n"},"归档/大一下期末/高等数学/重积分":{"slug":"归档/大一下期末/高等数学/重积分","filePath":"归档/大一下期末/高等数学/重积分.md","title":"重积分","links":[],"tags":[],"content":"二重积分\n\n直角坐标\n\n其重点在于将积分区域表示出来\n例：计算二重积分\\iint_D xy \\, dx\\,dy，其中D由直线y = 2,x = 2,y = 2x围成的有界闭区域。\n对积分区域D有\n此时我们可以将其看为x型(先y后x)的积分\n\\iint_Dxy\\,\\mathrm{d}x\\mathrm{d}y = \\int_{1}^{2}\\mathrm{d}x\\int_{2}^{2x}xy\\mathrm{d}y\n在积后一个积分的时候就将x看为常量对y积分即可\n\n\n极坐标\n\n利用极坐标变换：\\begin{cases} x = \\rho\\cos\\theta \\\\ y = \\rho\\sin\\theta \\end{cases}\n当被积函数中含有 x^{2} + y^{2} 这类式子时候或者积分区域是圆类时候可以使用极坐标变换\n极坐标变换注意\\mathrm{d}x\\mathrm{d}y要变为\\rho\\ \\mathrm{d}\\rho\\mathrm{d}\\theta\n设区域D: x^2 + y^2 \\leq 1，则积分\\iint_D (xy + 3)^2 \\, d\\sigma =\n\n利用极坐标变换有\n\\iint_{D}(\\rho^{2}\\cos\\theta\\sin\\theta + 3)^{2}\\rho\\ \\mathrm{d}\\rho\\mathrm{d}\\theta\n在圆中 \\theta \\in [0,2\\pi]\\quad \\rho \\in [0,r] r是圆半径\n有\\int_{0}^{1} d\\rho\\int_{0}^{2\\pi}(\\rho^{2}\\cos\\theta\\sin\\theta + 3)^{2}\\rho\\ \\mathrm{d}\\theta\nBYD好难算放弃了\n\n\n\n\n二重积分中值定理\n\n存在(x_{0},y_{0})\\in D有\\iint_Df(x,y)dxdy = f(x_{0},y_{0})\\cdot S\n其中S为D的面积\n\n\n对称性\n\n二重积分区域D如果关于某一个变量轴对称，若其被积函数关于另一个变量为奇函数，则二重积分为0\n\n例：积分关于x轴对称，且f(x,-y) = -f(x,y)则该积分为0\n\n\n如果为偶函数，则只需要计算一半的区域然后乘2,即2\\iint_{D^*}f(x,y)dxdy\n\n\n\n三重积分\n\n三重积分方法\n\n直角坐标计算法：先一后二与先二后一\n\n先一后二：即先计算一重积分，再计算二重积分\n常见形式 ：z = x^{2} + y^ {2} 与 z = a围的空间封闭区域\n\n将\\iiint_{\\Omega}f(x,y,z)\\ dxdydz 化为\\iint_{D}\\ dxdy\\int_{x^{2}+ y^{2}}^{a}f(x,y,z)\\ dz\nD为空间体在xOy平面上的投影\n\n\n先二后一：即先计算二重积分，再计算一重积分\n\n常见形式：当被积函数只有一个变量的时候，可以考虑后积这个变量。这样就可以化为：\n\\int_{z_{0}}^{z_{1}}f(z)\\ dz\\iint_{D}\\ dxdy =\\int_{z_{0}}^{z_{1}}f(z)\\cdot A \\ dz\n其中A一般是一个可以用z表示的沿着z变化的面积\n如上例：若f(x,y,z) = z ，则我们可以化为：\\int_{0}^{a} z \\cdot (\\pi z)\\ dz\n\n\n\n\n球面坐标法\n\n球面坐标转换：\n\\begin{cases} x = \\rho\\sin\\phi\\cos\\theta \\\\ y = \\rho\\sin\\phi\\sin\\theta \\\\ z = \\rho\\cos\\phi \\end{cases}\n微元变化：\\mathrm{d}V = \\rho^{2}\\sin\\phi\\ \\mathrm{d}\\phi\\mathrm{d}\\rho\\mathrm{d}\\theta\n\\rho的范围:从原点出发的射线穿过区域的起点和终点对应的\\rho值\n\n对于球体，通常是0到半径R;对于球壳，是内半径到外半径\n\n\n\\phi的范围:从正z轴开始，向下扫描区域所需的角度范围\n\\theta的范围:在xOy平面上投影区域所覆盖的水平角度范围\n\n\n三重积分对称性\n\n三重积分区域D如果关于某两个变量平面对称(如xOy)，若其被积函数关于另一个变量为奇函数(f(x,y,-z) = -f(x,y,z))，则三重积分为0\n\n\n\n\n"},"杂项/正则表达式":{"slug":"杂项/正则表达式","filePath":"杂项/正则表达式.md","title":"正则表达式","links":[],"tags":[],"content":""},"杂项/短路运算符":{"slug":"杂项/短路运算符","filePath":"杂项/短路运算符.md","title":"短路运算符","links":[],"tags":[],"content":"我们可以这样理解短路运算符\n\n短路运算符一般是用于判断的二元运算符\n当二元运算符的前项可以直接决定整个表达式的结果时候，二元运算符就会直接忽略后项\n\n// 在c++中， &amp;&amp; || 是短路运算符\nint check = 0;\nif( 0 &amp;&amp; check++ )\n{\n\t//code\n}\ncout &lt;&lt; check &lt;&lt; &#039; &#039;;\n这时候 check 的输出会是 0\n// 对 || 而言\nint check = 1;\nif( 1 || check-- )\n{\n\t// code\n}\ncout &lt;&lt; check &lt;&lt; &#039; &#039;;\n这时候 check 的输出会是 1"}}