{"ACM/奇妙C++用法/C++模板":{"slug":"ACM/奇妙C++用法/C++模板","filePath":"ACM/奇妙C++用法/C++模板.md","title":"C++模板","links":[],"tags":[],"content":"C++模板是一个强大的通用性工具,其用法为template &lt;typename T&gt;\n这个语法允许我们传入非固定的类型并且根据这个类型进行程序编写\nC++模板分为两种模板: 函数模板 和 类模板\n函数模板\n你定义一个通用的函数，其中一个或多个参数的类型是泛型（用一个占位符表示），而不是固定的类型，例如int或double。当你在代码中调用这个函数时，编译器会根据你传入的参数类型自动推断并实例化（instantiate）出一个具体的函数版本。\ntemplate&lt;typename T&gt; \nvoid swapT(T &amp;a, T &amp;b){\n\tT temp;\n\ttemp = a;\n\tb = a;\n\ta = temp;\n}\n类模板\n和函数模板类似,在 class 前声明模板就可以传入特定的类型,同时也可以使用template&lt;typename T1,typename T2 ...&gt; 来声明多个类型,在调用类的时候就需要输入多个类型\ntemplate &lt;typename T1, typename T2, typename T3&gt;\nclass ppair\n{\nprivate:\npublic:\n    T1 _first;\n    T2 _second;\n    T3 _third;\n    ppair(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)\n    {\n        _first = a;\n        _second = b;\n        _third = c;\n    }\n};\n\n上面就是一个简单的三元组实现\n"},"ACM/奇妙C++用法/现代C++之function":{"slug":"ACM/奇妙C++用法/现代C++之function","filePath":"ACM/奇妙C++用法/现代C++之function.md","title":"现代C++之function","links":["tags/语法"],"tags":["语法"],"content":"语法\nC++11 提供 std::function 这样一个函数包装式来封装函数\n\n基本语法：\n\nfunction&lt;返回值(传参)&gt;\n示例： function&lt;int(int,int)&gt; func\n\n\n利用function包装函数：\n\nvoid add(int a,int b){\n\treturn a+b;\n}\n \nint main()\n{\n\tstd::function&lt;int(int,int)&gt; fun = add;\n\tint res = fun(3,4);\n\t// 此时res输出 7\n}\n你同样也可以使用 function包装一个lambda表达式 为什么不直接使用lambda\nint main()\n{\n\tauto lamb = [&amp;](int a,int b){\n\treturn a+b;\n\t}\n\tstd::function&lt;int(int,int)&gt; fun1 = lamb;\n\t//上式等价于下式\n\tstd::function&lt;int(int,int)&gt; fun2 = [&amp;](int a,int b)-&gt; int{\n\t\treturn a+b;\n\t};\n}"},"ACM/奇妙C++用法/语句表达式":{"slug":"ACM/奇妙C++用法/语句表达式","filePath":"ACM/奇妙C++用法/语句表达式.md","title":"语句表达式","links":[],"tags":[],"content":"我们注意一段神奇代码\nauto a = ({\n        int p = 10, q = 20;\n        p + q;\n    });\n这其实是GUN扩展下的cpp语句扩展表达式\n其等价于:\nauto a = []{\n\tint p = 10,q = 20;\n\treturn p + q;\n}();\n可以在我们想要快速初始化的时候可以使用"},"ACM/算法/BFS-广度优先搜索":{"slug":"ACM/算法/BFS-广度优先搜索","filePath":"ACM/算法/BFS 广度优先搜索.md","title":"BFS 广度优先搜索","links":["tags/搜索","tags/递归与递推","ACM/算法/深度优先搜索-DFS","编程语言/C++/STL/Queue-队列"],"tags":["搜索","递归与递推"],"content":"搜索 递归与递推\nBFS 广度优先搜索\n\n\n在前面我们介绍过深度优先搜索 DFS，深搜的核心思想是一条路走到底，直到得到符合的结果或者超出边界情况结束\n\n\n而广度优先搜索则是从起始位置出发，每一次向外增加一圈，或执行完一大个操作之后再将计数变量增加\n\n\n广搜一般适用于求最短路径，求最少操作次数的这些操作，因为广搜本身便是向外扩散式的一种搜索\n\n\n广搜一般使用STL中的Queue 队列作为承接模板，通过其先进先出的特点实现广搜\n例题：洛谷P1135 奇怪的电梯\nsigned main()\n{\n    int n, a, b;\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    vector&lt;int&gt; to,path;\n    to = vector&lt;int&gt;(n + 1);\n    path = vector&lt;int&gt;(n + 1, -1);\n    for (size_t i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; to[i];\n    }\n    // 输入数据\n    queue&lt;int&gt; bfs; //建立一个bfs的queue队列\n    int ans = 0;\n    bfs.push(a); //将第一个元素存入队列中\n    path[a] = 0; //第一个路径初始\n    while (!bfs.empty()) { //如果队列非空，就说明仍然有可以进行下去的操作\n        int up = bfs.front() + to[bfs.front()]; //第一种可能，往上坐电梯\n        int down = bfs.front() - to[bfs.front()]; //第二种可能，往下坐电梯\n        if (up &gt; 0 &amp;&amp; up &lt;= n &amp;&amp; path[up] == -1) { //如果往上做的电梯能到达(即存在这个楼层)，且这个楼层没有被达到过\n            path[up] = path[bfs.front()] + 1; // 这个楼层的标识数 = 过来的楼层的标识数 + 1\n            bfs.push(up); //把这个楼层加入到队列里，表示接下来会对这个楼层操作\n        }\n        if (down &gt; 0 &amp;&amp; down &lt;= n &amp;&amp; path[down] == -1) { //同上\n            path[down] = path[bfs.front()] + 1;\n            bfs.push(down);\n        }\n        bfs.pop(); //原始楼层操作完毕，弹出队列\n    }\n    cout &lt;&lt; path[b]; //输出目标楼层的情况\n    return 0;\n}\n\n显然，BFS对这种求最短是一个不错的解法，但有的时候还得考虑DP或其他时间复杂度更低的方法\n"},"ACM/算法/Boyer-Moore-投票算法":{"slug":"ACM/算法/Boyer-Moore-投票算法","filePath":"ACM/算法/Boyer-Moore 投票算法.md","title":"Boyer-Moore 投票算法","links":["tags/模拟","tags/模板"],"tags":["模拟","模板"],"content":"模拟 模板\nBoyer-Moore 投票算法\n\n背景：数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素，若不存在，输出 -1\n\n\n\n一般我们习惯想到的方法是利用unordered_map 来存储每个数出现的次数，当发现有数字超过一半的时候，输出该数字，没有则在最后输出 -1\n\n\n上述方法时间复杂度和空间复杂度均为 O(n) ,而接下来介绍的算法，可以让空间复杂度降低到 O(1)\n\n\nBoyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等\n\n如果数组为空，则数组不存在主要元素\n如果数组剩下元素，则该元素可能为主要元素\n\n\n\n主要步骤：\n\n\n维护一个候选主要元素 candidate 和该元素出现次数 count ,初始时 candidate 可以为任意值，count = 0\n\n\n遍历数组 nums 的所有元素，遍历到元素 a_i 时进行如下操作：\n\n\n如果 count = 0 ,则将 a_i 的值赋给 candidate ；否则不更新 candidate 的值\n\n\n如果 candidate = a_i ，则将 count++.否则 count- -\n\n\n遍历结束后,如果存在主要元素，则为 candidate ,否则其可以为数组中的任意元素\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n在 Boyer-Moore 投票算法中，遇到相同的数则将 count 加 1，遇到不同的数则将 count 减 1\n根据主要元素的定义，主要元素的出现次数大于其他元素的出现次数之和，因此在遍历过程中，主要元素和其他元素两两抵消，最后一定剩下至少一个主要元素，此时 candidate 为主要元素，且 count \\geq 1\n\n\n\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; nums(n);\n    int candidate = 0, counts = 0;\n    for (auto &amp;&amp;i : nums) {\n        cin &gt;&gt; i;\n        if (counts == 0) candidate = i;\n        if (candidate == i)\n            counts++;\n        else\n            counts--;\n    }\n    int res = 0;\n    for (auto &amp;&amp;i : nums) {\n        if (i == candidate) {\n            res++;\n        }\n    }\n    cout &lt;&lt; (res &gt; nums.size() / 2 ? candidate : -1);\n    return 0;\n}"},"ACM/算法/DP-动态规划/DP问题全记录":{"slug":"ACM/算法/DP-动态规划/DP问题全记录","filePath":"ACM/算法/DP 动态规划/DP问题全记录.md","title":"DP问题全记录","links":[],"tags":[],"content":"Q1 CF2135A\n\n我们定义一个块(block)为其中所有元素都等于数组长度的数组。例如，[3,3,3]、[1] 和 [4,4,4,4] 都是块，而 [1,1,1] 和 [2,3,3] 则不是。\n若一个数组可以通过任意数量(可能为零)的块连接而成，则称其为整洁数组(neat array)。注意空数组总是整洁的。\n给定一个由 n 个整数组成的数组 a，请找出其最长的整洁子序列∗的长度。\n∗序列 c 是序列 a 的子序列，当且仅当 c 可以通过从 a 的任意位置删除若干个(可能为零或全部)元素得到。\n\nAc代码\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vint a(n + 1);\n    for (size_t i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];\n    }\n    // dp[i] 表示idx = i 时候前面可构造序列的最长长度\n    // 初始化？ 显然都为 0\n    // 转移方程？\n    // 可以选择是否加入dp[i]\n    // 如果不加入dp[i] , 则有 dp[i] = dp[i - 1]\n    // 如果选择加入 dp[i]\n    // 这意味着我们必须从当前位置向前找到计数数目减去a[i]的元素然后用其坐标x下的dp[x] + a[i] 来更新dp[i]\n    // 什么时候可以将a[i]加入dp？即当计数数目等于a[i]时候\n    vint dp(n + 1, 0);\n    map&lt;int, deque&lt;int&gt;&gt; re;\n    // re[a[i]] 为 元素 a[i] 下标构成的集合\n    for (size_t i = 1; i &lt;= n; i++) {\n        dp[i] = dp[i - 1];\n        re[a[i]].emplace_back(i);\n        if (re[a[i]].size() &gt; a[i]) {\n            re[a[i]].pop_front();\n        }\n        if (re[a[i]].size() == a[i]) {\n            dp[i] = max(dp[i], dp[re[a[i]].front() - 1] + a[i]);\n        }\n    }\n    cout &lt;&lt; dp[n] &lt;&lt; endl;\n}\nProblem - 2134D \n\n\n                  \n                  Background \n                  \n                \n\n\n若存在一种将每个下标 i 染成红色或蓝色的方式，使得对于所有满足 b_i &gt; b_j 的下标对 i  &lt;  j，i 和 j 被分配的颜色均不同，则称序列 b_1, b_2, \\ldots, b_k 是好的\n给定序列 a_1, a_2, \\ldots, a_n。计算该序列中所有好的子序列的数量(包括空子序列^{\\text{∗}})。由于答案可能非常大，请输出其对 10^9 + 7 取模的结果。\n^{\\text{∗}}若序列 b 可通过从序列 a 中任意位置删除零个或多个元素得到，则称 b 是 a 的子序列。\n\n\n\n显然，对于题目所描述的”良好”实际上是要求我们寻找最长递减子序列(LDS)不超过 2 的所有子序列\n那我们的需求就是统计所有LDS不超过2的子序列，对于统计子序列的问题，我们可以使用动态规划(dp)的思路来解决\n具体来说，就是对于当前元素，我们可以选择两种方式加入dp中，具体而言，就是：“选择当前元素i”,“不选当前元素”\n那么接下来我们还有一个问题，就是如何在线性时间下统计当前元素的LDS？\n我们可以为每一个元素统计一个前缀最大值和左侧存在最大值的一个前缀值最大mp，当有元素低于前缀值的时候，我们就可以认为这个这个序列LDS &gt; 2\n\n对于mp，你可以认为将前缀所有LDS = 2的那个元素拉出来取最大\n\n对于状态转移方程，我们可以这样定义dp\ndp[i][m][mp]为前i个元素中选择的子序列的个数，最大的元素m以及我们规定的元素mp\n\n如果不选择元素i\n\n从dp[i][m][mp] = dp[i-1][m][mp]\n\n\n如果选择元素i\n\ndp[i][ai][mp] = dp[i - 1][m][mp] (a_{i} &gt; m)\ndp[i][m][ai]  = dp[i - 1][m][mp]  (mp \\leq a_{i} &lt; m)\n\n\n\nAC solution\nvoid solve()\n{\n    i64 n;\n    cin &gt;&gt; n;\n    vint a(n + 1, 0), b(n + 1, 0);\n    for (i64 i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (i64 i = 1; i &lt;= n; i++) {\n        b[i] = 1;\n        for (i64 j = i + 1; j &lt;= n; j++) {\n            if (a[i] &gt; a[j]) b[i]++;\n        }\n        for (i64 j = 1; j &lt; i; j++) {\n            if (a[i] &gt;= a[j]) b[i]++;\n        }\n    }\n    // 每一个单独的子序列都是一个结果，其为1\n    // dp[i][m][mp]表示前i个元素中选择的子序列的数目，最大的元素m以及我们规定的LDS = 2的最大值mp\n    vector&lt;vector&lt;vector&lt;i64&gt;&gt;&gt; dp(2, vvint(n + 1, vint(n + 1, 0)));\n    dp[0][0][0] = 1;\n    i64 cr = 0;\n    for (i64 i = 1; i &lt;= n; i++) {\n        i64 x = b[i];\n        cr ^= 1;\n        for (i64 j = 0; j &lt;= n; j++) {\n            for (i64 k = 0; k &lt;= n; k++) {\n                dp[cr][j][k] = dp[cr ^ 1][j][k];\n            }\n        }\n        for (i64 j = 0; j &lt;= n; j++) {\n            for (i64 k = 0; k &lt;= j; k++) {\n                // 如果前一个为0\n                if (dp[cr ^ 1][j][k] == 0) continue;\n                // a[i] &gt; max\n                if (j &gt; x &amp;&amp; x &gt; k) dp[cr][j][x] = (dp[cr][j][x] + dp[cr ^ 1][j][k]) % MOD;\n                // a[i] &lt; max ，a[i] &gt; mp\n                if (x &gt; j) dp[cr][x][k] = (dp[cr][x][k] + dp[cr ^ 1][j][k]) % MOD;\n            }\n        }\n    }\n    i64 ans = 0;\n    for (i64 i = 0; i &lt;= n; i++) {\n        for (i64 j = 0; j &lt;= n; j++) {\n            ans = (ans + dp[cr][i][j]) % MOD;\n        }\n    }\n    cout &lt;&lt; ans % MOD &lt;&lt; endl;\n}\n1057-D\n![[题解I#[1057-D](https //codeforces.com/contest/2153/problem/D)]]"},"ACM/算法/DP-动态规划/区间DP":{"slug":"ACM/算法/DP-动态规划/区间DP","filePath":"ACM/算法/DP 动态规划/区间DP.md","title":"区间DP","links":[],"tags":[],"content":"引入\n\n给定一堆长度为 n 的石子，每个石子有其重量 a_i ,你需要做的是不断的合并相邻石子，每次合并i,j两堆石子需要付出 a_i + a_j的代价，你必须不断合并直到所有石子均被合并完成。你需要知道你付出的最小代价是多少\n\n特点\n\n区间dp的特点我们一般认为有以下\n\n在某一个序列上的一个区间进行操作,如(合并)\n可以利用子区间的最优解来构造全局的最优解\n\n\n\ndp含义以及状态转移\n状态定义：\n\n区间状态，我们定义dp[\\,i \\,][\\,j\\,]表示从位置 i 到位置 j 的最优解(最小代价，最大收益等)\n对于每一个 dp[\\,i\\,][\\,j\\,] 我们都应该保证其状态能从子区间转移而来\n\n状态转移：\n\n区间划分：为了计算dp[\\,i\\,][\\,j\\,],我们往往需要一个中间值 k \\in [\\,i,j\\,)\n\nk将区间[\\,i,j\\,]划分为两个区间 [\\,i,k\\,] 和 [\\,k+1,j\\,]\n我们通过合并这两个子区间的代价来进行选择\n为了能够知道所有状态的最优解,k应该遍历[\\,i,j\\,)\n\n\n递推式\n\ndp[\\,i\\,][\\,j\\,] = \\underset{i\\le k &lt; j }\\min{\\{dp[\\,i\\,][\\,k\\,] + dp[\\,k+1\\,][\\,i\\,] + \\mathrm{cost}(i,k,j)\\}}\n\n其中 \\mathrm{cost}{(i,j,k)} 为合并两个子区间所产生的代价\n\ndp计算思路\n\n一般区间dp有三层for循环，第一层枚举长度 len ,第二次找区间起始点 i ，第三层遍历所有中间点 k\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n区间dp的复杂度为 O(n^3)\n\n\n\n一般模板代码\n我们以引入问题为例进行分析\nvector&lt;vector&lt;int&gt;&gt; dp(N,vector&lt;int&gt;(N));\n// 我们认为序列长度有n\nfor(int i = 1 ; i &lt;= n ; i++)｛\n\tdp[i][i] = 0;\n｝\n// 预处理,根据题目含义做出预处理数组(前缀和，或合并代价)(此处为合并石子，即石子的前缀和，用于计算区间代价)\nvector&lt;int&gt; vv(N);\nfor(int i = 1; i &lt;= n; i++) {\n\tvv[i] = vv[i-1] + v[i];\n}\n \n//进行区间dp，枚举所有长度n\nfor(int len = 2;len &lt;= n; len++){            //第一层，枚举长度\n\tfor(int i = 1; i + len - 1 &lt;= n; i++){   //第二层，枚举起点\n\t\tint j = i + len - 1;                 //计算终点\n\t\tdp[i][j] = INT_MAX;                 \n\t\tfor(int k = i; k &lt; j ;k++{\n\t\t\tdp[i][j] = min(dp[i][j],dp[i][k] + dp[k+1][j] + (vv[j] - vv[i-1]);       // 区间dp转移，遍历所有中间节点，取最小值\n\t\t}\n\t}\n}\n \ncout &lt;&lt; dp[1][n];         //答案即为从1-n的区间最优解\n "},"ACM/算法/DP-动态规划/数位DP":{"slug":"ACM/算法/DP-动态规划/数位DP","filePath":"ACM/算法/DP 动态规划/数位DP.md","title":"数位DP","links":[],"tags":[],"content":"数位DP的性质在于，给定一个数字区间[L,R]关注L到R之间的数位上的特点并计数(计算)\n数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减，即 ans = ans_{[0,R]} - ans_{[0,L - 1]}\n一般而言数位DP都会和记忆化搜索联系在一起，我们会设置两个传入参数来确定递归模式，islimit表示当前是否为上限，ispre 代表是否为前导零"},"ACM/算法/DP-动态规划/背包DP":{"slug":"ACM/算法/DP-动态规划/背包DP","filePath":"ACM/算法/DP 动态规划/背包DP.md","title":"背包DP","links":["tags/背包问题","tags/动态规划"],"tags":["背包问题","动态规划"],"content":"背包问题 动态规划\n背包DP\n\n两个特点：\n\n\n一个物体有 大小 + 价值\n有一个背包只能容纳某一个特定大小\n\n\n\n要求：找最大价值\n\n\n一般性转移方程——&gt; 设背包大小为 N,有 Y 个物品 , 物品价值为 val_i 物品大小为 size_j\n\n\n设dp[i][j] 表示任取 0\\to i 个物品在j时间下取得的\\sum a_k的最大值\n\n\n初始化见下：\n\n\nvector&lt;vector&lt;int&gt;&gt; dp(Y,vector&lt;int&gt;(N+1,0)); \n//对[0]行的初始\nfor (size_t i = size[0]; i &lt;= N; i++) {\n    dp[0][i] = val[0];\n}\n//对[0]列的初始\n//在背包初始大小为0的情况，只有 size = 0 的物品可以被装下\nfor(size_t j = 0; j &lt;= Y ; j++){\n    dp[i][0] = 0;\n}\n\n\n现在我们来推递推方程：\n\n\n对于一个 dp[i][j] 而言表示的是在 j 背包大小下取得 前i个val 的最大值\n\n\n从 dp[i-1][j] 到 dp[i][j] 有两种情况\n\nj &lt; size_i  =⇒   dp[i][j] = dp[i-1][j] 即当前容量装不下 size_i这个物品，只能与前一个的价值相同 = ⇒ 即增加的val = 0\nj &gt; size_i ：\n装 size_i :  dp[i][j] = dp[i][j - size[i]]+val[i]   .1\n不装size_i:   dp[i][j] = dp[i-1][j]\n\n\n\n对 .1 的解释： 选择装下大小为 size_i 价值为 val_i 的物品，那对dp从[i-1][j] 到的 [i][j] 而言:\n\ni 表示选取的范围 那显然 i-1 \\to i\nj 表示背包容量大小 ： 既然我们选取了这个物品 i , 那我们就看对于没有该物品时候的背包大小所表示的价值 + 这个物品 i 的价值即：j\\to j-size_i\ndp[i][j]本质是最大价值，则我们需要加上所选物品的价值 即： dp[i][j-size[i]] + val[i]\n\n\n\n在选择 j &gt; size_i 的两种情况下选择较大的一方表示最大价值\n\n\n即完整递推表达式为：\n\n\ndp[i][j] =\n\\left\\{\n\\begin{aligned}\n&amp;dp[i-1][j] &amp; j &lt; size[i] \\\\\n&amp;\\max(dp[i-1][j],dp[i][j-size[i]]+val[i]) &amp; j \\geq size{[i]} \\\\\n\\end{aligned}\n\\right.\n代码表示见下\nfor (size_t i = 1; i &lt; m; i++) {\n    for (size_t j = 1; j &lt;= t; j++) {\n        if (j &lt; size[i])\n            dp[i][j] = dp[i - 1][j];\n        else\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - size[i]] + val[i]);\n    }\n}"},"ACM/算法/Ranges库":{"slug":"ACM/算法/Ranges库","filePath":"ACM/算法/Ranges库.md","title":"Ranges库","links":["tags/语法"],"tags":["语法"],"content":"语法\n\nrange::find(v,‘1’);\n\n在容器 v 内查找传入的第二个参数，返回值是第一个找到的参数的迭代器，如果没找到，则返回v.end()\n\n\nrange::minmax(v)\n\n以一个pair形式返回容器中的最大值和最小值\n\n\n\n\t//常用接收形式\n\tauto [s1,s2] = ranges::minmax(v)\n\nranges::max_element(v)\n\n如果不进行二次传参，则返回范围内最大的一个元素的迭代器\n如果进行二次传参，则可以创建一个映射关系，返回映射关系下最大的那个元素的迭代器，例如：\n\n\n\n\tvector&lt;string&gt; v = {&quot;12&quot;,&quot;12345&quot;,&quot;1234&quot;};\n    auto s1 = ranges::max_element(v,\n\t{},     //comp比较函数，一般默认即可 \n    [](const string &amp;s) { return s.size(); }); //自定义映射函数，一般使用lambda进行编写\n    cout &lt;&lt; *s1;\n\nranges::sort(v)\n\n与std::sort()用法几乎一致，但是ranges::sort()仅仅需要传入数组名即可排序\nranges::sort(v,comp,porj)\n\nporj：\n\nporj投影函数，旨在简化传入参数的复杂情况，它可以将元素映射为其他属性或值。\n若不传入proj，则会对元素本身进行排列\n例：ranges::sort(v, {}, string::size);\n在上面的例子中，v容器内的字符串被转换成为了string::size,sort对size进行排列\n传入的函数也可以是一个lambda形式的函数\nranges::sort(v, {}, [](const string &amp;s) { return s.size() % 3; });\n例2:\n\n\n\n\n\n\n\n\tstruct Person {\n\tstd::string name;\n\tint age;\n\t};\n\t\nint main() {\n\tstd::vector&lt;Person&gt; people = {{&quot;Alice&quot;, 30}, {&quot;Bob&quot;, 25}, {&quot;Charlie&quot;, 35}};\t\n\tstd::ranges::sort(people, {}, &amp;Person::age);  // 按 age 属性排序\n\tfor (const auto&amp; person : people) {\n\tstd::cout &lt;&lt; person.name &lt;&lt; &quot; &quot;;  // 输出: Bob Alice Charlie\n    }\n}\n\n在这个例子中调用了Person::age将容器内的元素转化为age进行比较\n\n\nviews::take / views::drop\n\n这是view命名空间下的函数，作用是取前n个(take) 去前n个(drop)\n语法规则：auto vi_1 = v | view::take(n)\n\n其中：v 是容器 ， n 是取的值， vi_1是一个视图\n视图可以采用范围for的迭代方式，如果要对视图进行操作，可以使用两种解决方案：\n\n使用.begin() + index操作视图\n使用 to&lt;vector&gt;操作\n\nvector&lt;int&gt; v = vw | ranges::to&lt;vector&gt;();\n\n\n\n\n\n\n\n\n\nint main()\n{\n\tvector&lt;int&gt; a = {1,2,3,4,5};\n\tauto a1 = a | views::take(2);\n\tfor(auto &amp;&amp; i : a1)\n\t{\n\t\tcout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\t}\n\t// 输出 1 2\n\tcout &lt;&lt; endl;\n\tauto a2 = a | views::drop(2);\n\tfor(auto &amp;&amp; i : a2)\n\t{\n\t\tcout &lt; i &lt;&lt; &quot; &quot;;\n\t}\n\t// 输出 3 4 5 6\n\tcout &lt;&lt; endl;\n\tauto vi = a2 | ranges::to&lt;vector&gt;();\n\tfor(auto &amp;&amp; i : a2)\n\t{\n\t\tcout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\t}\n\t//输出同 a2\n}"},"ACM/算法/Readme":{"slug":"ACM/算法/Readme","filePath":"ACM/算法/Readme.md","title":"Readme","links":[],"tags":[],"content":"如何优雅地食用这个 C++ 语法笔记仓库？\n\n确保你拥有 git 并掌握一定的git知识\n确保你使用的笔记软件是 obsidian\n确保你会使用github的基础功能\n\n\n准备工作完毕，现在开始食用吧\n同步更新使用如下\n\nfork这个仓库\n到你fork好的仓库里，用git克隆下来这个仓库\n用 obsidian 打开这个仓库如下的路径：\nD:\\Code film\\C++\\memo\\C++语法(新)\n定期用git同步fork的仓库即可\n\n\n非同步更新如下：\n\n\n使用git克隆这个仓库\ngit clone github.com/imicola/Questions-and-Impressions.git\n\n\n用 obsidian 打开这个仓库如下的路径：\nD:\\Code film\\C++\\memo\\C++语法(新)\n\n\n如果想获取更新，可以用以下方法：\n\n\n添加上游仓库\n首先需要在你的本地 Git 仓库中添加一个指向原始仓库的远程仓库链接。假设你已经克隆了仓库到本地，并且当前目录已经在仓库内。你可以通过以下命令添加：\ngit remote add upstream github.com/imicola/Questions-and-Impressions.git\n\n\n这样做之后，你就有了两个远程仓库：origin（指向你 fork 的仓库）和 upstream（指向原始仓库）。\n\n获取上游仓库的更新\n接下来，使用 git fetch 命令来获取上游仓库的所有更新，但不会自动合并或修改你当前的工作目录。\n\ngit fetch upstream\n\n\n切换到主分支\n确保你在你的主分支上（对于大多数仓库来说，这个分支叫做 main 或者 master）。如果没有在该分支上，请切换过去：\ngit checkout main  # 或者 git checkout master\n\n\n合并上游仓库的更新\n使用 git merge 命令将上游仓库的更新合并到你的本地主分支：\ngit merge upstream/main  # 如果主分支名为main；若为master则替换为upstream/master\n\n\n这一步会将上游仓库的最新更改合并到你的本地仓库中。\n通过定期重复步骤 2 到 4，你可以确保你的本地仓库与原始仓库保持同步。"},"ACM/算法/ST表":{"slug":"ACM/算法/ST表","filePath":"ACM/算法/ST表.md","title":"ST表","links":[],"tags":[],"content":"ST表,又称稀疏表,通过采取预处理的方案储存不同长度的区间答案,从而在查询时候非常高效\nST表一般用于解决区间最值,可重复贡献的问题\n使用ST表需要注意以下问题:\n\n静态区间查询\n运算必须满足 结合律 和 幂等律\n常见问题有:\n\n区间最大最小值\n区间GCD\n区间按位与,按位或\n\n\n\n\n\n                  \n                  基本思路 \n                  \n                \n\n\nST表的基本思路是 倍增法\n假设我们有一个长度为n的数组a[0…n-1],我们预处理一个二维数组 st[i][j]\nst[i][j]表示从 i 开始,长度为 2^j 的区间答案\n预处理\n\n初始化 st[i][0] = a[i]\n状态转移:\nst[i][j] = f(s[i][j - 1],st[i+2^{j-1}][j-1])\n即将长度为 2^j的区间拆成两个长度2^{j - 1}的区间\n\n查询\n\n对于区间[L,R]:\n\n令 k = floor(log_2(R-L+1))\n有 ans = f(st[L][k],st[R-(1 &lt;&lt; k)+1][k]\n对于log我们可以预处理log表\n\n\n下图展示了ST表倍增的过程\n\n\n\n\n\n这里给一份参考代码\nstruct ST\n{\n    int maxn;\n    vector&lt;i64&gt; logtab;\n    vector&lt;vector&lt;i64&gt;&gt; st;\n    ST(int maxk)\n    {\n        maxn = maxk;\n    }\n    void pre(const vector&lt;i64&gt; &amp;a)\n    {\n        // 预处理log表\n        logtab.resize(maxn + 1);\n        int K = __lg(maxn) + 1;\n        st = vector&lt;vector&lt;i64&gt;&gt;(maxn, vector&lt;i64&gt;(K));\n        logtab[1] = 0;\n        for (i64 i = 2; i &lt;= maxn; i++) {\n            logtab[i] = logtab[i / 2] + 1;\n        }\n        // 预处理st表\n        // 初始化\n        for (i64 i = 0; i &lt; maxn; i++) {\n            st[i][0] = a[i];\n        }\n        // pre\n        for (i64 j = 1; (1 &lt;&lt; j) &lt;= maxn; j++) {\n            for (i64 i = 0; i + (1 &lt;&lt; j) &lt;= maxn; i++) {\n                st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]);\n            }\n        }\n    }\n    i64 get(int l, int r)\n    {\n        i64 k = logtab[r - l + 1];\n        return max(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]);\n    }\n};"},"ACM/算法/stringstream":{"slug":"ACM/算法/stringstream","filePath":"ACM/算法/stringstream.md","title":"stringstream","links":["tags/语法","tags/字符串"],"tags":["语法","字符串"],"content":"语法 字符串\nC++针对字符串的读写有一套专门的方法，即stringstream\n语法规则：\n\nstringstream ss(str)\nstr是你想进行操作的字符串\n场景：\n读取字符串中的数据：你可以通过 stringstream 从字符串中提取整数、浮动数、字符等。\n将数据写入字符串：可以将不同类型的数据输出到一个字符串中。\n\nmain(){\n\t//读入\n\tstd::stringstream ss(str);\n    int num1, num2;\n    ss &gt;&gt; num1 &gt;&gt; num2;  // 从stringstream读取数据\n    std::cout &lt;&lt; &quot;num1: &quot; &lt;&lt; num1 &lt;&lt; &quot;, num2: &quot; &lt;&lt; num2 &lt;&lt; std::endl;\n    //写出\n    int x = 10, y = 20;\n    std::stringstream ss2;\n    ss2 &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y;  // 将数字写入stringstream\n    std::string result = ss2.str();  // 获取格式化后的字符串\n    std::cout &lt;&lt; &quot;Formatted string: &quot; &lt;&lt; result &lt;&lt; std::endl;\n}\n\n一般而言，我们习惯使用getline来将整个字符串读入，然后直接stringstream ss(s)\n\nmain(){\n\tstring s;\n\tgetline(cin,s);\n\tstd::stringstream ss(s);\n\tint p;\n\t//假设读入的都是数字\n\twhile(ss &gt;&gt; p){\n\t/* code */\n\t}\n}"},"ACM/算法/二分":{"slug":"ACM/算法/二分","filePath":"ACM/算法/二分.md","title":"二分","links":["tags/二分"],"tags":["二分"],"content":"二分\n二分\n二分是一个经典思想，包含二分查找和二分答案\n1 二分查找\n\n在一串升序排列的数字中，找到某一个数字 k\n\n思路： 维护一个左右边界 l,r，其中初始时,  l = \\min(a_n)|_n , r= \\max(a_n)|_n (即最大值和最小值的下标)\n进行循环，直到 l &gt; r,在每个循环做如下操作\n\n维护一个mid, 其为mid = (l + r + 1)/2\n判断a_{mid} = k 是否成立\n\n如果a_{mid} &lt; k 则让 l = mid + 1；\n如果a_{mid} &gt; k 则让 r = mid - 1;\n\n\n跳出循环，此时mid即为数k的下标\n\n2 二分答案\n二分答案是在优化循环时常用的思路，当我们发现一般循环思路难以在规定时间下解决问题的时候可以考虑进行二分答案\n思路如下:\n\n假设得到的答案为 \\omega ，设立 l,r 作为答案 \\omega 的范围\n进行循环：每次将 \\omega 赋值为 (l + r + 1)/2\n通过得到的 \\omega 在题意下推理\n\n如果\\omega符合题意，说明仍然存在范围，可以继续缩小\\omega\n如果不符合题意，说明已经超出范围，需要扩大范围\n\n\n循环结束，此时 \\omega 为最优解\n\n最大连号数问题\n\n例：\n有n个房间，每个房间只能容纳一个人，当两个及以上房间都有人时称为房间连号，连号数等于这一段同时有人的房间的数量，现在有k个人要被分配到房间里，请你找出最佳分配方式使得最大连号数最小,我们保证 k \\leq n\n\n思路：\n\n使用二分答案查找一个数 m ，对于每个猜测的m，我们需要验证是否存在一种分配方式，使得所有连号数不超过m，并且恰好分配k个人\n验证思路：\n\n对于每个候选的m，计算在最大连号数不超过m的情况下，最多可以安排多少人。这通过将房间分成多个段，每个段最多m人，段之间至少有一个空房间来实现。如果这种安排下的人数大于等于k，则m是可行的\n具体思路：\n\n确定 mid = (l + r)/2 ,这里的mid我们将其当作可以放下的最大连号数\n进入循环：\n\nc1 = n/(mid + 1) 表示在这个最大连号数下房间可以被分成几块\n\n因为两个连号房间之间得隔着一个空房间，所以是mid + 1\n\n\nc2 = n - c1*(mid+1) 表示在n个房间中分完了后剩下的部分\n计算在 mid 条件下能放下的人数ans\n比较 ans 与题目人数 k\n\n\n若 ans \\geq k 说明可以放下的人数超过题目人数，可以缩减人数范围\n若 ans &lt; k 则说明要扩大人数范围\n\n\n\n\n\nvoid solve() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    int l = 0, r = k,ans = 0;\n    while (l &lt;= r)\n    {\n        int mid = (l + r) / 2;\n        auto check = [&amp;]() -&gt; bool {\n            int ans1 = 0;\n            int c1 = n / (mid + 1);\n            int c2 = n - c1 * (mid+1);\n            ans1 += c1 * mid + c2;\n            return ans1 &gt;= k;\n        };\n        if(check()){\n            ans = mid;\n            r = mid - 1;\n        }\n        else\n        {\n            l = mid + 1;\n        }\n        \n    }\n    cout &lt;&lt; ans;\n}"},"ACM/算法/二进制":{"slug":"ACM/算法/二进制","filePath":"ACM/算法/二进制.md","title":"二进制","links":["tags/数学","tags/二进制","tags/位运算"],"tags":["数学","二进制","位运算"],"content":"数学 二进制 位运算\n快速获取某一个数的二进制\n法一: 从原理上获取\n\n一个数的二进制的计算可以通过将这个数反复整除2且取模2来获得其位数，直到这个数变为0\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n \nstd::string decimalToBinary(int n) {\n    if (n == 0) return &quot;0&quot;;\n    std::string binary;\n    while (n &gt; 0) {\n        binary = (n % 2 == 0 ? &quot;0&quot; : &quot;1&quot;) + binary;\n        n /= 2;\n    }\n    return binary;\n}\n \nint main() {\n    int number;\n    std::cout &lt;&lt; &quot;请输入一个十进制数: &quot;;\n    std::cin &gt;&gt; number;\n    std::string binaryForm = decimalToBinary(number);\n    std::cout &lt;&lt; &quot;该数字的二进制表示为: &quot; &lt;&lt; binaryForm &lt;&lt; std::endl;\n    return 0;\n}\n法二: 位运算\n\n&amp;(与运算) ： 考虑两个数 a,b ,当 a \\&amp; b 时，实际上是其二进制位的比较，当 a,b 某一个相同的二进制为都为 1 时，运算结果的该二进制位也为 1 ，否则为 0 .\n考虑任意一个 int 类型的正整数 k ，当 k \\&amp; 1 时，实际上得出的数是 k 第0位二进制位的结果\n考虑 k &gt;&gt; x ,这个过程将 k 二进制位向右移动 x 位。此时结合上一条，我们便可以将 k 的每一位表示出来\n\n#include &lt;bits/stdc++.h&gt;\n \nstd::vector&lt;int&gt; decimalToBinary(int n)\n{\n    std::vector&lt;int&gt; bit_2;\n    for (int i = 31; i &gt;= 0; i--) {\n        bit_2.emplace_back((n &gt;&gt; i) &amp; 1);\n    }\n    while (!*bit_2.begin()) bit_2.erase(bit_2.begin());\n    return bit_2;\n}\n \nint main()\n{\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; ans = decimalToBinary(n);\n    for (auto &amp;&amp;i : ans) {\n        std::cout &lt;&lt; i;\n    }\n}\n快速获取一个数二进制有多少个0或1\n放进函数里不断向右一位与 1 进行与运算，计数即可\n#include &lt;bits/stdc++.h&gt;\n \nint count_2bit(int n, bool x)\n{\n    int cnt = 0;\n    while (n &gt; 0) {\n        if ((n &amp; 1) == x) {\n            cnt++;\n        }\n        n &gt;&gt;= 1;\n    }\n    return cnt;\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int n;\n    std::cin &gt;&gt; n;\n    int onecount = count_2bit(n, 1);\n    int zerocount = count_2bit(n, 0);\n    std::cout &lt;&lt; &quot;count one = &quot; &lt;&lt; onecount &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;count zero = &quot; &lt;&lt; zerocount &lt;&lt; std::endl;\n    return 0;\n}\n获取二进制最低位 1 / 0 在第几位\n最低位 1\n要快速找到一个数的二进制表示中最低位的1的位置，可以通过以下步骤：\n\n\n找到最低位1：计算 n &amp; -n，这会得到一个仅保留n最低位1的掩码。\n\n\n位置确定：通过计算掩码的二进制位数或使用计数尾部零的函数（如__builtin_ctz）得到位置。\n\n\n#include &lt;bits/stdc++.h&gt;\n \nint get_2_low0(int n)\n{\n    if (n == 0) return -1;\n    int mask = (n) &amp; -(n);\n    int res = __builtin_ctz(mask);\n    return res;\n}\n \nint main()\n{\n    int n;\n    std::cin &gt;&gt; n;\n    std::cout &lt;&lt; get_2_low0(n) &lt;&lt; std::endl; // 输出0\n    return 0;\n}\n最低位0\n和取1类似，只需要取 ~n &amp; -~n 即可然后找保留1的位置即可\n#include &lt;bits/stdc++.h&gt;\n \nint get_2_low0(int n)\n{\n    int mask = (~n) &amp; -(~n);\n    int res = __builtin_ctz(mask);\n    if (pow(2, res) &gt; n) return -1;\n    return res;\n}\n \nint main()\n{\n    int n;\n    std::cin &gt;&gt; n;\n    std::cout &lt;&lt; get_2_low0(n) &lt;&lt; std::endl;\n    return 0;\n}\n某些特殊二进制数判断\n判断数k是不是2的幂次\n思路：如果k为2的幂次，则k的二进制构造为：k_2 = 1\\overbrace{0\\cdots0 }^{n},则(k-1)_2 = \\overbrace{1\\cdots1}^{n-1} 使用 k\\, \\&amp;\\, (k-1)检查是否为0即可\n\nbool is_power_of2 = k &amp; ( k - 1 ) == 0\n\n判断数k是不是二进制全1数\n\n结合上一个判断\n\nbool is1num = k&amp;(k+1) == 0\n\n\n\n某些特殊数下的特殊性质\n当k为2^n时\n\n若p &lt; k :\n\np \\oplus k = p+k\np\\ \\&amp;\\ k = 0\np\\ \\mid \\ k = 0\np\\mod k = p\\,\\&amp;(k-1)\n\n\nk\\ \\&amp; \\ (k-1) = 0\n\n当k = 2^n - 1时\n\n若p \\leq k时\n\np \\oplus k = p-k\np\\,\\&amp;\\, k=p\\%(k+1)\n\n\n"},"ACM/算法/位运算":{"slug":"ACM/算法/位运算","filePath":"ACM/算法/位运算.md","title":"位运算","links":["tags/位运算","tags/二进制","tags/数学"],"tags":["位运算","二进制","数学"],"content":"位运算 二进制 数学\n两数之间的运算符\n\n两数的运算符有 「与，或，异或」三种运算方式，它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算运算符数学符号解释与&amp;\\And,and只有两个对应位都为 1 时才为 1或|\\mid,or只要两个对应位中有一个 1 时就为 1异或^\\oplus,xor只有两个对应位不同时才为 1\n一些总结经验：\n\n\n对或(|)运算而言，有如下性质：\n\na \\mid b = b \\mid a\n\\left( a \\mid b \\right) \\mid c = \\left( b \\mid c \\right) \\mid a\na \\mid 0 = a\na \\mid a = a\n若 a\\leq b，则 a \\mid c \\leq b \\mid c（对无符号数成立)\na \\mid b \\leq \\max(a,b)\n\n\n\n对异或 \\oplus 有如下性质：\n\na \\oplus b = a + b - 2(a \\&amp; b)\na \\oplus b = x \\Rightarrow a = b \\oplus x\n\n\n"},"ACM/算法/分数背包问题-(Fractional-Knapsack-Problem)":{"slug":"ACM/算法/分数背包问题-(Fractional-Knapsack-Problem)","filePath":"ACM/算法/分数背包问题 (Fractional Knapsack Problem).md","title":"分数背包问题 (Fractional Knapsack Problem)","links":["tags/贪心","tags/背包问题"],"tags":["贪心","背包问题"],"content":"贪心 背包问题\n分数背包问题 (Fractional Knapsack Problem)\n\n代表题目：洛谷P2240[部分背包问题][www.luogu.com.cn/problem/P2240]\n部分背包问题，本质甚至不是动态规划，而是贪心,这个题名出的非常具有迷惑性\n特点：\n\n有一个容量为T 的背包\n有N组物品，每组物品分别有以下两个特性：\n\n价值：这堆物品所代表的价值\n重量：这堆物品的重量\n\n\n与经典的0/1背包不同的是，分数背包允许将物品划分为重量为 1 的单位物品\n策略：先计算每一堆物品的单位价值，再根据单位价值装填背包。\n对P2240代码如下：\n\n\n   //#pragma GCC optimize(3)\n   #include &lt;bits/stdc++.h&gt;\n   //#define int LL\n   #define endl &#039;\\n&#039;\n   #define size_t int\n   #define all(v) v.begin(), v.end()\n   using namespace std;\n   typedef long long LL;\n   typedef vector&lt;int&gt; vint; \n   typedef vector&lt;vint&gt; vvint;\n   typedef vector&lt;string&gt; vstr;\n   typedef pair&lt;int, int&gt; pii;\n   typedef vector&lt;pii&gt; vpii;\n   \n   bool cmp(pair&lt;double, int&gt; a, pair&lt;double, int&gt; b)\n   {\n       if (a.first == b.first) return a.second &gt; b.second;\n       return a.first &gt; b.first;\n   }\n   signed main()\n   {\n       //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n       int n, t;\n       cin &gt;&gt; n &gt;&gt; t;\n       vector&lt;pair&lt;double, int&gt;&gt; coin(n);\n       for (auto &amp;&amp;[val, wei] : coin) {\n           double m, v;\n           cin &gt;&gt; m &gt;&gt; v;\n           val = (v / m);\n           wei = m;\n       }\n       sort(all(coin), cmp);\n       double ans = 0;\n       for (size_t i = 0; i &lt; n; i++) {\n           if (t &gt;= coin[i].second) {\n               ans += coin[i].second * coin[i].first;\n               t -= coin[i].second;\n           }\n           else {\n               ans += coin[i].first * t;\n               break;\n           }\n       }\n       printf(&quot;%.2f&quot;, ans);\n       return 0;\n   }\n\n不难发现这其实是一种贪心而非背包问题\n"},"ACM/算法/前缀和与差分":{"slug":"ACM/算法/前缀和与差分","filePath":"ACM/算法/前缀和与差分.md","title":"前缀和与差分","links":["tags/数学","tags/前缀和与差分"],"tags":["数学","前缀和与差分"],"content":"数学 前缀和与差分\n前缀和与差分\n1.1 一维数组的前缀和\n\n对数列 A [1,2,3,4,5] ,求数列B,使B_i = \\sum_{k=0}^{i}A_k\n\n\n思路： 因为B[0] = A[0]  且有递推式 B_i = B_{i-1}+A_i构造递推式\n\nint main()\n{\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    vector&lt;int&gt; A = {1, 2, 3, 4, 5, 6};\n    vector&lt;int&gt; B(A.size());\n    B[0] = A[0];\n    for (size_t i = 1; i &lt; A.size(); i++) {\n        B[i] = B[i - 1] + A[i];\n    }\n    for (auto &amp;&amp;i : B) cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    //输出: 1 3 6 10 15 21\n    return 0;\n}\n\n于传统代码相比，将时间复杂度从O(n^2)降低到O(n)且空间复杂度仍然是O(n)\n\n1.2 二维数组的前缀和\n对一个二维数组A:\nA=\n\\left[\n\\begin{matrix}\n1 &amp; 2 &amp; 3 &amp;4\\\\\n5 &amp; 6 &amp; 7 &amp;8 \\\\\n9 &amp; 10 &amp;11 &amp;12  \\\\\n\\end{matrix}\n\\right]\n二维数组前缀和定义：存在二维数组S，有：\nS_{i,j} = \\sum_{k_1=0}^{i}\\sum_{k_2=0}^{j}A_{k_1,k_2}\n类比一维的情形，S_{i,j}应该可以基于S_{i-1,j}或 S_{i,j-1} 计算，从而避免重复计算前面若干项的和。但是，如果直接将S_{i-1,j}和 S_{i,j-1} 相加，再加上 A_{i,j}，会导致重复计算 S_{i-1,j-1} 这一重叠部分的前缀和，所以还需要再将这部分减掉。这就是 容斥原理。由此得到如下递推关系：\nS_{i,j} = A_{i,j} + S_{i-1,j} + S_{i,j-1} - S_{i-1,j-1}\n简单代码实现:\nint main()\n{\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    //在构建A的时候可以将A整体向右下移一个单位防止负数下标的出现\n    vector&lt;vector&lt;int&gt;&gt; A = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 2, 3, 4},\n        {0, 5, 6, 7, 8},\n        {0, 9, 10, 11, 12},\n    };\n    vector&lt;vector&lt;int&gt;&gt; S(A.size(), vector&lt;int&gt;(A[0].size()));\n    S[1][1] = A[1][1];\n    for (size_t i = 1; i &lt; A.size(); i++) {\n        for (size_t j = 1; j &lt; A[0].size(); j++) {\n            if (i == j &amp;&amp; i == 1) continue;\n            S[i][j] = A[i][j] + S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1];\n        }\n    }\n    for (auto &amp;&amp;i : S) {\n        for (auto &amp;&amp;j : i) {\n            cout &lt;&lt; j &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n    /*输出：\n    0 0 0 0 0\n    0 1 3 6 10\n    0 6 14 24 36\n    0 15 33 54 78\n    */\n    return 0;\n}\n\n例：洛谷 P1387 最大正方形\n最大正方形\n题目描述\n在一个 n\\times m 的只包含 0 和 1 的矩阵里找出一个不包含 0 的最大正方形，输出边长。\n输入格式\n输入文件第一行为两个整数 n,m(1\\leq n,m\\leq 100)，接下来 n 行，每行 m 个数字，用空格隔开，0 或 1。\n输出格式\n一个整数，最大正方形的边长。\n样例 #1\n样例输入 #1\n4 4\n0 1 1 1\n1 1 1 0\n0 1 1 0\n1 1 0 1\n样例输出 #1\n2\n\n\n解决思路：\n\n\n先使用二维前缀和数组将输入数组A的A_{1,1}\\to A_{i,j}的和表示出来\n\n\n设立边长l从1开始找最小正方形，其过程如下：\n\n\n设立i,j作为假设正方形的右下角点,找的正方形为以l为边长，底点为(i,j)的一个正方形\n\n\n显然i,j均从l开始，到m,n结束\n\n\nb[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l作为判断标准(why)\n\n\n\n\n\n\nb[i][j]是从(1,1) \\to (i,j)的前项和，我们需要求 (i-l,j-l) \\to (i,j) 的和\n![[Pasted image 20250123215240.png]]\n![[Pasted image 20250123215327.png]]\n\n\n\n不难发现：我们想求的是黄色部分的前缀和并判断其是否等于l^2\n\n\n我们可以发现求黄色部分就是将b(i,j)减去图一蓝色的部分，可以减去两矩形的面积b(i-l,j),b(i,j-l),但显然会多减去图二绿色部分的区域，所以我们需要利用容斥定理加上b(i-l,j-l)的面积\n\n\n所以我们便得到了黄色部分的递推表达式:\nlocans = b_{i,j} - b_{i-l,j}-b_{i,j-l}+b_{i-l，j-l}\n\n\n\n\n现在判断locans与l^2的关系即可\n完成一次查找之后就可以让 l 增加,显然 l \\in [1,\\min(n,m)]\n示例代码：\n\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint a[103][103];\nint b[103][103];  // 前缀和数组，相当于上文的 sum[]\n \nint main() {\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n \n  for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n      cin &gt;&gt; a[i][j];\n      b[i][j] =\n          b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1] + a[i][j];  // 求前缀和\n    }\n  }\n \n  int ans = 0;\n \n  int l = 1;\n  while (l &lt;= min(n, m)) {  // 判断条件\n    for (int i = l; i &lt;= n; i++) {\n      for (int j = l; j &lt;= m; j++) {\n        if (b[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l) {\n          ans = max(ans, l);  // 在这里统计答案\n        }\n      }\n    }\n    l++;\n  }\n \n  cout &lt;&lt; ans &lt;&lt; endl;\n  return 0;\n}\n\n\n                  \n                  Tip\n                  \n                \n\n\n上面进行的操作便是在前缀和中寻找某一区域的和的操作，利用这个思想，我们可以寻找任意大小的区域和，可以从容斥定理入手，进行区域和的计算\n\n\n\n树上前缀和\n\n一维数组树上前缀和\n\n在求解一维数组之前我们要进行一次前缀和操作\n对数组A的[l,r]区间，其区间和如下：\n\n\n\nsum[l,r]=S[r]−S[l−1]\n时间复杂度：构造前缀和数组O(n),查询区间和O(1)\n\n二维数组树上前缀和\n\n与一维数组树上前缀和一样，二维树上前缀和也需要提前做好前缀和工作\n快速求任意子矩阵的和\n\n\n\n\\text{sum}([x_1, y_1], [x_2, y_2]) = S[x_2][y_2] - S[x_1-1][y_2] - S[x_2][y_1-1] + S[x_1-1][y_1-1]\n\n其中：\n\nS[x_1][y_2]：从 [1,1]到[x_1,y_1]的矩形和；\nS[x_2][y_2]：从 [1,1] 到 [x_2,y_2] 的矩形和；\n−S[x_1−1][y_2]：减去上方多余的矩形；\n−S[x2][y1−1]: 减去左侧多余的矩形；\n+S[x1−1][y1−1]：加回左上角重复减去的部分。\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n要注意的是在减去左边和上边的矩形的时候，下标都为S[x_1 - 1][y_2]和 S[x_2][y_1-1]\n\n\n\n差分\n\n\n指找数组范围内某一两项的差\n\n\n定义：diff[i] = a_i - a_{i-1} 特别的：i = 1时，diff[1] = a_1\n\n\n差分和原数组的关系 性质：\n\n我们将差分数组做一次前项和得到的即为原数组\n显然：我们对前缀和数组做一次差分得到的就是原数组\n差分计算数组动态变化\n\n\n\n对数组A的[l,r]区间同时加k有：\n\n\n\tdiff[l] += k\n\tdiff[r+1] -= k\n此时再进行一次前缀和，即可完成原始数组的复原\nfor(int i = 1; i &lt;= diff.size() ; i++){\n    sum[i] = sum[i-1] + d[i];\n}"},"ACM/算法/单调栈":{"slug":"ACM/算法/单调栈","filePath":"ACM/算法/单调栈.md","title":"单调栈","links":["tags/模板","tags/栈"],"tags":["模板","栈"],"content":"模板 栈\n单调栈\n\n何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。\n将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。\n\n\n如上：一个 {0,11,45,81}的单调栈，如果要插入元素 14\n\n必须将{0,11} 弹出栈，再放入 元素 14\ninsert x;\nwhile (!sta.empty() &amp;&amp; sta.top() &lt;= x) {\n    sta.pop();\n}\nsta.push(x);\n\n\n                  \n                  TIP\n                  \n                \n\n\n有的人会问，那被弹出去的元素呢？其实，在大部分单调栈问题中，我们更关注在一次弹出后的栈的状态，即在放入当前元素前栈的各个属性，比如：\n\n栈顶 \\to  能告诉我们比这个元素大(小)的元素是什么\n栈的大小 \\to 能告诉我们在这个元素前有几个比当前元素大(小)的元素\n\n\n\n\n例题：\n\n洛谷P5788 单调栈(模板)\n\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    vint n(t);\n    for (size_t i = 0; i &lt; t; i++) {\n        cin &gt;&gt; n[i];\n    }\n    stack&lt;int&gt; sta;\n    vint result(t, 0);\n    for (size_t i = t - 1; i &gt;= 0; i--) {\n        while (!sta.empty() &amp;&amp; n[sta.top()] &lt;= n[i]) {\n            sta.pop();\n        }\n        result[i] = sta.empty() ? 0 : sta.top() + 1;\n        sta.push(i);\n    }\n    for (auto &amp;&amp;i : result) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n\n思路解释：\n\n维护一个单调存放数字下标的单调栈，这个单调栈入栈的规则根据数字的具体大小决定\n当某个元素入栈时，说明至少这个元素会比当前的栈顶下标所代表的元素要大，所以我们便把栈顶弹出，直到找到某个比当前元素大的数\n而找到的这个正好就是我们要找的刚好大于这个数，我们就被栈顶放入 result  数组中即可\n那为什么栈顶就是我们要找的数字呢？\n\n如 2 6 5 7 5\n\n进行比较的是与元素的大小，但栈存放的是下标 \\to 所以使用 n[sta.top()] &lt;= n[i]进行下标栈和元素大小栈的转换\n\n\n我们最先放进去的是 5 ，此时栈的状态是 { 5 } ， \\to  下标栈的状态 { 5 }\n接着我们要放入 7  ，不难发现 7  &gt; 5  ,弹出 5 放入 7\nsta : { 4 } —— num { 7 }\n再看 5 ，5  &lt;  7  ,不需要弹出，直接放入，此时比 5 大的数就是 7 ，在result 数组下 放入 sta.top()即可\nsta : { 3 4 } ——  num {5 7}\n看 6 ，6 比 5 大 ，比 7 小 ， 将 5 弹出 ，放入 7 所代表的下标作为答案\n以此类推即可\n\n\n\n\n例题2：\n\n [USACO06NOV] Bad Hair Day S\n\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int t = 1, ans = 0;\n    cin &gt;&gt; t;\n    stack&lt;int&gt; cowh;\n    for (size_t i = 1; i &lt;= t; i++) {\n        int h;\n        cin &gt;&gt; h;\n        while (!cowh.empty() &amp;&amp; cowh.top() &lt;= h) {\n            cowh.pop();\n        }\n        ans += cowh.size();\n        cowh.push(h);\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n\n思路解释\n\n与上一题相似，但这次我们要找的是前面有多少个比放入的数字大的数量\n\n还是维护一个栈，如果当前放入的数字比栈顶大就弹出栈顶\n我们 ans 加的是还放入这个数的栈的大小，代表在这之前比这个数字大的数字有多少个\n我们要求的是 这个数能看见多少个数，求所有数能看见的总和   同样可以标识为 这个数能被多少个数看见，每个数能被看见的总和\n那当我们弹出比这个数小的数字之后，剩下的数就一定都能看见这个数\n将这些数量加到 ans 内即可\n\n\n\n"},"ACM/算法/哈希表":{"slug":"ACM/算法/哈希表","filePath":"ACM/算法/哈希表.md","title":"哈希表","links":["tags/哈希","tags/STL","编程语言/C++/STL/Set-集合","编程语言/C++/STL/Map-映射"],"tags":["哈希","STL"],"content":"哈希 STL\n哈希表\n哈希表的实现可以由三种数据结构实现\n\nSet 集合 Map 映射 unordered_map 无序映射\n\n\n\n哈希表算法是一种以空间换时间的算法，可以在判断数据是否重复出现 or 数据去重方面有优异性能\n\n例题：leetcode NO.1两数之和\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n哈希代码示例：&lt;leetcode.1&gt;\n\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; mp;\n        for (int i = 1; i &lt;= nums.size(); i++) {\n            mp[nums[i - 1]] += i;\n            if (mp[target - nums[i]] != 0) {\n                return {i, mp[target-nums[i]]-1};\n            }\n        }\n        return {};\n    }\n};"},"ACM/算法/图论/图论基础":{"slug":"ACM/算法/图论/图论基础","filePath":"ACM/算法/图论/图论基础.md","title":"图论基础","links":[],"tags":[],"content":"建图\n一般来说，我们在点少于10^3时候可以使用邻接矩阵，n更大的时候可以用邻接表\n邻接表\nvector&lt;vector&lt;i64&gt;&gt; g(n);"},"ACM/算法/图论/拓扑排序":{"slug":"ACM/算法/图论/拓扑排序","filePath":"ACM/算法/图论/拓扑排序.md","title":"拓扑排序","links":[],"tags":[],"content":"拓扑排序是将偏序关系变化成线性关系的一种方法\n如何进行拓扑排序?我们介绍 Kahn 算法\n\n\n                  \n                  A \n                  \n                \n\n\nkahn算法的主要思想是不断删除入度为0的节点并将其移除\r\n具体步骤:\n\n统计每个节点的入度\n将所有入度为0的点加入队列\n不断的从队列中取出节点\n\n\n将其加入结果序列\n对其所有出边的目标节点入度减1\n如目标节点入度为0,则入队\n\n\n如果最终结果包括所有节点，则说明排序完成，否则说明图中有环\n\n\n\n\nstruct Kahn\n{\n    vint order;\n    i64 n;\n    Kahn(const vvint &amp;g)\n    {\n        this-&gt;n = g.size();\n        order.reserve(n);\n        kahnsort(g);\n    }\n    void kahnsort(const vvint &amp;g)\n    {\n        queue&lt;i64&gt; qu;\n        vint indeg(n);\n        for (i64 u = 1; u &lt;= n; u++) {\n            for (auto &amp;&amp;v : g[u]) {\n                indeg[v]++;\n            }\n        }\n        for (i64 i = 1; i &lt;= n; i++) {\n            if (indeg[i] == 0) qu.push(i);\n        }\n        while (!qu.empty()) {\n            i64 u = qu.front();\n            order.emplace_back(u);\n            for (auto &amp;&amp;v : g[u]) {\n                if (--indeg[v] == 0) qu.push(v);\n            }\n        }\n    }\n    vint get_order() const\n    {\n        return order;\n    }\n};\n例题\r\nProblem - C - 2143\n对于这题，我们先疏通题意\n题目给定我们一个树,数上每个边都关联两个贡献值x,y,对于边(u,v) 定义边的贡献值为:\n\\begin{cases}\r\nx \\qquad if\\ p_{u} &gt; p_{v} \\\\\r\ny \\qquad otherwise\r\n\\end{cases}\n其中p_u,p_v需要我们如下定义,给定一个排列P,将P中每个数填入树中的节点上\n我们需要确定一种排列，使整个树的贡献值最大\n\n[!思路]\r\n显然，因为我们获得的是一个排列，我们可以确定一种关系，让每一个边都可以获得较大的一个数，这实际上确定了一种偏序关系\n所以我们便可以使用拓扑排序来确定线性关系,具体如下：\n我们对树上每一个边从较小的节点向较大的节点建立有向边，最终形成有向图，最后我们对这个有向图拓扑排序即可\n\nAC solution\nvoid solve()\n{\n    i64 n;\n    cin &gt;&gt; n;\n    vint p(n + 1, 0);\n    vector&lt;vector&lt;i64&gt;&gt; adj(n + 1);\n    for (i64 i = 1; i &lt; n; i++) {\n        i64 u, v, x, y;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; x &gt;&gt; y;\n        if (x &gt; y) {\n            adj[v].push_back(u);\n            p[u]++;\n        }\n        else {\n            adj[u].emplace_back(v);\n            p[v]++;\n        }\n    }\n    // 拓扑排序\n    queue&lt;i64&gt; qu;\n    for (i64 i = 1; i &lt;= n; i++) {\n        if (p[i] == 0) qu.push(i);\n    }\n    vint order;\n    order.reserve(n);\n    while (!qu.empty()) {\n        i64 u = qu.front();\n        qu.pop();\n        order.push_back(u);\n        for (auto &amp;&amp;i : adj[u]) {\n            p[i]--;\n            if (p[i] == 0) {\n                qu.push(i);\n            }\n        }\n    }\n    vint res(n + 1);\n    for (i64 i = 0; i &lt; order.size(); i++) {\n        res[order[i]] = i + 1;\n    }\n    for (i64 i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}"},"ACM/算法/图论/最近公共祖先LCA":{"slug":"ACM/算法/图论/最近公共祖先LCA","filePath":"ACM/算法/图论/最近公共祖先LCA.md","title":"最近公共祖先LCA","links":[],"tags":[],"content":"在进行寻找最近公共祖先的时候我们有必要先了解如何判断一个节点是不是这个节点的祖先"},"ACM/算法/并查集":{"slug":"ACM/算法/并查集","filePath":"ACM/算法/并查集.md","title":"并查集","links":["tags/图","tags/模板"],"tags":["图","模板"],"content":"图 模板\n并查集维护的是多个不相交的集合，支持两种操作:\n\n查找:查找某个元素所属的集合\n合并:将两个元素合并成一个\n\n用于维护并查集数据结构是多颗 树 组成的 森林\n原理\n查询\n\n在使用并查集时候，设立一个数组 parent 来记录每个元素的父节点：\n\n如果 parent[i] = i ,表明 i 是自己的根，即它是一个独立的集合\n如果 parent[i] = j,说明 i 属于 j 这个集合\n当我们想查询 i 时候,我们可以递归查询 parent[i]\n合并\n\n\n我们若要实现对两个数组 parent_i 和 parent_j 的合并\n\n我们只需要将一棵树的根指向另一颗树即可\n换句话说，我们只需要将 parent[i] = j即可\n\n\n\n基础实现\nconst int N = 1e7;\nvector&lt;int&gt; parent(N);\n \nvoid init()\n{\n    for (size_t i = 0; i &lt; N; i++) {\n        parent[i] = i;\n    }\n}\n \nint dsufind(int x)\n{\n    if (parent[x] == x) return x;\n    return dsufind(parent[x]);\n}\n \nvoid union_set(int x, int y)\n{\n    int rootx = x;\n    int rooty = y;\n    if (rootx != rooty) parent[x] = y;\n}\n \nvoid solve()\n{\n    init();\n    union_set(1, 2);\n    union_set(3, 1);\n    cout &lt;&lt; dsufind(3);\n}\n并查集的优化\n\n在对并查集的基本实现中,查找可能会遍历很深的树,为了提高效率,我们引入路径压缩和按秩合并\n\n路径压缩\n在dsufind过程中，让x直接指向根，减少查找的层数\nint dsufind(int x)\n{\n    if (parent[x] != x) parent[x] = dsufind(parent[x]);\n    return parent[x];\n}\n按秩合并\n目标： 在 union_set(x, y) 时，让“矮的树”挂到“高的树”下面，减少树的高度\n方法： 维护一个 rank[] 数组，表示树的高度：\n\nrank[rootX] &gt; rank[rootY]：让 rootY 挂到 rootX 下\nrank[rootX] &lt; rank[rootY]：让 rootX 挂到 rootY 下\nrank[rootX] == rank[rootY]：任选一个为根，并 rank++\n\nvoid union_set(int x, int y)\n{\n    int rootx = x;\n    int rooty = y;\n    if (rootx != rooty) {\n        if (ranks[rootx] &gt; ranks[rooty]) {\n            parent[rooty] = rootx;\n        }\n        else if (ranks[rootx] &lt; ranks[rooty]) {\n            parent[rootx] = rooty;\n        }\n        else {\n            parent[rootx] = rooty;\n            ranks[rootx]++;\n        }\n    }\n}\n在优化后的并查集时间复杂度为O(\\alpha(N)) 其中\\alpha(N)为阿克曼函数的逆，增长极慢，可以近似表现为O(1)\nunordered_map作为数据结构的并查集\n当我们试图对字符串做并查集操作的时候，我们可以利用到unordered_map&lt;string,string&gt;作为数据结构基础来实现并查集\n我们这里用类给出\nclass dsuFind {\nprivate:\n    unordered_map&lt;string, string&gt; parent;  // 存储每个字符串的父节点\n    unordered_map&lt;string, int&gt; rank;       // 按秩合并，记录树的高度\n \npublic:\n    // 查找（带路径压缩）\n    string find(string x) {\n        if (parent.find(x) == parent.end()) parent[x] = x;  // 如果 x 不在并查集，初始化\n        if (parent[x] != x) parent[x] = find(parent[x]);  // 路径压缩\n        return parent[x];\n    }\n    // 合并（按秩合并）\n    void union_set(string x, string y) {\n        string rootX = find(x);\n        string rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] &gt; rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] &lt; rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootX] = rootY;\n                rank[rootY]++;\n            }\n        }\n    }\n    // 判断两个字符串是否在同一集合\n    bool isConnected(string x, string y) {\n        return find(x) == find(y);\n    }\n};\n当然对整数我们也可以使用unordered_map来构造树，但是在大部分情况下都没有数组效率高\n特别的，当n特别大且是离散的时候我们可以使用unordered来作为树的结构"},"ACM/算法/快读与快写":{"slug":"ACM/算法/快读与快写","filePath":"ACM/算法/快读与快写.md","title":"快读与快写","links":[],"tags":[],"content":"\n在某些极端卡常情况下,IO瓶颈也可能成为限制时间的因素之一,而且输入的性能损耗尤其严重,所以我们需要一套快速读写来尽可能提高输入输出速度\n\n对于快读,有\nstatic inline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch&lt;&#039;0&#039;||ch&gt;&#039;9&#039;){if (ch==&#039;-&#039;) f=-1;ch=getchar();}\n\twhile (ch&gt;=&#039;0&#039;&amp;&amp;ch&lt;=&#039;9&#039;){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n对于快写,只能写int类型或long long类型\nstatic inline void write(int x, char endc = &#039;\\n&#039;) {\n    if (x == 0) { putchar_unlocked(&#039;0&#039;); putchar_unlocked(endc); return; }\n    if (x &lt; 0) { putchar_unlocked(&#039;-&#039;); x = -x; }\n    char s[12]; int n = 0;\n    while (x) { s[n++] = char(&#039;0&#039; + x % 10); x /= 10; }\n    while (n--) putchar_unlocked(s[n]);\n    putchar_unlocked(endc);\n}"},"ACM/算法/快速幂":{"slug":"ACM/算法/快速幂","filePath":"ACM/算法/快速幂.md","title":"快速幂","links":["tags/模板","tags/数学"],"tags":["模板","数学"],"content":"模板 数学\n7 快速幂\n\n不多说，先上代码\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \nlong long fastpower(long long a , long long b)\n{\n    long long ans = 1;\n    while (b &gt; 0)\n    {\n        if (b&amp;1)\n        {\n            ans *= a;\n        }\n        a *= a;\n        b &gt;&gt;= 1;\n    }\n    return ans;\n}\n \nint main()\n{\n    cout &lt;&lt; fastpower(2,8);\n}\n快速幂的核心思路在下面这串代码里\nwhile (b &gt; 0)\n{\n    if (b&amp;1)\n    {\n        ans *= a;\n    }\n    a *= a;\n    b &gt;&gt;= 1;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n\n\nb是我们的指数，只要大于零，我们便把这个循环继续下去\n\n\n对任何一个数，都可以拆解为2进制的数，快速幂的核心思想在于，在幂次b二进制转化为十进制的时候0\\times2^k是可以不用乘进结果的而 1\\times2^k是需要被乘进结果的\n\n\n示例：\n\n\n假设我们要计算 a^{13}：\n\n13 的二进制表示是 1101_2。\n从最低位开始：\n\n第一位（1）：需要 a^{2^0}。\n第二位（0）：不需要 a^{2^1}。\n第三位（1）：需要 a^{2^2}。\n第四位（1）：需要 a^{2^3}。\n\n\n\n\n\n因此，我们可以计算：\n\\begin{split}\na^{13} &amp;= a^{1\\times2^0} + a^{0\\times2^1} + a^{1\\times2^2} +a^{1\\times2^3} \\\\\n\t   &amp;= a^{1+0+4+8}\\\\\n \t   &amp;= a^{13}\\\\\n\\end{split}\n\n只要b大于零，我们就把他的二进制右移(除二)，这样我们就能获取下一位二进制数字\n如果b的二进制位为1，我们就把该位置的幂次方乘进ans中，待b移位完成后ans也完成了幂运算\n\n\n\n\n\n快速幂的时间复杂度为O(\\log{N})\n"},"ACM/算法/扩展欧几里得算法":{"slug":"ACM/算法/扩展欧几里得算法","filePath":"ACM/算法/扩展欧几里得算法.md","title":"扩展欧几里得算法","links":["tags/数学","tags/丢番图","tags/模板","ACM/算法/线性丢番图方程"],"tags":["数学","丢番图","模板"],"content":"数学 丢番图 模板\n扩展欧几里得算法(Extended Euclidean Algorithm)\n扩展欧几里得算法是基于经典的欧几里得算法，用于计算两个整数 a和 b的最大公约数，同时还能够找到一组整数系数 x和 y，使得以下等式成立：\nax+by=\\gcd⁡(a,b)\n\n上式是一个典型的线性丢番图方程，其实扩展欧几里得算法也常用于计算线性丢番图方程的一组特解\n\n实现：\n\n初始化：设置初始值 r_0=a, r_1=b，同时设置系数 s_0=1, s_1=0 和 t_0=0, t_1=1\n执行辗转相除直到余数为0 (求gcd过程).对于每次迭代 i :\n\n计算商q_i = \\lfloor{r_i-2/r_i-1}\\rfloor和余数r_i = r_{i-2} - q_ir_{i-1}\n更新系数s_i = s_{i-2}-q_is_{i-1}和t_i = t_{i-2}-q_it_{i-1}\n\n\n结束条件：当某个余数 r_n=0=0 时，前一个非零余数 r_{n−1}就是 a 和 b 的最大公约数，而对应的 s_{n−1} 和 t_{n−1}即为满足等式的系数  x和 y\n\nint exgcd(int a, int b, int &amp;x, int &amp;y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a; // 返回gcd(a, b)\n    }\n    int r = exgcd(b, a % b, x, y);\n    int t = y;\n    y = x - (a / b) * y;\n    x = t;\n    return r;\n}\n\n上述代码中传入参数x,y最后会变为一组特解，返回的r是a，b的最大公因数\n"},"ACM/算法/数论/同余定理与简单模运算定理":{"slug":"ACM/算法/数论/同余定理与简单模运算定理","filePath":"ACM/算法/数论/同余定理与简单模运算定理.md","title":"同余定理与简单模运算定理","links":[],"tags":[],"content":"模的定义\n当我们讨论r = a \\bmod b 时候实际上有 a = qb + r 其中q为一个非负整数\n同余定理\n下面我们会给出模数的几个重要性质，即同余定理并且尝试证明\n\n定理1:当a \\equiv b\\pmod m且 d \\equiv 0\\pmod m 时，有 a \\equiv b \\pmod d\n\npoof:\n\\begin{align*}\n\\because a &amp;\\equiv b \\pmod m\\\\\n\\text{设: }\\quad qm + r &amp;= a,pm + r = b \\\\\n\\because d &amp;\\equiv 0\\pmod m \\\\\n\\text{设: }\\qquad \\quad m &amp;= kd \\\\\n\\text{显然：}\\qquad \\quad a &amp;= qkd + r , b = pkd + r \\\\\n\\therefore a &amp;\\equiv b \\pmod d\\\\\n\\mathbb{Q.E.D}\n\\end{align*}\n\n定理2:当 a \\equiv b \\pmod m \\quad \\text{and} \\quad c \\equiv d \\pmod m 时，有：\n\n\\begin{align*} (1) \\quad a+c \\equiv b+d \\pmod m \\\\ (2)\\quad a - c \\equiv b - d \\pmod m \\\\ (3) \\quad a \\times c \\equiv b \\times d \\pmod m \\end{align*}\npoof\n\\begin{align*}\n\\because a &amp;\\equiv b \\pmod m \\ , \\ c \\equiv d \\pmod m \\\\\n\\text{设： } a = k_{a}m + r&amp;,b = k_{b}m+r ,c = k_{c}m+w,d= k_{d}m + w\\\\\n\\\\\npoof(1): \\\\\na + c &amp;= k_{a}m + k_{c}m + r + w \\\\\nb + d &amp;=  k_{b}m + k_{d}m + r + w \\\\\n(a + c) \\bmod m &amp;= (r + w) \\bmod m\\\\\n(b + d) \\bmod m &amp;= (r + w) \\bmod m\\\\\n\\therefore a+c &amp;\\equiv b+d \\pmod m\\\\\n\\\\\npoof(2): \\\\\n\\text{同(1)有： } (a - c) \\bmod m  &amp;= (r - w) \\bmod m\\\\\n(b - d) \\bmod m &amp;= (r -w) \\bmod m \\\\\n\\therefore a - c &amp;\\equiv b - d \\pmod m\\\\\n\\\\\npoof(3):\\\\\nac &amp;= (k_{a}m+r)(k_{c}m + w) \\ ,\\ bd = (k_{b}m+r)(k_{d}m+w)\\\\\nac &amp;= k_{a}k_{c}m^{2} + (k_{a}w+ k_{c}r)m + wr\\\\\nbd &amp;= k_{b}k_{d}m^{2}+ (k_{b}w+k_{d}r)m + wr\\\\\nab \\bmod m &amp;= wr \\bmod m \\\\\ncd \\bmod m &amp;= wr \\bmod m\\\\\na \\times c &amp;\\equiv b \\times d \\pmod m\\\\\n\\\\\n\\mathbb{Q.E.D}\\\\\n\\end{align*} \n\n定理3: 当 ac \\equiv bc \\pmod m 且 \\gcd{(c,m)} = 1 时，有 a \\equiv b \\pmod m\n\n由于LaTeX太难打了，下面证明采用更简单的方式呈现\npoof:\n\n因为\\gcd(c,m) = 1即存在c^{-1}使得c \\cdot c^{-1} \\equiv 1\\pmod m\n显然ac\\cdot c^{-1} \\equiv bc\\cdot c^{-1} \\pmod m\n既: a \\equiv b \\pmod m\n\\mathbb{Q.E.D}\n\n\n定理4: 当 a \\equiv b \\pmod m 时,对于任意的 c \\ne 0 有 ac \\equiv bc \\pmod m\n\npoof:\n\na \\equiv b \\pmod m \\Rightarrow a - b = k_{1}m\nac \\equiv bc \\pmod m \\Rightarrow c(a - b) = k_{2}m\n\n有a - b = \\frac{k_{2}}{c}m\n\n\n在模运算下我们不关心m前的系数,即 a - b = \\frac{k_{2}}{c}m \\iff a \\equiv b \\pmod m\n\n\n定理5: 当 a \\equiv b \\pmod m时,对任意正整数k,有 a^{k} \\equiv b ^{k} \\pmod m\n\npoof:\n\n由定理3: a \\equiv b \\pmod m \\Rightarrow a \\cdot a \\equiv b \\cdot b \\pmod m\n扩展可得: a^{k} \\equiv b^{k} \\pmod m\n\n\n定理6: 当 a \\equiv b \\pmod m时,存在整数k,使a - b = km\n\npoof:\n\na = k_{1}m + r,b = k_{2}m+r\n显然存在 k = k_{1} - k_{2} 有 a-b = km\n\n在模意义下的四则运算\n在模意义下,四则运算的处理应该谨慎,下面给出四则运算处理方式\n加法:\na + b \\Rightarrow (a + b)\\% \\text{MOD}\n减法:\na - b \\Rightarrow (a -b+\\text{MOD})\\%\\text{MOD}\n乘法:\na \\times b \\Rightarrow (a \\times b)\\%\\text{MOD}\n除法(整除意义下):\n\\frac{a}{b} \\Rightarrow a \\times b^{-1} \\% \\text{MOD}\n其中:b^{-1}为b的乘法逆元"},"ACM/算法/数论/快速组合数":{"slug":"ACM/算法/数论/快速组合数","filePath":"ACM/算法/数论/快速组合数.md","title":"快速组合数","links":[],"tags":[],"content":"通过预处理阶乘 + 逆元的方式快速计算\\begin{pmatrix}n \\\\ k\\end{pmatrix},在计算大组合数时候采用,在数字大于模数时候采用 Lucas 定理\n\n\n                  \n                  Lucas 定理 \n                  \n                \n\n\n对于质数p有组合数公式\nC(n,k) = \\frac{n!}{k!(n-k)!} \\pmod p\n当n &lt; p 时候可以直接使用阶乘求:\nC(n,k) = fac[n]\\cdot inv\\_fac[k]\\cdot inv\\_{[n-k]} \\bmod p\n当n \\geq p时候,Lucas定理告诉我们:\nC(n,k) \\bmod p = C\\left(\\left\\lfloor \\frac{n}{p}\\right\\rfloor,\\left\\lfloor \\frac{k}{p}\\right\\rfloor \\right) \\cdot C(n\\bmod p , k \\bmod p) \\bmod p\n\n\n\n下面给出板子:\nksm板子需自己补全\nstruct Comb\n{\n    vector&lt;i64&gt; fac, inv_fac;\n    i64 MAX_N;\n    Comb(i64 MAXK)\n    {\n        MAX_N = MAXK;\n        fac.resize(MAX_N);\n        inv_fac.resize(MAX_N);\n        init();\n    }\n    // 预处理 [0, MOD-1] 阶乘及逆元\n    void init()\n    {\n        fac[0] = 1;\n        for (i64 i = 1; i &lt; MAX_N; i++) fac[i] = fac[i - 1] * i % MOD;\n        inv_fac[MAX_N - 1] = ksm(fac[MAX_N - 1], MOD - 2);\n        for (i64 i = MAX_N - 2; i &gt;= 0; i--) inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD;\n    }\n    // 计算 C(n, k) mod MOD，要求 n, k &lt; MOD\n    inline i64 C_small(i64 n, i64 k)\n    {\n        if (k &lt; 0 || k &gt; n) return 0;\n        return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD;\n    }\n    // Lucas 定理递归求解大组合数\n    inline i64 C(i64 n, i64 k)\n    {\n        if (k &lt; 0 || k &gt; n) return 0;\n        if (n &lt; MOD &amp;&amp; k &lt; MOD) return C_small(n, k);\n        return C(n / MOD, k / MOD) * C_small(n % MOD, k % MOD) % MOD;\n    }\n    inline i64 A(int n, int k) const\n    {\n        if (k &lt; 0 || k &gt; n) return 0;\n        return fac[n] * inv_fac[n - k];\n    }\n};"},"ACM/算法/数论/整除分块":{"slug":"ACM/算法/数论/整除分块","filePath":"ACM/算法/数论/整除分块.md","title":"整除分块","links":["ACM/算法/数论/约数"],"tags":[],"content":"我们在这里主要聊的是 整除分块 ,这是求解形如\n\\sum\\limits^{n}_{i=1} f\\left(\\left\\lfloor \\frac{n}{i} \\right\\rfloor\\right)\n这类涉及到 整除 或 取整 的求和问题,其核心思想是:对于固定的n,\\left\\lfloor \\frac{n}{i} \\right\\rfloor的值在一定区间内是相同的,我们可以将这些 i 连续区间优化为一次处理\n对一个固定的 n ,我们考虑其表达式\nk = \\left\\lfloor \\frac{n}{i} \\right\\rfloor\n当i增大时, \\dfrac{n}{i} 单调递减,故k是单调不增的\n对于某个确定的k,所有满足\\left\\lfloor \\frac{n}{i} \\right\\rfloor = k的i连续且可以用一个区间 [L,R] 表示\n现在我们来求这个区间\n\\begin{cases}\nk = \\left\\lfloor \\frac{n}{i} \\right\\rfloor  \\\\\n\\iff k \\le \\frac{n}{i} &lt; k+1 \\\\\n\\iff \\frac{n}{k+1} &lt; i \\leq \\frac{n}{k}\n\\end{cases}\n因此:\nL = \\left\\lfloor \\frac{n}{k+1} \\right\\rfloor + 1\n\\quad \nR = \\left\\lfloor \\frac{n}{k} \\right\\rfloor\n在遍历的时候我们更倾向于使用 R\n显然对于向上取整我们也可以使用整除分块来优化复杂度,我们可以转化为 \\left\\lfloor  \\frac{n + i - 1}{i} \\right\\rfloor 来进行整除分块\n遍历方法\n整除分块的标准做法是:\n从小到大遍历 i ,一次跳过所有 n/i 相等的区间\n模板\nfor(i64 l = 1,r;l &lt;= n; l = r + 1){\n\ti64 k = n / i;\n\tr = n / k;\n\t// code for solution\n}\n \n// 对于向上取整\nfor(i64 l = 1,r;l &lt;= n;l = r + 1){\n\ti64 k = (n + l - 1) / l;\n\tif(l == 1){\n\t\tr = 1;\n\t}\n\telse{\n\t\tr = max(n,(n - 1)/(k - 1));\n\t}\n\t// code here\n}\n \n\n\n                  \n                  Tip\n                  \n                \n\n\n注意整除分块中每一个循环都是一段区间的内容,所以不要忘记处理完成后将结果乘上区间长度r - l + 1\n\n\n\n一个例子,可以看下面计算约数计数和\nTransclude of 约数#solution1\n另外一种形式的分块\n这种形式的分块主要是以下类型\n\\sum\\limits_{i=1}^{n}\\left\\lfloor  \\right\\rfloor"},"ACM/算法/数论/斯特林数,欧拉数":{"slug":"ACM/算法/数论/斯特林数,欧拉数","filePath":"ACM/算法/数论/斯特林数,欧拉数.md","title":"斯特林数,欧拉数","links":["ACM/算法/数论/快速组合数","ACM/算法/快速幂"],"tags":[],"content":"第一类斯科特数\n\n第一类斯科特数 c(n,k) 表示 将n个不同元素排列成恰好k个”循环”的排列数\n\n对于循环,我们可以理解为\\{1,2,3\\}与\\{2,3,1\\} 与\\{3,2,1\\}均为一类循环,因为将这些数无限写下去的形式上是一致的\n\\{\\cdots,\\textcolor{blue}{1,2,3},1,\\textcolor{red}{2,3,1},2,\\textcolor{green}{3,1,2},\\cdots\\}\n例子\n\nc(3,1) = 2,即所有3!排列都在一个大循环中,此时有两种方案{(1,2,3),(1,3,2)}\nc(3,2) = 3,此时有 (1)(2,3) | (2)(1,3) | (3)(1,2) 这样的组合方式\nc(3,3) = 1,此时每个元素各自组成一个循环\n\n第一类斯科特数递推公式\nc(n,k) = c(n - 1,k -1 ) + (n - 1)\\cdot c(n-1,k)\n其中递推的初始条件我们规定为\n\nc(0,0) = 1 \\text{ , } c(n,0) = 0(n &gt; 0) \\text{ , }c(0,k) = 0(k&gt;0)\n\n上面为无符号第一类斯科特数的递归方式 如果想获得有符号类的可以使用 s(n,k) = (-1)^{n-k}c(n,k)方式得到\n应用:\n\n在排列的循环结构或者有向图的环的计数中使用\n在阶乘多项式展开中使用\n\nx^{\\underline{n}} = x(x-1)\\cdots(x-n+1) = \\sum\\limits^{n}_{k=0}s(n,k)s^k\n\n其中 s(n,k)即有符号的第一类斯科特数\n\n第二类斯科特数\n\n第二类斯科特数 S(n,k) 表示将 n 个不同元素划分为恰好 k 个非空无序集合的方案数\n\n对与三个不同元素{1,2,3}划分\n\nS(3,1) = 1 ,即所有元素处于一个集合中\nS(3,2) = 3:\n\n\\{\\{1\\},\\{2,3\\}\\},\\{\\{2\\},\\{1,3\\}\\},\\{\\{3\\},\\{1,2\\}\\}\n\n\n\n对第二类斯特林数有递推公式\nS(n,k) = S(n-1,k-1) + k\\cdot S(n-1,k) \n\n初始条件我们规定\nS(0,0) = 1 \\text{ , } S(n,0) = 0(n &gt; 0) \\text{ , }S(0,k) = 0(k&gt;0)\n\n对与第二类斯特林数,我们有显式公式:\nS(n,k) = \\frac{1}{k!} \\sum_{i=0}^{k} (-1)^i \\binom{k}{i} (k-i)^n\n可以在O(k)复杂度下计算出其值,可以结合快速组合数与快速幂计算,在最后给出板子\n第一类欧拉数\ni64 ksm(i64 a, i64 b, i64 mod = MOD)\n{\n    i64 res = 1;\n    while (b) {\n        if (b &amp; 1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n \nstruct Stirling\n{\n    vector&lt;i64&gt; fac, inv_fac;\n    i64 MAX_N;\n    Stirling(i64 MAXK)\n    {\n        MAX_N = MAXK;\n        fac.resize(MAX_N);\n        inv_fac.resize(MAX_N);\n        init();\n    }\n    // 预处理 [0, MOD-1] 阶乘及逆元\n    void init()\n    {\n        fac[0] = 1;\n        for (i64 i = 1; i &lt; MAX_N; i++) fac[i] = fac[i - 1] * i % MOD;\n        inv_fac[MAX_N - 1] = ksm(fac[MAX_N - 1], MOD - 2);\n        for (i64 i = MAX_N - 2; i &gt;= 0; i--) inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD;\n    }\n    // 计算 C(n, k) mod MOD，要求 n, k &lt; MOD\n    inline i64 C_small(i64 n, i64 k)\n    {\n        if (k &lt; 0 || k &gt; n) return 0;\n        return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD;\n    }\n    // Lucas 定理递归求解大组合数\n    i64 C(i64 n, i64 k)\n    {\n        if (k &lt; 0 || k &gt; n) return 0;\n        if (n &lt; MOD &amp;&amp; k &lt; MOD) return C_small(n, k);\n        return C(n / MOD, k / MOD) * C_small(n % MOD, k % MOD) % MOD;\n    }\n    i64 A(int n, int k) const\n    {\n        if (k &lt; 0 || k &gt; n) return 0;\n        return fac[n] * inv_fac[n - k];\n    }\n    // 第二类斯特林数的显式表示\n    i64 get_Stirling(int n, int k)\n    {\n        if (k &lt; 0 || k &gt; n) return 0;\n        i64 res = 0;\n        for (int i = 0; i &lt;= k; ++i) {\n            i64 term = C(k, i) * ksm(k - i, n) % MOD;\n            // 符号： (-1)^i，根据公式 S(n,k) = 1/k! * sum_{i=0..k} (-1)^i C(k,i) (k-i)^n\n            if (i &amp; 1)\n                res = (res - term + MOD) % MOD;\n            else\n                res = (res + term) % MOD;\n        }\n        res = res * inv_fac[k] % MOD; // 除以 k!\n        return res;\n    }\n    // 第二类欧拉数计算\n    i64 sec_Eulr(int n, int k)\n    {\n        return (get_Stirling(n, k) * fac[k]) % MOD;\n    }\n};\n\n其实就是在快速组合数上进行了添加\n"},"ACM/算法/数论/约数":{"slug":"ACM/算法/数论/约数","filePath":"ACM/算法/数论/约数.md","title":"约数","links":["ACM/算法/数论/整除分块"],"tags":[],"content":"约数个数和定理\n我们记 d(i) 为 数 i 的约数个数,存在等式\n\\sum\\limits^{n}_{i = 1}d(i) = \\sum\\limits^{n}_{i = 1}\\left\\lfloor \\frac{n}{i} \\right\\rfloor\n这个等式的证明如下\n记二重计数集合 S = \\{(a,b) \\in \\mathbb{Z}{}^{2}_{\\geq1}: ab \\leq n\\}\n含义为两个大于1的正整数a,b其乘积小于等于n我们需要得知的即为|S|\n按积分组角度\n对于每一个i \\in [1,n],将所有满足 ab = i的有序对计入S,这个有序对个数正好就是d(i),将i = 1到n累加有:\n|S| = \\sum\\limits^{n}_{i=1}d(i) \\tag{1}\n按固定的a 角度\n固定a \\in [1,n],则满足条件的b的个数是满足 ab \\leq n的个数,即:\n\\{b | b \\geq1 \\text{ and } b \\leq \\frac{n}{a}\\} = \\left\\lfloor \\frac{n}{a} \\right\\rfloor \n累加有:\n|S| = \\sum\\limits^{n}_{a=1} \\left\\lfloor \\frac{n}{a} \\right\\rfloor \\tag{2}\n而这两个计数的是同一个集合,结合(1),(2)可证\n\\boxed{\\sum\\limits^{n}_{i = 1}d(i) = \\sum\\limits^{n}_{i = 1}\\left\\lfloor \\frac{n}{i} \\right\\rfloor}\n\n\n                  \n                  Tip\n                  \n                \n\n\n在具体计算的时候有时由于 n 过大,我们还需要将算法复杂度从 O(n) 降低到 O(\\sqrt{n}),具体操作可以使用 整除分块\n\n\n\nSolution1\nvoid solve()\n{\n    i64 n;\n    cin &gt;&gt; n;\n    i64 ans = 0;\n    // 注意for中 l 应该是 跳入到下一个块中\n    for (i64 l = 1, r; l &lt;= n; l = r + 1) {\n        // 当前一个区间的整除数\n        i64 k = n / l;\n        // 计算块右边界\n        r = n / k;\n        // 计算结果(不要忘记块长)\n        ans += k * (r - l + 1);\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}"},"ACM/算法/最长回文子序列":{"slug":"ACM/算法/最长回文子序列","filePath":"ACM/算法/最长回文子序列.md","title":"最长回文子序列","links":["tags/字符串","tags/模板","tags/模拟"],"tags":["字符串","模板","模拟"],"content":"字符串 模板 模拟\n最长回文子序列\n\n给定一个字符串 s , 求 s 的最长回文子序列\n\n1 模拟暴力法\n\n通过一个二维数组遍历原字符串的所有子串\n逐一判断该子串是否为回文串\n更新最长子串\n\n#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nstring huiwen(const string &amp;s, int back, int front)\n{\n    int idx_b = back;\n    int idx_f = front;\n    while (idx_b &gt; idx_f) {\n        if (s[idx_f] != s[idx_b]) {\n            return s.substr(0,1);\n        }\n        idx_f++;\n        idx_b--;\n    }\n    string res;\n    for (size_t i = front; i &lt;= back; i++) {\n        res += s[i];\n    }\n    return res;\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    string ans = &quot;&quot;;\n    if(s.size() &lt;= 1){\n        cout &lt;&lt; s;\n    }\n    for (size_t i = 0; i &lt; s.size(); i++) {\n        for (size_t j = i + 1; j &lt; s.size(); j++) {\n            string temp = huiwen(s, j, i);\n            ans = (temp.size() &gt; ans.size() ? temp : ans);\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n\n这个算法的复杂度来到了惊人的O(n^3),令人汗颜，数据量在10^3就能直接让OJ爆TLE\n\n2 中心扩展算法\n中心算法的三个核心步骤\n\n1.选择中心：对于一个长度为 n 的字符串，其拥有  2n - 1 个中心结点（即长度为奇数的回文子串结点有n个，长度为偶数的回文子串的结点有n-1个\n2.扩展回文：对于每个选定的中心，尝试向两边扩展，直到无法形成回文为止\n3.更新结果：在每次成功扩展后，计算当前回文的长度，并与已知的最大回文长度进行比较。如果更长，则更新最大回文及其起始位置\n\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nint expandAroundCenter(const string &amp;s, int left, int right)\n{\n    while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) {\n        left--;\n        right++;\n    }\n    return right - left - 1;\n}\n \nstring longestPalindrome(const string &amp;s)\n{\n    if (s.empty()) return &quot;&quot;;\n    int start = 0;\n    int end = 0;\n    for (size_t i = 0; i &lt; s.size(); i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = max(len1, len2);\n        if (len &gt; end - start) {\n            end = i + len / 2;\n            start = i - (len - 1) / 2;\n        }\n    }\n    return s.substr(start, end - start + 1);\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; longestPalindrome(s) &lt;&lt; endl;\n    return 0;\n}\n\n此时时间复杂度已经降至 O(n^2) ，空间复杂度降低至O(1) ,已经绝杀大部分算法\n\n3 Manacher’s Algorithm\n\n很抱歉没能让manacher大人尽兴\t——by 中心扩展算法\n\n\n\nManacher’s Algorithm(马拉车算法)是一种高效解决最长回文子串的算法，其提供一个O(n)复杂度下的方法来实现对回文子序列的查找\n\n核心思想\n回文串的对称性： 假设已经计算出了以某个位置为中心的回文串的半径（即该回文串两边的最大扩展长度），那么与其对称的部分的回文半径也可以直接推算出来\n预处理：将原字符串进行预处理，以避免处理奇数长度和偶数长度回文的不同情况。通常的做法是在每个字符之间插入一个特殊字符（如 #），并在字符串的开头和结尾添加不同的特殊字符（如 ^ 和 $）。这样处理后的字符串长度一定是奇数，且不会出现冲突。\n动态维护最远回文边界：在扩展时，维护一个“右边界” R 和一个“中心” C，C 代表回文串的中心位置，R 代表回文串的最右边界。当当前处理的位置 i 位于 R 的范围内时，可以利用已知的对称性质来减少计算。\n\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \n//预处理\nstring preprocess(const string &amp;s)\n{\n    string t = &quot;^&quot;;\n    for (char c : s) {\n        t += &quot;#&quot; + string(1, c);\n    }\n    t += &quot;#$&quot;;\n    return t;\n}\n \nstring longestPalindrome(const string &amp;s)\n{\n    string T = preprocess(s);\n    int n = T.size();\n    vector&lt;int&gt; P(n, 0); //P[i] 记录以 t[i] 为中心的回文半径\n    int C = 0, R = 0;    //C 是回文中心，R 是回文串的最右边界\n    for (size_t i = 1; i &lt; n - 1; i++) {\n        // 确定对称位置\n        int Mirror = 2 * C - i;\n        if (i &lt; R) {\n            P[i] = min(P[Mirror], R - i);\n        }\n        // 尝试扩展边界\n        while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) {\n            P[i]++;\n        }\n        // 如果当前回文串扩展超过了 R，更新中心和右边界\n        if (i + P[i] &gt; R) {\n            C = i;\n            R = i + P[i];\n        }\n    }\n    // 找到最长的回文子串\n    int maxLen = 0;\n    int Centerindex = 0;\n    for (size_t i = 0; i &lt; n - 1; i++) {\n        if (P[i] &gt; maxLen) {\n            maxLen = P[i];\n            Centerindex = i;\n        }\n    }\n    // 构造回文串\n    int start = (Centerindex - maxLen) / 2;\n    return s.substr(start, maxLen);\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; longestPalindrome(s) &lt;&lt; endl;\n    return 0;\n}\n\n"},"ACM/算法/杂项笔记/杂项练习笔记1":{"slug":"ACM/算法/杂项笔记/杂项练习笔记1","filePath":"ACM/算法/杂项笔记/杂项练习笔记1.md","title":"杂项练习笔记1","links":["ACM/算法/扩展欧几里得算法"],"tags":["杂项练习","函数类","STL"],"content":"杂项练习\n0 点子王\n\n万能头文件 #include&lt;bits/stdc++.h&gt;(可以解决大部分头文件问题)\n使用 printf(&quot;%.2f&quot;,[输出])来输出保留两位的小数\n小写字母的ASCII码是大写字母的ASCII + 32\n在处理时间问题时，我们不妨全部转化为最小的时间单位，再用循环回复时间格式\n字符串/字符 进行比较的时候要用stramp(a,b)\n\n当 str1 &lt; str2 时，返回为负数(-1)；\n当 str1 == str2 时，返回值= 0；\n当 str1 &gt; str2 时，返回正数(1)。\n\n\n\n\n\n\n                  \n                   \n更新：对字符串来说也可以用 == 符号判等 ——&gt; 甚至可以扩展到vector上\n                  \n                \n\n\n\n使用stoi()函数将字符串强转为整型\nint i = char(数字) - &#039;0&#039;i即为字符型数字的整型\nchar i = int(整型) + &#039;0&#039;i即为整型数字的字符型\n在解题的时候切忌只用算法硬算，理解数学思路并简化题目非常重要\n使用getline()函数获取长字符串 getline(cin,str)\n主要当 cin&gt;&gt;和 getline()一起使用的时候要使用如下代码删除getline缓存：\n\n int n = 0;\n    cin &gt;&gt; n;\n    string str;\n    getline(cin,str);\n    str = &quot;\\n&quot;;\n    getline(cin,str);\n\n\n比较器函数初识\n\n\nless&lt;类型&gt;表示升序排列[由小到大][^6]\n\n\ngreater&lt;类型&gt;表示降序排列[由大到小]\n\n\nstring也是可以比大小的，会按照字典序来比较大小\n\n\n关闭同步流，获得最速输入输出 ！关闭同步流后cin和cout不能和printf和scanf混用\n\n\nios::sync_with_stdio(0),cin.tie(0),cout.tie(0);[取消同步流]\n\n\n#pragma GCC optimize(2)在文件头添加这个实现O2优化\n\n\n判断一个除法除出来的数是不是整数推荐使用取模法 if((a*c)%b == 0) cout &lt;&lt; &quot;is intnum&quot; (血泪教训见下)\n\n\n神奇函数：在C和 C+++中，toupper 函数用于将小写字母转换为其对应的大写字母。这个函数定义在&lt;cctype.h&gt;或&lt;ctype.h〉头文件中。\n\n\n当某一个数据经常更新(比如说判断max值)我们可以将：\n\nif(i &gt; max0) max0 = i 改为 max0 = max(max0,i)\n同理 ：if(i &lt; min0) min0 = i改为 min0 = min(min0,i)\n\n\n\n结构体在初始化vector&lt;int&gt;这类特殊特殊变量的时候，可以使用显式调用来初始化容器\n\n\n\n  struct st{\n      vector&lt;int&gt; a = vector&lt;int&gt;(6,0);\n  }\n1.printf 和 scanf为格式化输出输入函数\n\n基本语法为\nprintf(&quot;输出控制符&quot;,输出参数)\nscanf(&quot;输入控制符&quot;，输入参数)\n其中常用的输入(输出)控制符有：\n\n\n​     %a(%A)     浮点数、十六进制数字和p-(P-)记数法(C99)\n​      %c             字符\n​      %d             有符号十进制整数\n​      %f              浮点数(包括float和doulbe)\n​      %e(%E)     浮点数指数输出[e-(E-)记数法]\n​      %g(%G)     浮点数不显无意义的零”0”\n​      %i              有符号十进制整数(与%d相同)\n​      %u             无符号十进制整数\n​      %o             八进制整数    e.g.     0123\n​      %x(%X)      十六进制整数0f(0F)    e.g.   0x1234\n​      %p             指针\n​      %s             字符串\n​      %%            ”%”\n\n\n\n                  \n                  Note\n                  \n                \n\n\n\nprintf 和 scanf 都可以支持多位输入(输出)\n\nscanf(&quot;%1d%1d&quot;,&amp;a,&amp;b)就代表输入两个1位数字(两位数)，第一个赋值到a,第二个赋值到b (&amp;为取址符)\n\nscanf 读取字符串的时候不用加寻址符\nscanf不能读取 string str格式的字符串\n\n\n\n\n\n例子：我们可以用 printf&amp;scanf实现数字位数的获取来简化优化程序\n优化前\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    float a = 114.5;\n    cin &gt;&gt; a ;\n    int b = a*10;\n    float c = b%10 + 0.1*((b/10)%10) + 0.01*((b/100)%10) + 0.001*(b/1000);\n    cout &lt;&lt; c;\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n优化后\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    int a;int b;int c;int d;\n    scanf(&quot;%1d%1d%1d.%1d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);\n    printf(&quot;%1d.%1d%1d%1d&quot;,d,c,b,a);\n    system(&quot;pause&quot;);\n    return(0);\n}\n2 取整函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数名称函数说明floor()不大于自变量的最大整数ceil()不小于自变量的最小整数round()四舍五入到最临近的整数fix()朝零方向取整\n\nfloor()朝负无穷方向取整\nceil()朝正无穷方向取整\nround()函数，才是我们需要的四舍五入的函数，因为它会返回离自变量最近的整数，这个返回的整数可能大于也可能小于原来的数，但是一定是离它最近的那个整数。\nfix() 朝零方向取整，正数向下去，负数向上取\n\n\n3 位运算(简单版)\n\ni&lt;&lt;1 等同于 i*2\ni&gt;&gt;1等同于i/2\n\n4 sort()排序函数\n\nsort()可以用一行实现数组的排序，而且可以实现从小到大，从大到小(甚至个位数从小到大之类的排序)的排序\nsort()函数的语法为 sort(begin,end,cmp),其中begin指向待sort数组的第一个元素的指针，end指向待sort数组的最后一个元素的下一个位置的指针\ncmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序\n如果我们想从大到小排序可以将cmp参数写为greater&lt;int&gt;()就是对int数组进行排序，当然&lt;&gt;中我们也可以写double、long、float等等\n例：从小到大\n\nint main()\n{\n    int num[10] = {5,8,9,7,6,8,4,2,7,6};\n    sort(num,num+10);\n    for(int i=0;i&lt;10;i++)\n    {\n\t\tcout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;\n\t}\n}\n例：从大到小\nint main()\n{\n    int num[10] = {5,8,9,7,6,8,4,2,7,6};\n    sort(num,num+10,greater&lt;int&gt;());\n    for(int i=0;i&lt;10;i++)\n    {\n\t\tcout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;\n\t}\n}\n\n==cmp的编写规则==\n\n\ncmp函数的返回值是bool值\ncmp传入的参数为(待排序的第一个类型&amp; a，待排序的第二个类型&amp; b)\ncmp里 return a &gt; b指降序排序 (从大到小)\n\n\n例给无法排序的map排序\n\nbool cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b){\n    return a.first &gt; b.first;\n}\nint main()\n{\n   \tmap&lt;int,int&gt; arr;\n\tvector&lt;pair&lt;int, int&gt;&gt; temp(arr.begin(),arr.end());\n}\n其实cmp的排序可以这么理解：\nbool cmp(const &lt;Type T&gt; &amp;a , const &lt;Type T&gt; &amp;b ){\n    return a &gt; b; //降序排列\n    //......\n}\n\n\n                  \n                  Tip\n                  \n                \n\n\nbool 类型的函数返回的是一个bool值，所以return回去的是一个bool值，传入的参数是 a,b 如果bool值为 1 ，则说明这个a b的顺序无需改变，如果传入的是0，则说明需要改变\n注意：实际上cmp的规则并非如此，当我们不做任何判断直接返回1的话，数组会被倒序排序，而0则是没有任何改变\n\n\n\n5 __gcd求最大公约数函数\n格式：__gcd(a,b)返回值为a，b的最大公因数\n头文件：#include&lt; algorithm&gt;\n实现:\n\n欧几里得算法\n\nint main() \n{\n    int a,b,r;\n    cin &gt;&gt;a&gt;&gt;b;\n    //求x 和 y 的最大公约数，就是求 y 和 x % y 的最大公约数\n    while (a%b!=0) //判断a能否整除b\n    {\n        //开始循环找数\n        //判断余数能否被被除数整除\n        //循环到1\n        r=a%b; \n        a=b;\n        b=r;    \n    }\n    cout &lt;&lt; b;\n    return 0;\n}\n\n还存在一种扩展欧几里得算法，用于求出方程\\gcd(a,b)与方程ax + by = gcd \\left({a,b}\\right) 的一组(x_0，y_0)\n\n6 字符与字符串\n\n字符串本质是一个数组，因此我们可以用str(字符串)[下标]的方式访问字符串的子字符，而下标从”0”开始计数\n字符串的两种表示方式中，scanf()和printf()都无法访问 string str[^3]形式的字符串\n可以用str.size();的方式访问字符串长度(注意字符串最后会存在一个空字符，所以实际长度会比str.size输出的长度多一)\n使用强转函数 to_string可以时整型变为字符串型\n我们可以使用 str.empty()来判断一个字符串是否为空，若为空，该函数会返回一个 True 的bool值，否则返回 False\nstr.clear()可以帮我们愉悦的删掉有效字符(但str.clear不会改变底层空间(capacity)的大小)\n我们可以用 str.capacity()的方式查看字符串的底层空间大小\n\n其实字符串(string类型)采用动态数组作为底层实现，它会为字符串提前预留一些额外的储存空间来减少内存的分配与释放次数\n\n\n\n7 vector 容器 / 动态数组\n\n使用 vector&lt;int&gt; vec[^4]的方式来创建一个动态数组\n对于 vector的赋值，不能直接使用cin &gt;&gt; vec[i] 的方式，我们可以建立一个临时变量，用 vec.push_back(temp)的方法输入值\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n9.17修改 ：对于使用 vector&lt;int&gt; dp(a,b)形式的vec可以使用cin输入\n\n\n\n\n对 vector容器的排序，我们必须使用迭代器来确定其数据位置，不能使用”+“确定位置\n\n\n\n所以我们可以这样输入语法\nsort(vec.begin(),vec.end())\n\n\n使用 vec[i]来获取第 i - 1个元素(从零计数)\n\n8 栈(stack)\n\n栈是一种线性储存结构，其元素遵守先进后出的规则\n只能在栈顶进行元素的添加和删除(进栈和出栈)\n使用stack&lt;int&gt; st创建一个栈\n对栈常见的操作有：\nempty(): 判断栈是否为空栈，如果为空栈返回true， 否则或者false\npush(): 进栈操作，将新的元素放入到栈中，新的元素成为栈顶元素。\npop()： 出栈操作，栈顶元素从栈中离开\ntop(): 获取栈顶元素，但是不会移除它\nsize(): 获取栈的长度，即栈中元素的数量\n\n9 宏常量定义小寄巧\n打勾的就是好用的\n\n  #define endl &quot;\\n&quot;\n #define int long long\n\n\n\n                  \n                  WARNING\n                  \n                \n\n\n使用这个的时候 int main()要改为 signed main()\n\n\n\n\n #define double long double\n\n10 数组前导零与后导零的删除\n\n有的时候我们会用vis记录某一数据的增量和变化，到最后进行增量的排序\n但是这个时候vis里没有在数据范围里的数据就是 0 这给我们sort数组带来极大的困惑\n\nwhile(*arr.begin() == 0) arr.erase(arr.begin);\nwhile(*(arr.end()-1) == 0) arr.erase(arr.end()-1);\n\n我们可以使用这样的代码删除数组中的前后导零\n\n11 位运算抽象版\n\n\n                  \n                  Important\n                  \n                \n\n\n位运算虽然在卡常时可以发挥一些优化作用，但其会导致代码可读性下降至一个难以理解的程度\n\n\n\n\n用位运算代替 *=2 /=2 的操作\n\nint a = 10; (a &lt;&lt;= 2) == (a*=2); (a &gt;&gt;= 2) == (a/=2)\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n对位运算来说，左移右移都是改变二进制位的操作，比如我们可以这么理解\n\\begin{split}\n设某一数x\\\\\nx_2 &amp;= tttttt\\\\\nx &lt;&lt; s &amp;= tttttt\\underbrace{0000 \\ldots 00}_{s}\\\\\n则 x_{10} &amp;= x \\times 2^s\n\\end{split}\n同理，右移就是x_{10} = \\frac{x}{2^s} \n\n\n\n\n用位运算代替swap()\n\n    int a = 5 , b = 2;\n    a ^= b, b^=a, a^=b;\n    //swap(a,b)\n\n\n                  \n                  Tip\n                  \n                \n\n\n^运算，即 **异或(XOR)**运算，比较两个值的二进制位，如果两个值相同，则结果为假，如果两个值相同，则结果为真\n推理：\n\n第一次异或运算：A = A ^ B\n\n这一步将 A 和 B 的值进行异或运算，并将结果存储在 A 中。\n此时，A 包含了 A 和 B 的异或结果，而 B 仍然是原来的值。\n\n\n第二次异或运算：B = A ^ B\n\n由于 A 现在包含了 A 和 B 的异或结果，我们将这个结果与 B 进行异或运算，并将结果存储在 B 中。\n这一步实际上是将 B 的原始值与 A 和 B 的异或结果进行异或运算，这将导致 B 现在包含 A 的原始值。\n\n\n第三次异或运算：A = A ^ B\n\n现在 B 包含了 A 的原始值，我们将 A（包含 A 和 B 的异或结果）与 B（现在包含 A 的原始值）进行异或运算。\n这一步将导致 A 现在包含 B 的原始值。\n\n\n\n\n\n\n\n\n取出二进制的某一位\n  int a = 15;\n  for(int i = 31;i &gt;= 0 ;--i) cout &lt;&lt; (x &gt;&gt; i &amp; 1);\n\n怎么实现的呢？\n从31位开始向前将a的每一个二进制位与 1 做与位操作\n与位操作即：\n\n如果两个比较的位都是1，则结果位是1。\n如果两个比较的位中至少有一个是0，则结果位是0。\n那么与 1 做&amp;操作的二进制位则必然会等于其本身\n\n\n\n\n优化版：\n\n\nvector&lt;int&gt; arr;\nint a = 15;\nfor(int i = 31;i &gt;= 0 ;--i) arr.push_back(a &gt;&gt; i &amp; 1);\nwhile(!*arr.begin()) arr.erase(arr.begin());\nfor(auto &amp;&amp;i : arr) cout &lt;&lt; i;\n\n实现了前导零的删除\n用异或判断两变量是否相等\n\nint a = 10,b = 5;\nif(a^b) cout &lt;&lt; &quot;不相等&quot;；\nelse cout &lt;&lt;&quot;相等&quot;；\n\n使用^48实现int和char的转化\n\nint a = 6;\nchar ch = x^48;\ncout &lt;&lt; ch &lt;&lt; endl;\n//同理char变int也可以用^48\nint y = ch^48;\ncout &lt;&lt; y;\n\n用&amp;1判断函数奇偶性\n\nint a = 7;\nif(a&amp;1)\n{\n\tcout &lt;&lt; &quot;奇数&quot; &lt;&lt;endl;   \n}\nelse\n{\n\tcout &lt;&lt; &quot;偶数&quot; &lt;&lt;endl;\n}\n12 时间函数帮你计算运算时间\nclock_t st = clock();\n//代码......\nclock_t ed = clock();\ncout &lt;&lt; &quot;time: &quot; &lt;&lt; ed - st &lt;&lt;&quot; ms&quot;&lt;&lt;endl; \n13 一组数的各种数计算\n\n对一组数据而言，对其分布有影响的数据类型有: \\to 平均数 ， 中位数\n\n平均数：\nint sum = 0;\nfor(int i = 0; i &lt; arr.size() ; i++){\n    sum += arr[i];\n}\ndouble tnum = (sum/n*1.0);\n中位数：\nvector&lt;int&gt; arr(n);\ndouble cent = 0;\nsort(arr.begin(),arr.end());\nif(arr.size()%2 == 1) cent = arr[n/2 + 1];\nelse cent = (arr[n/2 + 1] + arr[n/2]*1.0)/2; \n//数组从0开始技术的时候，要注意下标减一\nif(arr.size()%2 == 1) cent = arr[n/2 + 1 - 1];\nelse cent = (arr[n/2 + 1 - 1] + arr[n/2 - 1]*1.0)/2; "},"ACM/算法/杂项笔记/杂项练习笔记2(codeforces)(详细ver)":{"slug":"ACM/算法/杂项笔记/杂项练习笔记2(codeforces)(详细ver)","filePath":"ACM/算法/杂项笔记/杂项练习笔记2(codeforces)(详细ver).md","title":"杂项练习笔记2(codeforces)(详细ver)","links":["tags/杂项练习","tags/codeforces","ACM/算法/杂项笔记/杂项练习笔记4(codeforces)(简单ver)","tags/数学","tags/二进制","ACM/算法/二进制","tags/数论"],"tags":["杂项练习","codeforces","数学","二进制","数论"],"content":"杂项练习 codeforces\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n这是对codeforces里不会的题的详细题解,在自己平均水平之上，所以会比较详细\n对于较为简单的题，可以参阅杂项练习笔记4(codeforces)(简单ver)\n\n\n\n\n同时取模两数相等的总个数\n数学\n\n对两个数 x_1,x_2 ，从 0 到 n 的所有数字中，存在 p 使得 p \\mod x_1 = p \\mod x_2 的所有 p 的个数 k 有\n\nk = \\left \\lfloor \\frac{\\left( n+1 \\right)}{\\operatorname{lcm}{(x_1,x_2)}}\\right \\rfloor \\cdot \\min(x_1,x_2) + \\begin{cases} \n(n + 1) \\bmod \\operatorname{lcm}(x_1, x_2) &amp; \\text{if } (n + 1) \\bmod \\operatorname{lcm}(x_1, x_2) &lt; \\min(x_1, x_2) \\\\\n\\min(x_1, x_2) &amp; \\text{otherwise}\n\\end{cases}\n\n可以精简为：\n\nk = \\left\\lfloor \\frac{n+1}{\\operatorname{lcm}(x_1, x_2)} \\right\\rfloor \\cdot \\min(x_1, x_2) + \\min\\left( (n+1) \\bmod \\operatorname{lcm}(x_1, x_2), \\min(x_1, x_2) \\right)\n用代码表示为：\n k = ((n + 1) / lcm(x1,x2)) * min(x1,x2) + min((n+1)%lcm(x1,x2),min(x1,x2))\n\nEducational Codeforces Round 175 (Rated for Div. 2) A\n\n对R1009.D3.C 异或解题思考\n数学 二进制\n\nCodeforces Round 1009 (Div. 3) C. XOR and Triangle \n\n原题目的要求是给定一个数 x ，要求找到一个 y 使得：\n\nx + y &gt; x \\oplus y \\qquad (1)\ny + x \\oplus y &gt; x \\qquad (2)\ny &lt; x \\qquad \\qquad \\quad \\ \\ (3)\n有一个知识点：加法可以用位运算表示，即：\nx + y = \\left(x \\oplus y\\right) + 2 \\left( x\\,\\&amp;\\, y \\right)\n则题式就可以表示为：\n\n\\begin{split}\nx + y &amp;&gt; x \\oplus y \\\\\n \\,\\ \\left(x \\oplus y\\right) + 2 \\left( x\\,\\&amp;\\, y \\right) &amp; &gt; x \\oplus y \\\\\n即:\\left( x\\,\\&amp;\\, y \\right) &amp;&gt; 0\n\\end{split}\n同理，对(2)式有原式：y + (x + y) - 2(x \\&amp; y) &gt; x 即 y &gt; x\\&amp;y\n\n即我们得到条件 \\left( x\\,\\&amp;\\, y \\right) &gt; 0 和 y &gt; x\\&amp;y\n对二进制位分析则不难发现：\n\ny 的二进制位必须包含一个 x 二进制位下的1 → 对应条件 (1)\ny 的二进制位必须包含一个 x 二进制位下的0 → 对应条件 (2)\n\n\n特殊情况分析：\n\n当 x = 2^n 时不存在y\n\nx = 2^n 即x只有最高位为1，此时对任意 y &lt; x 有 x \\&amp; y = 0 , 不符合条件1\n\n\n当 x 为全 1 数时不存在y (根据条件(2)显然)\n实现：\n\n\n对特殊情况，可以使用这个方法判断\n对非特殊情况，可以使用构造，构造y为x的二进制最高有效位-1\n\ny = 1 &lt;&lt; (31 - __bulitiz_clz(x)) - 1\n\n\n\n最大公约数(GCD)相关的优化问题\n数论\n问题\n\n考虑一个数组 A 你可以时数组里的每个元素同时加任意数d ,现在你需要找到数组中任意两个元素 a_i,a_j 使得 \\gcd(a_i,a_j) 最大\n\n正解是当我们选取k 使\nk = \\underset{A}{\\max}\\ a_i \\,-\\underset{A}{\\min} a_j \n\n知识点：对于任意整数 x,y ,有 \\gcd(x,y)|(y-x)\n换句话说，x和y的最大公约数总是能整除他们的差\n则对于任意一组数据a_i,a_j,其\\gcd(a_i + d,a_j + d)不可能大于\\left \\vert a_i - a_j \\right \\vert\n显然最大的\\left \\vert a_i - a_j \\right \\vert 为 \\underset{A}{\\max}\\ a_i \\,-\\underset{A}{\\min} a_j\n接下来，我们利用选取d的机会构造使得\n\n\\gcd(\\underset{A}{\\max}\\ a_i + d \\, ,\\, \\underset{A}{\\min} a_j + d) = \\underset{A}{\\max}\\ a_i \\,-\\underset{A}{\\min} a_j \n我们记\\underset{A}{\\max}\\ a_i = M \\,,\\underset{A}{\\min} a_j = m\n\n则我们构造一个d使得m + d \\equiv 0\\, \\left( \\mathrm{mod}(M-m)\\right) ,换句话说，我们得找到d使得m + d是M-m的倍数,则此时 M + d也为M-m的倍数\n换句话说，d  一定是存在且非负的\n以上，证明完毕\n\n\n来源：Codeforces Round 1014 (Div. 2) A. Kamilka and the Sheep\n\n数论之质数和gcd与lcm\n数论\n问题：\n给你一个整数 n ，存在两个数a,b满足 1 \\leq a &lt; b \\leq n 现在，我们称:\nF\\left(a,b\\right) = \\frac{\\mathrm{lcm}(a,b)}{\\gcd(a,b)}\n若 F(a,b) 为质数，则我们称这个数对是”有趣的”,现在我们想知道在满足1 \\leq a &lt; b \\leq n的条件下有多少”有趣的”数对\n思路：\n\n数论基础知识：a \\cdot b = \\gcd(a,b) \\cdot \\mathrm{lcm}(a,b)\n我们不妨将F(a,b)上下同乘\\gcd(a,b) 得到 F(a,b) = \\frac{a \\cdot b}{\\gcd^2{(a,b)}}\n设 x = \\gcd(a,b) \\cdot a \\ ,\\ y = \\gcd(a,b) \\cdot b\n现在F(a,b) = x \\cdot y\n因为F(a,b)为质数，即x \\cdot y为质数，根据质数性质，x,y必须是一个质数乘1\n\n因为 a &lt; b 且 x = \\gcd(a,b)\\cdot a 则 x = 1\n那么 y 为质数\n\n\n那么接下来，问题变为:\n\n计算数对(a,b) 中 a \\le \\gcd(a,b) &lt; \\gcd(a,b) \\cdot y \\le n 的数对\n\n\n我们将每个小于n质数y固定下来，\\gcd(a,b)则可以取1到\\left \\lfloor \\frac{y}{n} \\right \\rfloor的数\n即对于每个y,有\\left \\lfloor \\frac{y}{n} \\right \\rfloor个数对符合要求\n\n在 n \\le 10^7的数量下，必须先用埃式筛或欧拉筛提前准备质数数组，可以在最优O(N + \\pi(M)) 下完成\n\n其中N表示题目最大数据量，M表示测试数据最大数量\n其中\\pi(M)表示小于M的质数数量\n来自：CR1013 d3 E\n\n二分搜索技巧\n\n背景：\n给定数组 A,B ，对A里的每个元素a_i我们可以做下面这个操作：\n\n在B中选择一个元素b_j，使得 a_i&#039;= b_j - a_i\n问能不能实行若干次操作将数组A变为非递减序列\n\n\n思路：\n\n我们先对数组B进行排序，以便后续二分查找\n对与每个a_i我们希望其在操作后尽可能的小，以便后续成立\n对每一个a_i 我们的任务是找到一个最小的b_j使得b_j - a_i \\ge a_{i-1}\n二分上，我们使用\n\nlower_bound(iterator_1,iterator_2,T,cmp)\n\n对于这个传函数式的传参，返回的是第一个为flase的值\n\n则我们使用：\nlower_bound(all(b),-14,[](int k1,int k2){\n\treturn k1 - a[i] &lt; a[i-1];\n})；\n因为b数组已被排序，此时返回的就是b中不符合b_j - a_i &lt; a_{i-1}的最小的b_j 即满足b_j - a_i \\ge a_{i-1} 的最小的b_j ,而这正是我们所需要的\n\n对于每一个a_i 如果找不到b_j 则跳过\n如果原本a_i &lt; a_{i-1} 且操作后仍 b_j - a_i \\ge a_{i-1} 则是无解的，跳过\n其余则考虑在b_j - a_i 与 a_i 中找最小值\n最后检查排序即可，这里可以使用is_sorted函数\n来自：\nCR1003 d4 C_2\n\n贪心前缀和\n\n你有一个长度为n的数组A ,你现在可以执行下面操作直到数组为空\n\n选择一个数 a\n\n如果是 a_i&lt;0 ，则用 [a_1,a_2,\\ldots,a_{i - 1}]替换替换A(即删除以a_i开头的后缀)\n否则，将 A 替换为 [a_{i+1},a_{i+2},…,a_m] (即删除以 a_i 结尾的前缀)\n\n\n每次选择数时将数|a|加入分数中\n我们需要最后分数最大\n\n\n我们发现，每一次都是删除最左边的正数元素或删除最右边的负数元素从而获得最高的分数\n则我们依据正数和负数构造两个数组表示前缀和后缀，而这些前后缀只对其对应符号的数生效\n我们的答案就是找到么某个点使得其前缀加后缀最大\n并查集策略\n来自ECR117 d2 C\n\n\n你有一个长度为 n 的 排列数组 p，也就是说它包含了从 1 到 n 的所有整数，且不重复。\n接下来你会收到 n 个 查询，每个查询会把数组中某个位置的元素替换成 0(每个位置只会被替换一次)\n在每次查询之后，你要判断：最少需要多少次操作，才能把当前这个数组恢复成一个合法的排列（包含 1 到 n，每个数恰好一次）。\n允许的操作是：对于 1 \\sim n 中的任意一个数 i，可以 将数组的第 i 个位置的值替换成 i\n\n\n\n思路：\n\n假设我们缺失的数字为P_{d_i},我们知道最终的排列一定包含该数字，且该数字只能被放置在P_{d_i},则P_{P_{d_i}}的数字可能被丢失，而该数字也必须被包含在排列中，以此类推。当一个数被放置在已经缺失数的位置上时候，该过程结束\n\n\n我们只关心有哪些数会在一次修复中被涉及，我们考虑使用并查集或集合模拟\n这里给出使用集合模拟的解决方法：\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vint v(n);\n    for (auto &amp;&amp;i : v) {\n        cin &gt;&gt; i;\n        i--;\n    }\n    set&lt;int&gt; x;\n    for (int i = 0; i &lt; n; i++) {\n        int d;\n        cin &gt;&gt; d;\n        d--;\n        while (!x.contains(d)) {\n            x.insert(d);\n            d = v[d];\n        }\n        cout &lt;&lt; x.size() &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}\n\n其中核心操作为15-17行的操作\n\n维护一个集合X表示所有需要固定的位置\n输入其查询数字P_{d_i},查询P_{d_i}是否在集合X中\n若存在，说明已经有该位置，可以则输出集合大小\n若不存在，则说明X中一定会增加P_{d_i}这个位置\n\n此时将 P_{d_i} 赋值为 d_i 表示查询P_{d_i}的位置，直到可以在集合X中找到为止\n\n\n因为每一次的丢失会继承到下一次查询中，所以不需要清空集合\n若使用思路也是一样的，将P_{d_i} 与 d_i 设置在一个集合中并且赋值，知道可以在集合中找到P_{d_i}\n\n\n\n差分序列与反转下的最大值\n来自：\nCR1001 d1+2 C\n\n有一个数组 A  长度为 n ,可以执行任意次下面的两个操作\n\n反转数组\n用差值序列替换序列。形式上，操作后[a1,a2,…,an] 变为[a2−a1,a3−a2,…,an−an−1]\n你需要求所有运算后a中元素的可能的和的最大值\n\n\n思路：\n\n对操作(1),反转后不会对数组和产生任何影响\n对操作(2),构造一个差序对数组\\Delta A = [a_2​−a_1​,a_3​−a_2​,\\cdots,a_m​−a_{m−1}]\n\n显然对\\sum (\\Delta A) = a_m - a_1\n倘若我们先执行一遍操作(1) ,则\\sum (\\Delta A&#039;) = a_1 - a_m = -\\sum (\\Delta A)\n\n\n若对 A 执行 k 次差分(其中可以自由执行操作(1)来构造最大值)，最终得到的序列长度为 n - k,其元素和正好为其元素和恰好是原序列经过 k 次差分的总和,即S^{(k)} = \\underset{i = 1}{\\overset{n-k}\\sum}v_i\n\n证明1\n\n\n则我们选择k \\in \\{0 \\sim n-1\\}的\\max(S^{(k)})即可，特别的S^{(0)} = \\underset{i = 1}{\\overset{n}\\sum}a_i\n对于代码实现，直接模拟就可以\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vint v(n);\n    for (auto &amp;&amp;i : v) {\n        cin &gt;&gt; i;\n    }\n    int ans = accumulate(all(v), 0);\n    vint cur = v; //构造差序对数组\n    for (size_t i = 1; i &lt; n; i++) {\n        int m = cur.size();\n        int sum = 0;\n        vector&lt;int&gt; nxt(m - 1); // 下一个差序对数组\n        for (size_t k = 0; k + 1 &lt; m; k++) {\n            nxt[k] = cur[k + 1] - cur[k];\n            sum += nxt[k];\n        }\n        ans = max(ans, abs(sum));\n        cur.swap(nxt);\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n标答很简洁但是我写很多的难绷题目\n\n来自CR1022 d2 C\n\n题目大意:\n\n你有一个数组A，你可以选择一个数字放下标识\n\n这个标识可以左右移动\n当标识经过一个没有被标识经过的数时候就会将这个数加入到数组B中\n\n\n我们需要数组B按单调递减排序且B含有A的所有元素\n求最少需要放几个标识\n\n我的思路：\n\n先将数组A排序为数组B，再根据B的顺序去找A中的元素\n其中找到第一个元素向左右扩散直到遇见上升数(即a_i &lt; a_{i+1})，将这些数加入mp和path中\n\n其中mp表示当我们在B遇到某个数时，该数有没有已经处于一个标识可以达到的集合之中，用map&lt;int,int&gt;记录\npath表示该坐标有没有被走过\n\n\n考虑到时间复杂度，必须使用很离谱的优化：即将数组A的数组与下标都保存在一个map中\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vint a(n);\n    for (auto &amp;&amp;i : a) {\n        cin &gt;&gt; i;\n    }\n    vint vs = a;\n    ranges::sort(vs, greater&lt;int&gt;{});\n    //抽象优化技巧之把v[i]和其对应的下标存入map中\n    map&lt;int, vector&lt;int&gt;&gt; v_index;\n    for (int j = 0; j &lt; n; ++j) {\n        v_index[a[j]].push_back(j);\n    }\n    //为每个权重记录了下一次我们应该从 v_index[i] 向量的哪个位置开始查找\n    map&lt;int, size_t&gt; next_idx_ptr;\n    map&lt;int, int&gt; st;\n    vint path(n, 0);\n    int ans = 0;\n    for (auto &amp;&amp;i : vs) {\n        if (st[i] &gt; 0) {\n            st[i]--;\n            continue;\n        }\n        //这个idx表示我们55行后面操作的下标\n        int idx = -1;\n        if (v_index.count(i)) {\n            // 取当前数的所有下标集合\n            vint &amp;vi_idx = v_index[i];\n            // 取这个数下标集合中进行到多少个下标\n            size_t &amp;now_idx = next_idx_ptr[i];\n            while (now_idx &lt; vi_idx.size()) {\n                // f_inx 代表我们要找的第下标的实际值\n                // 该下标应该满足path[idx] != 0\n                int f_idx = vi_idx[now_idx];\n                // 当我们找到符合的下标的时候退出\n                if (path[f_idx] == 0) {\n                    idx = f_idx;\n                    now_idx++;\n                    break;\n                }\n                now_idx++;\n            }\n        }\n        // 为什么要做上面这一步？\n        // 我们需要排除出现找10时候出现[... 10 10 ...] 这样的情况\n        if (idx != -1) {\n            ans++;\n            path[idx] = 1;\n            for (int k = idx; k + 1 &lt; n; ++k) {\n                if (a[k] &gt;= a[k + 1] &amp;&amp; path[k + 1] == 0) {\n                    path[k + 1] = 1;\n                    st[a[k + 1]]++;\n                    continue;\n                }\n                break;\n            }\n            for (int k = idx; k - 1 &gt;= 0; --k) {\n                if (a[k] &gt;= a[k - 1] &amp;&amp; path[k - 1] == 0) {\n                    path[k - 1] = 1;\n                    st[a[k - 1]]++;\n                    continue;\n                }\n                break;\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl; \n}\n答案思路：\n\n其实从上面我的思路中就可以优化两点\n\n连续的相同数字不影响结果\n我们实际上找的是极大值点的数目\n则非常简单的就可以出来\n\n\n\nvoid solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tvint v;\n\tv.emplace_back(-1e9);\n\tfor(int i = 0; i &lt; n ; i++){\n\t\tint t = 0;\n\t\tcin &gt;&gt; t;\n\t\tif(t != v.back())v.emplace_back(t);\n\t}\n\tv.emplace_back(-1e9);\n\tint ans = 0;\n\tfor(int i = 1; i + 1 &lt; v.size() ; i++){\n\t\tif(v[i] &lt; v[i + 1] &amp;&amp; v[i] &gt; v[i - 1]) ans++;\n\t}\n\tcout &lt;&lt; ans &lt;&lt; endl;\n}\n一种很新的贪心 — 延迟决策与追溯修改\n来自CR 1026 d2 C\n\n大意:\n你有一个飞行器，其起始高度h_0 = 0，同时给你一个操作数组 d , d 中存在两种操作可能，分别是：\n\n保持不动(0) → h_{i+1} = h_i\n向上移动一位(1) → h_{i+1} = h_i + 1\n其中还存在特殊操作 -1,代表你可以自己决定其保持不动还是上升\n\n现在给你一些障碍，障碍的表现形式使用 l_i,r_i 给出，当飞行器高度l_i \\leq h_i \\leq r_i 时候，飞行器可以穿过障碍\n操作从0起始，现在我们想知道能不能穿越所有障碍，如果不行输出-1,如果可以，输出整个操作数组d\n\n核心思路：延迟决策与追溯修改\n\n\n我们维护两个数组L，R表示h_i目前可以到达的可能的高度\n\n\n维护一个栈sk保存出现-1的情况[主要保存的是idx]\n\n\n对每一个障碍我们做如下判断\n\n\n当d_i \\neq -1时，直接根据d_i改变h_i\n\n\n否则，将i，即idx存入栈中\n\n\n当h_i \\notin [L,R] 时候\n\n当h_i &lt; L_i时候，表示当前飞行器在不”人为干预”的情况下会撞到下障碍\n\n我们关注栈的状态，如果栈处于空，则直接输出-1,表示我们在之前已经没有多余的操作数去影响现在的h_i\n否则我们将栈中元素对应的idx的-1修改为1,并弹出栈顶表示飞行器向上移动一位\n\n\n当h_i + sk.\\text{size}() &gt; R_i时候，表示如果我们之前-1全设定为1时候会大于上障碍\n\n我们同样关注栈状态，如果栈空,直接输出-1，这表示我们没有办法通过前面的-1去降低h_i\n否则我们将栈中元素对应的idx的-1修改为0,并弹出栈顶,表示飞行器在之前假设最大高度下降一格\n\n\n\n\n\n最后我们输出数组d,注意要输出max(0,i)  因为到最后栈内元素不保证为空，则是我们不去控制即可，全部以0输出\n\n\n\n\n                  \n                   延迟决策与追溯修改\n                  \n                \n\n\n\n对于这样的贪心思路，我们先储存操作可能，在需要操作的时候返回去修改操作的可能，我们称之为延迟操作与追溯修改\n这是一个非常不错的贪心思路，在这类需要全局操作和后面情况会对前项造成影响的时候可以尝试\n\n\n\n\n\n这个似乎叫做”反悔贪心”的说\n\n\n同余原理方法\n来自 [CR 1042 d3](Problem - C - Codeforces)\n对一个数 p 我们可以先不断进行 p \\to |p - k| 直到得到余数 r \\in [0,k-1]\n\n此时 p \\equiv r \\mod k 即 p,r 对 k 同余\n此时我们 对r \\to |r - k| 有 k-r\n\n故我们称 r 与 k - r 等价\n\n\n所以我们先看 r 的情况\n\n对 r 而言，如果数组 T 中存在元素 t \\mod k = r 那我们就可以通过不断的 r \\to r + k 让 r 变成 t\n\n\n\n对k - r 的情况\n\n因为当余数为r时候，可以转化为 k - r ,同理，当余数为 k - r 时候通过 k - r \\to |k - r - k| = r也可以转化\n\n故我们只要求余数为 (r,k-r)的总数在这两个数组中的元素数量相等即可\n\n\n\n\n\n字符串01,10子串问题\n来自河南萌新赛1 I\n我们主要想要探讨的问题是,为什么一个字符串”10”和”01”子串数量是否相等只取决于这个字符串开头和结尾的字符是否相同\n当我们在字符串线性计数时候,我们不难注意到当我们从0 到 1时候,子串01的数量就会增加,当我们从 1 到 0 的时候10子串数量就会增加\n即当我们字符每发生一次状态转换,都会导致10或01的数目增加\n当我们开头和末尾数字一致的时候,我们在字符串中产生的状态转换一定是偶数次,那意味着01,10的数目一定是相等的,因为计数01后下一次计数一定是10\n同理,当开头末尾数字不一致时候,产生的状态转化数一定是奇数,此时两子串之差一定为1,也就是一定不等\nFootnotes\n\n\n如果你连续做 k 次差分，那么等价于先做一次差分得序列 \\Delta v，再对它做一次差分 \\Delta^2 v，……，直到 \\Delta^k v。而每一步差分的“和”都只剩下“前者首尾之差”这种形式，所以对第 k 次差分：\n \\sum (\\Delta^k v) = (\\Delta^{k-1} v)_{\\text{末}} - (\\Delta^{k-1} v)_{\\text{首}}\n在最后一步我们依旧可以翻转来取正负号，于是对第 k 次差分所能得到的和，就是\n\\sum (\\Delta^k v) =\\pm \\left[ (\\Delta^{k-1} v)_{\\text{末}} - (\\Delta^{k-1} v)_{\\text{首}} \\right]\n而对于(\\Delta^{k-1} v)_{\\text{末}} 与 (\\Delta^{k-1} v)_{\\text{首}} 我们也可以用递归的方式展开，最终即可证明 ↩\n\n\n"},"ACM/算法/杂项笔记/杂项练习笔记3":{"slug":"ACM/算法/杂项笔记/杂项练习笔记3","filePath":"ACM/算法/杂项笔记/杂项练习笔记3.md","title":"杂项练习笔记3","links":["tags/杂项练习","ACM/算法/二分"],"tags":["杂项练习"],"content":"杂项练习\n两个数组大小(字典序比较)\n描述：\n我们称序列 \\{ a_1​,⋯,a_n​ \\} 比序列 \\{ b_1​,⋯,b_n​ \\} “小”，如果存在1\\leq k \\leq n 满足 a_i = b_i​ 对所有 i&lt;k 成立，且 a_k​ &lt; b_k​。\n核心规则是：\n\n从第一个元素开始逐项比较两个序列的对应位置；\n若在第 k 个位置首次出现 a_k \\ne b_k​，则通过 ak​ 和 bk​ 的大小关系直接判定整个序列的大小（ak​&lt;bk​ 时序列 {ai​} 更小）；\n若所有对应位置均相等，则较短的序列视为更小（但题目中隐含比较的序列长度相同）。\n\n代码实例：\n//通过cmp函数返回sort的cmp值\n//排序的是较小数组放前方\n \nbool cmp(vector&lt;int&gt; a , vector&lt;int&gt; b)\n{\n\tfor(int i = 0; i &lt; min(a.size(),b.size()) ; i++){\n\t\tif(a[i] != b[i]) return a[i] &lt; b[i];\n\t}\n\treturn a.size() &lt; b.size();\n}\n//返回的cmp参数会使sort函数由大到小排列\n \nbool cmp_big(vector&lt;int&gt; a,vector&lt;int&gt; b)\n{\n\tfor(int i = 0; i &lt; min(a.size(),b.size()) ; i++){\n\t\tif(a[i] != b[i]) return a[i] &gt; b[i];\n\t}\n\treturn a.size() &gt; b.size();\n}\n最大连号数问题\n题目描述见最大连号数问题，在二分章节，我们介绍了一种O(\\log n)的解法，现在我们介绍一种O(1)的解法\n\n要使最大的连号数最小，我们将尽量均分每个连号数\n当我们将k个人分成尽可能多的段时，每段之间的空房间可以有效减少最大连号数。最多可以分割的段数为m = n - k + 1，因为每段之间至少需要一个空房间\n则最大连号数为 \\left \\lceil \\frac{k}{n-k+1} \\right \\rceil\n代码表示则为ans = ceil((k*1.0)/(n-k+1))\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\nceil在很高精度下会有精度丢失，我们用整数除法代替取整函数\n\\lceil \\frac{a}{b} \\rceil = \\lfloor \\frac{a+b-1}{b} \\rfloor\n即ceil((a*1.0)/b) == (a+b-1)/b\n\n\n\n\n数论(平方差)\n\n给定一个数 k ,对任意正整数 y\\,,\\,x \\quad (y \\ge x) 若 k\\mod 4 = 2,则k \\ne y^2 - x^2\n\n扩展 费马定理\n\n给定一个数 k ,存在正整数 p , q 使 k = q^2 + p^2 ,k 的存在定理：\n\n若k的所有质因数分解的为A 如果有其中元素 a_i \\mod 4 = 3 且该元素的指数幂次为偶数，则证明该数可以被平方和构造\n\n\n使用下面代码，能帮助我们在 O(\\sqrt{n})时间复杂度下检查某一个数是不是平方和数\n\nbool checkpowersum(int n)\n{\n\tunordered_map&lt;int,int&gt; nprime;\n\tfor(int i = 2 ; i &lt;= n/i ;i++) {\n\t\twhile(n % i == 0) {\n\t\t\tnprime[i]++;\n\t\t\tn /= i; \n\t\t}\n\t}\n\tif(n &gt; 1) {\n\t\tnprime[n]++;\n\t}\n\tfor(auto &amp;&amp;[prime,num] : nprime){\n\t\tif(prime % 4 == 3 &amp;&amp; num % 2 != 0){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n方法(方差与二分)\n对一组数据我们对其方差有：\nD(x) = E(x^2) -E^2(x) \n对于一组数据我们快速计算其方差就可以用前缀和的方式提前算好E(x)和E(x^2)\n数论2^n的最高位为k时n的取值\n当n满足下述方程时成立，方程表现形式如下\n\\left\\lfloor \\{n \\cdot \\log_{10} 2\\} - \\log_{10} k \\right\\rfloor = 0 \n其中\\{x\\}表示取x小数部分,\\left\\lfloor x \\right\\rfloor表示对该数向下取整\nPoof：\n推论1 ：对一般整数p = k^n，其最高位表示为\\left\\lfloor10^{\\{n\\log_{10}k\\}}\\right\\rfloor\nPoof_1:\n对p = k^n两边同时取10的对数:\n\\log_{10}​p=n\\log_{10}​k=m+f\n其中 m=⌊n\\log_{10}​k⌋ 为整数部分，f={n\\log_{10}​k}\\in[0,1) 为小数部分\n则p = k^n可以被分解为\np = k^{m + f} = k^m \\, \\cdot \\, k^f\n显然 f = \\{n\\log_{10}k\\}, 且k^m为一个10的次幂整数，而且我们不难得出k^f \\in [0,10)\n所以\\lfloor k^f \\rfloor即为最高位的数字\n推论1得证\n则我们可以得到 2^n = \\left\\lfloor10^{\\{n\\log_{10}2\\}}\\right\\rfloor\n拆去取底有\n\\begin{split}\n\\iff &amp;k \\leq 10^{\\{n\\log_{10}2\\}} &lt; k+1 \\\\\n\\iff &amp;\\log_{10}k \\leq \\{n\\log_{10}2\\} &lt; \\log_{10}{(k+1)} \\\\ \n\\iff &amp; 0 \\leq {n\\log_{10}2} - \\log_{10}k &lt; \\log_{10}{(k+1)} - \\log_{10}k \\\\\n\\iff &amp;\\left\\lfloor \\{n \\cdot \\log_{10} 2\\} - \\log_{10} k \\right\\rfloor = 0 \n\\\\\n&amp;&amp;\\mathcal{Q.E.D.}\n\\end{split}\n二分 + 前缀和"},"ACM/算法/杂项笔记/杂项练习笔记4(codeforces)(简单ver)":{"slug":"ACM/算法/杂项笔记/杂项练习笔记4(codeforces)(简单ver)","filePath":"ACM/算法/杂项笔记/杂项练习笔记4(codeforces)(简单ver).md","title":"杂项练习笔记4(codeforces)(简单ver)","links":[],"tags":[],"content":"\n\n命名采用标准 [比赛简名] + [div.x] + [x题]\nCR: Codeforces Round\nECR: Educational Codeforces Round\n\n\nCR1012 d2 B\n\n对这题我们发现，当某一个位置是1的时候，这个1必须到最上方或者最右方是连通的，我们只需要实现这个查询就可以了\n\n我们在读入数据的时候多开两个数组用于记录这个数与前一个数和上一个数的连通性，即\nvx[i][j] += vx[i][j - 1] + vv[i][j];\nvy[i][j] += vy[i - 1][j] + vv[i][j];\nvv是输入数组\n则我们在查询的时候就可以查询这个数组该位置的值是否是i(j)来判断是不是到最右侧是连通的\n\n\n\n\nCR1004 d2 B\n通读题目发现我们需要将两个包内的数字一致，初始B包为空，我们可以进行如下操作\n\n将A包的一个数移动到B包\n在A包选择B包中有的数使该数 值+1\n\n思路：\n\n我们维护一个map，存下每个数出现的个数\n从最大值开始沿整数遍历到最小值\n对于遍历的每一个数i，我们设一个 ck 用于计算和保存需要多少 i - 1：\n\n检查 mp[i] - ck\n\n若其大于 0 ,表示该数足以填补前面所有需要的数，则将ck归零，mp[i]减去ck;\n然后计算mp[i] 能不能被二整除,不行的话则将 ck + 3\n若不大于零，则需要下一个数进行补充\n\n我们发现若要达到A，B袋子平衡态，则需要3个 k → k+1 和 1 个k+1才能达到\n若我们需要两个 k+1 ,则只需要多加一个 k 就行(即4个k)，因为本身已经处于平衡态，不需要额外的 k 保证平衡\n\n\n则新 ck 为 原ck - mp[i] - 1 + 3\n\n\n\n\n遍历完成后检查 ck 是否大于0,大于零则说明不够形成平衡态，输出 No 即可\n\n\nCR1007 d2 B\n\n题目需求是让我们求一个长度为n的排列，这个排列前的\\{1,2,3,\\cdots,n\\}项的和都不能是平方数\n\n显然对一个长度为n的排列的和 S = \\frac{n(n+1)}{2} ，若该S为平分数，则长度为n的序列一定不能被构造出来\n我们考虑长度不为n的排列，先从1～n进行排列，若其中某下标k满足上面的平分构造，则我们交换 a_k,a_{k+1}\n\n而对于交换后是否一定满足其前缀和为平方数？我们可以这样理解，对于最小的两个平方数差为 4 - 1 = 3，而交换两个相邻数，前缀和+1，小于最小平方数之差。\n\n\n\n\n输出构造完毕的排序即可\n\n\nECR176 d2 B\n\n对长度为 n 的数组 A 有k次操作选择 A 中的数，在根据这些数为原点任意扩散，我们需要知道选择的k个数和选择完毕扩散到的最后一个数的值的最大情况\n\n显然当 k &gt; 1 时候，我们扩散到的最后一个数可以是选择后数组中的任意一个数，则我们只需要选择前k + 1大的数做和即可\n当k = 1时，我们注意到A序列两端中必有一端是最后被扩散的数，则我们只需要取除去两端外最大的数和两端中最大的数即可\n\n\n\n\nCR1019 d2 B\n\n贪心思路\n\n先在字符串加前缀”0”方便后续操作\n在字符串里寻找 “01” 与 “10” 并分别计数\n若不改变字符串，操作数为 n + cnt01 + cnt10\n当 “10” 数量与 “01” 数量之和小于2时候，直接计数即可\n否则看是否有字符串的数量大于 2 ，如果存在操作数就 -2，否则 -1\n\n\n\n\nCR1005 d2 B\n\n贪心 + 双指针\n\n我们需要寻找数组中最长的且数字只出现一次的子序列\n维护一个map用来保存数字出现几次\n在map为1的数下查找最长的子序列\n注意不要忘记当所有数字出现次数都大于2时候输出0\n\n\n\n\nCR998 d3 D\n\n贪心\n\n显然当数组已经排序时可以通过操作\n对每一次操作，都会将\\{a_i,a_{i+1}\\}变为\\{0,a_{i+1} - a_i\\}或\\{a_i - a_{i+1},0\\},显然后者是不可取的\n因为构造出的第一个数是0，则我们若想一个非已经排序数字的开头开始按题目要求向后构造\n\n从第一个构造到最后一个，倘若可以形成非递减序列，则最后数组形式一定为\\{0,0,0,\\cdots,0,x\\}形式，则检查最后数组是否排序即可\n\n\n\n\n\n\nCR997 d2 B\n\n图与排序\n\n根据题目含义，我们可以知道，图中两个定点元素有边，则说明小的元素的下标值一定小于大的元素\n则根据这一点，我们可以先确定一个排序[\\,n\\,,\\,n-1\\,,\\,\\cdots \\,\\,2\\,,\\,1\\,] 然后从第一个元素出发，如果发现该元素比其小的元素有边，说明这个元素下标应该比有边的元素大\n\n整个排序过程可以使用类似快速排序的思想完成\nlambda = [&amp;]( int a , int b ){ return (mp[a][b] == 1 ? a &lt; b : a &gt; b)};\n\n\n\n\n\n\nECR178 d2 D\n\n这种题目属于典型的看了答案大彻大悟，不看答案一头雾水\n\n我们理解题目限制1,即我们操作后的元素和不能大于原数组和\n现在考虑一个理想数组的特性，一个大小为n的理想数组的和的最小状态应该是前n项质数组成的数组\n则我们只需要知道原数组和是质数数组前缀和的第几项就可以了\n\n但是直接做前缀可以有超时风险，我们可以先由大到小排序给定数组，在加和给定数组和质数数组，每一次加和的时候进行比较sumv &gt;= sump ? ans = i + 1 :\n最终答案便是 n - ans\n\n\n\n\n\n"},"ACM/算法/树状数组(BIT)":{"slug":"ACM/算法/树状数组(BIT)","filePath":"ACM/算法/树状数组(BIT).md","title":"树状数组(BIT)","links":["线段树","ACM/算法/前缀和与差分"],"tags":[],"content":"树状数组是一种支持单点修改和区间查询的，代码量小的数据结构,在这里我们可以理解为线段树的简化版本\n\n树状数组对单点修改和区间查询的时间复杂度都为O(\\log n)\n对于前缀和，树状数组在更新值的时候\n\n引入\n\n对于数组 A 其中元素为 [a_0,a_1 \\cdots a_n]\n有q次询问，每次询问可能涉及两种操作\n\n对 a_i 加 k\n给定区间[\\,l,r\\,]，求区间和\n\n\n\n\n对数组A，我们朴素的使用前缀和也可以实现上面的两个操作，但是对于询问次数特别多且n特别大的时候，前缀和在修改的O(n)时间复杂度就不能满足题目要求\n\n\n我们试想，将A的每个元素两两加和得到一个新的A&#039;，对A&#039;做操作这样我们需要查询和修改的n就变为了 \\frac n2\n\n\n我们继续重复以上步骤，将每次的A&#039;的元素都两两加和\n\n\n最终我们会得到下面的一幅图：\n\n\n\n我们发现在我们进行修改和区间和的时候，有些元素是完全不会被用上的\n\n即：每行的第偶数个元素都是没必要的\n比如我们需要计算 [\\,1,3\\,] 的区间和，我们只需要计算最下面数组的a_3 + 倒数第二行的 a_1 即可。其余的都证明\n\n\n\n所以我们将从上到下每个数组偶数个元素删去\n\n\n\n发现剩下的数据正好有n个,即我们的新数组可以表示为一个为长度n的新数组，即树状数组\n\n\n数组中的每一个元素，都代表莫一个区间\n\n\n\n则我们可以在这个新的数组中了解树状数组两个操作，即单点修改和区间查询\n\n\n那我们如何查找每个元素对应的区间呢？\n\nlowbit(i)函数，这个函数会返回数 i 最后一位二进制为1的数对应的数 如 5 = (101)_2 则 lowbit(5)= (1)_2 = 1\nlowbit(i){ return i&amp;(-i);\n我们发现对上图的每个元素下标 i ,\\mathrm{lowbit}(i) 即为从下到上的区间位置和区间长度\n也就是说，序号为i的序列正好就是长度为lowBit(i)且以i结尾的序列。\n\n\n\n回到引入题目，我们现在需要构建一个树状数组，那我们从树状数组的单点修改入手：\n单点修改\n\n当我们想要修改某一个数的时候，我们需要找到包含这个数的所有区间\n\n而树状数组的性质告诉我们，某一个序列上方的序列在树状数组的下标中为：b[i&#039;] = b[i+\\mathrm{lowbit}(i)\n则我们只需要不断的向上累加直到超过长度就可以了\n\n\n\n\n// 在i位置加k\nvoid add(int i,int k)\n{\n\twhile(i &lt; N){\n\t\tb[i] += k;\n\t\ti += lowbit(i);\n\t}\n}\n\n而对于初始化，我们只需要一开始设置一个长度为n，初始值0的数组,将每个i位加上元素值即可\n\nvoid init()\n{\n\tfor(int i = 1 ; i &lt;= n ; i++) add(i,v[i]);\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n我们约定俗成的规定树状数组的下标由1开始，避免lowbit(0)的死循环问题\n\n\n\n区间查询\n\n树状数组能够做到的是对求到i的前缀和，而根据数上前缀和的原理，我们便可以求解区间\n\n前缀和的求解非常简单，只需要求i位置对应的区间及其前面的区间即可，可以用lowbit定位到每一个区间\n\n\n\nint getsum(int i)\n{\n\tint cnt = 0;\n\twhile(i &gt; 0){\n\t\tcnt += b[i];\n\t\ti -= lowbit(i);\n\t}\n\treturn cnt;\n}\n\n而对于区间求和就可以使用数上前缀和的方法ans = sum[r] - sum[l-1]\n\nint range_sum(int l ,int r)\n{\n\treturn getsum(r) - getsum(l-1);\n}\n\n\n                  \n                  Add\n                  \n                \n\n\n下面给出一个简单易于书写的fenwick数模板\n\n\n\nstruct fenwick{\n\ti64 n;\n\tvector&lt;i64&gt; bit;\n\tfenwick(i64 n): n(n) ,bit(n+1,0){}\n\tvoid add(i64 i,i64 v = 1){for(;i &lt;= n;i += ( i &amp; -i )) bit[i]+=v; }\n\ti64 sum(i64 i){i64 r = 0;for(;i &gt;= 0;i -= i&amp;-i)r += bit[i];return r;}\n\ti64 sum(i64 r,i64 l){return sum(r) - sum(l - 1);}\n}"},"ACM/算法/桶排序":{"slug":"ACM/算法/桶排序","filePath":"ACM/算法/桶排序.md","title":"桶排序","links":["tags/哈希","tags/排序"],"tags":["哈希","排序"],"content":"哈希 排序\n桶排序\n\n有一种排序方式可以很快的对数字进行排序\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main() \n{\n    int arr[11];\n    for (size_t i = 1; i &lt;= 10; i++)\n    {\n        int a;\n        cin &gt;&gt; a;\n        arr[a]++; \n    }\n    for (size_t j = 0; j &lt;= 10; j++)\n    {\n        if (arr[j] != 0)\n        {\n            for (size_t i = 1; i &lt;= arr[j]; i++)\n            {\n                cout &lt;&lt; j &lt;&lt;&quot; &quot;;                \n            }\n        }\n    }\n    \n    return 0;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n\n在使用桶排序解决实际题目的时候，一定要注意初始开始值\n点名表扬洛谷 [P5729 【深基5.例7】工艺品制作]\n\n\n\n\n\n\n                  \n                  Note\n                  \n                \n\n\n\n桶排序的思想可以用在需要标记类的题目上，例如洛谷 [P1047 [NOIP2005 普及组] 校门外的树] [P5729 【深基5.例7】工艺品制作]\n\n\n\n"},"ACM/算法/深度优先搜索-DFS":{"slug":"ACM/算法/深度优先搜索-DFS","filePath":"ACM/算法/深度优先搜索 DFS.md","title":"深度优先搜索 DFS","links":["tags/递归与递推","tags/搜索","tags/模板","ACM/算法/递归"],"tags":["递归与递推","搜索","模板"],"content":"递归与递推 搜索 模板\nDFS 深度优先搜索\n\n题目来源：P1036 [NOIP2002 普及组] 选数\n题目核心:\n\n\n[NOIP2002 普及组] 选数\n题目描述\n已知 n 个整数 x_1,x_2,\\cdots,x_n，以及 1 个整数 k（k&lt;n）。从 n 个整数中任选 k 个整数相加，可分别得到一系列的和。例如当 n=4，k=3，4个整数分别为 3,7,12,19 时，可得全部的组合与它们的和为：\n3+7+12=22\n3+7+19=29\n7+12+19=38\n3+12+19=34\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n有别于传统模拟，这种在N个数里找k个数的操作，正常人应该都不会想到使用 循环 或 枚举 但受限于知识则停滞不前\n其实思路很简单，选多少个数就建立多少个标记，然后从某一标记开始移动，将所有标记过的数加和即可\n问题是，怎么使用代码实现？\n\n\n\n\n\nDFS:深度优先搜索\n这时候就需要用到递归搜索了。\n该类搜索算法的特点在于，将要搜索的目标分成若干「层」，每层基于前几层的状态进行决策，直到达到目标状态。\n\n先看核心代码\nvoid dfs(int m, int sum, int startx){\n    if(m == k){\n        if(isprime(sum))\n            ans++;\n        return ;\n    }\n    for(int i = startx; i &lt; n; i++)\n        dfs(m + 1, sum + a[i], i + 1);\n    return ;\n}\n\n前置知识：每次递归调用dfs时，都会创建一个新的栈帧，并将m + 1、sum + a[i]和i + 1作为参数传递给dfs函数。当dfs函数执行到return语句时，它会返回到上一个栈帧，也就是上一次调用dfs的地方\n\n\n例子\n\n\n\n让我们用一个简化的例子来说明DFS算法的运行原理。假设我们有一个数组 a = [1, 3, 5, 7] 和 k = 2，我们要找出所有长度为2的子数组，其和为素数\n\n\n 开始\n  |\n  v\n dfs(0, 0, 0)  &lt;- 初始化，m=0（子数组长度），sum=0（子数组和），startx=0（起始索引）\n  |\n  |\n  |--&gt; dfs(1, 1, 1)  &lt;- 选择a\\[0]，m=1，sum=1，startx=1\n  |   |\n  |   |--&gt; dfs(2, 4, 2)  &lt;- 选择a\\[1]，m=2，sum=4，startx=2\n  |   |   |\n  |   |   |--&gt; 检查sum=4（不是素数），结束这个分支\n  |   |\n  |   |&lt;-- 返回到 dfs(1, 1, 1) \\[返回到这个栈帧的时候for循环内的参数不会变化] //保留了这个栈帧的数据\n  |\n  |   |--&gt; dfs(2, 8, 2)  &lt;- 选择a\\[2]，m=2，sum=8，startx=2\n  |   |   |\n  |   |   |--&gt; 检查sum=8（不是素数），结束这个分支\n  |   |\n  |   |&lt;-- 返回到 dfs(1, 1, 1)\n  |   |\n  |&lt;----- 返回到 dfs(0, 0, 0)\n  |\n  |--&gt; dfs(1, 3, 1)  &lt;- 选择a\\[1]，m=1，sum=3，startx=1\n  |   |\n  |   |--&gt; dfs(2, 6, 2)  &lt;- 选择a\\[2]，m=2，sum=6，startx=2\n  |   |   |\n  |   |   |--&gt; 检查sum=6（不是素数），结束这个分支\n  |   |\n  |   |&lt;-- 返回到 dfs(1, 3, 1)\n  |\n  |   |&lt;-- 返回到 dfs(0, 0, 0)\n  |\n  |--&gt; dfs(1, 5, 1)  &lt;- 选择a\\[2]，m=1，sum=5，startx=1\n  |   |\n  |   |--&gt; dfs(2, 10, 2)  &lt;- 选择a\\[3]，m=2，sum=10，startx=2\n  |   |   |\n  |   |   |--&gt; 检查sum=10（不是素数），结束这个分支\n  |   |\n  |   |&lt;-- 返回到 dfs(1, 5, 1)\n  |\n  |   |&lt;-- 返回到 dfs(0, 0, 0)\n  |\n  |&lt;-- 返回到开始\n 结束\n使用DFS实现全排列\n\nDFS的核心思路是一路往下寻找，不撞南墙不回头说明当DFS到达边界情况时，就完成了一次搜索\n使用DFS时就要考虑完成一次**“搜索”**所需要的条件和边界情况\n\n\n使用DFS实现全排列\n\n思考第一步：全排列的一次情况的边界条件\n\n我们不妨对DFS传入一个参数 step 表示完成一次全排列的步骤\n当step 到 n 的时候，一次全排列的一种情况便结束了：\n在当前情况下，我们需要做的事情是：\n\n输出全排列的一次情况\n\n\n\n\nQ1：如何输出一次全排列情况？\n\nA:用result数组存\n\n\n思考第二步：全排列的实现\n\n我们可以使用一 个 path 来保留加入到result数组\npath 数组在一次查找过程中先将其标记，再进入下一个DFS函数查找，再取消标记，即一次回溯操作\n\n\n\n\nvector&lt;bool&gt; path;\nvint result;\nint t = 1;\n \nvoid quan(int step)\n{\n    if (step == t + 1) {\n        for (size_t i = 1; i &lt;= t; i++) {\n            cout &lt;&lt; result[i] &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n    for (size_t i = 1; i &lt;= t; i++) {\n        if (path[i] == 0) {\n            path[i] = 1;\n            result[step] = i;\n            quan(step + 1);\n            path[i] = 0;\n        }\n    }\n    return;\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    cin &gt;&gt; t;\n    path = vector&lt;bool&gt;(t + 10);\n    result = vint(t + 10);\n    quan(1);\n    return 0;\n}\n[板子] 一组数据取任意个数据进行操作\n例1：在数组[1,2,3,4,5] 中取任意个数，求这些取出来的数相加的结果\n方法一：DFS爆搜\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nvint res;\nvoid dfs(int n, int sum, int T, vint k)\n{\n    if (n &gt;= T) return;\n    sum += k[n];\n    res.emplace_back(sum);\n    for (size_t i = n + 1; i &lt; T; i++) {\n        dfs(i, sum, T, k);\n    }\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int T = 1;\n    cin &gt;&gt; T;\n    vint k(T);\n    for (auto &amp;&amp;i : k) {\n        cin &gt;&gt; i;\n    }\n    for (size_t i = 0; i &lt; T; i++) {\n        dfs(i, 0, T, k);\n    }\n    cout &lt;&lt; 0 &lt;&lt; &quot; &quot;;\n    for (auto &amp;&amp;i : res) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n\n其结果表现为：\n\n0 1 3 6 10 15 11 7 12 8 4 8 13 9 5 10 6 2 5 9 14 10 6 11 7 3 7 12 8 4 9 5\n充分体现了人类看不懂栈帧的特点\n\n\n法二：DP\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n//#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    vint food(T);\n    for(auto &amp;&amp; i : food){\n        cin &gt;&gt; i;\n    }\n    vint dp;\n    dp.emplace_back(0); // 初始状态\n    for (auto &amp;&amp;i : food) {\n        vint temp = dp;\n        for (auto &amp;&amp;j : dp) {\n            temp.emplace_back(i + j);\n        }\n        dp = move(temp);\n    }\n    for (auto &amp;&amp;i : dp)\n    {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n\n输出如下：\n0 1 2 3 3 4 5 6 4 5 6 7 7 8 9 10 5 6 7 8 8 9 10 11 9 10 11 12 12 13 14 15\n\n已验证，两个程序的结果除了顺序完全一致\n例2: P2036 [COCI2008-2009 #2] PERKET\n\n\n例二 法一：DFS\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n#define int LL\n#define endl &#039;\\n&#039;\n#define size_t int\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector&lt;int&gt; vint;\ntypedef vector&lt;vint&gt; vvint;\ntypedef vector&lt;string&gt; vstr;\ntypedef pair&lt;int, int&gt; pii;\ntypedef vector&lt;pii&gt; vpii;\n \nint T;\nvpii food;\n// vint result;\nint ans = 1e6;\n \nvoid dfs(int n, int sum_s, int sum_k)\n{\n    if (n == T) {\n        sum_s *= food[n - 1].first;\n        sum_k += food[n - 1].second;\n        ans = min(ans, abs(sum_s - sum_k));\n        return;\n    }\n    sum_s *= food[n].first;\n    sum_k += food[n].second;\n    ans = min(ans, abs(sum_s - sum_k));\n    for (size_t k = 0; k &lt; T; k++) {\n        for (size_t i = n; i &lt; T; i++) {\n            dfs(i + 1, sum_s, sum_k);\n        }\n        sum_s = 1;\n        sum_k = 0;\n    }\n}\n \nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    cin &gt;&gt; T;\n    food = vpii(T);\n    // result = vint(T, 0);\n    for (auto &amp;&amp;[s, k] : food) {\n        cin &gt;&gt; s &gt;&gt; k;\n    }\n    dfs(0, 1, 0);\n    cout &lt;&lt; ans;\n    return 0;\n}\n// 比我命还暴力这个算法\n// 这题绝对能用DP写，待我研究一下\n例二 法二 ： DP\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair&lt;ll, ll&gt; pii;\n \nsigned main()\n{\n    int T = 1;\n    cin &gt;&gt; T;\n    vector&lt;pii&gt; food(T);\n    for (auto &amp;&amp;[s, k] : food) {\n        cin &gt;&gt; s &gt;&gt; k;\n    }\n    // 使用集合记录所有可能的 (酸度, 苦度) 组合\n    set&lt;pii&gt; dp;\n    dp.emplace(1, 0); // 初始状态\n    for(auto &amp;[s, b] : food){\n        set&lt;pii&gt; temp = dp;\n        for(auto &amp;[acid, bitter] : dp){\n            temp.emplace(acid * s, bitter + b);\n        }\n        dp = move(temp);\n    }\n    // gtp写的，确实很精巧，用set记录了每个可能的情况\n    // 因为初始状况是(1,0),就相当于每一次内层循环的第一次都是只选当前组的食物\n    // 每一次都会把dp数组过完一遍，相当于在之前的所有情况下加一个 选择当前食物的情况\n    ll result = LLONG_MAX;\n    for(auto &amp;[acid, bitter] : dp){\n        if(acid != 1 || bitter != 0){\n            result = min(result, abs(acid - bitter));\n        }\n    }\n    cout &lt;&lt; result;\n    return 0;\n}"},"ACM/算法/状态压缩":{"slug":"ACM/算法/状态压缩","filePath":"ACM/算法/状态压缩.md","title":"状态压缩","links":["tags/模板"],"tags":["模板"],"content":"模板\n状态压缩\n状态压缩指的是用较小的数据结构（如整数或位掩码）来表示一个可能的状态或组合，从而减少存储空间和计算复杂性\n\n当两个数据分析特别大的时候，我们可以考虑使用二进制来实现0/1的分类;\n下面举例使一个数组的分为 a b两组,找到 max( \\sum a , \\sum b ) 中的最小值\na 代表一个分类     b 代表一个分类\n\ncin &gt;&gt; n;\nfor(int i = 0; i &lt; n; i ++) cin &gt;&gt; k[i];\nfor(LL state = 0; state &lt; 1LL &lt;&lt; n; state ++){           ---&gt; A \n    a = 0, b = 0;\t\t\t\t\t\t\t\t\t\t\n    for(int i = 0; i &lt; n; i ++){\t\t\t\t\t   \t ---&gt; B\n        if(state &gt;&gt; i &amp; 1) a += k[i];\n    \telse b += k[i];\n    }\n    ans = min(ans, max(a, b));                           ---&gt; C\n\nstate表示了一个被压缩的状态 \\to 用long long 表示一个被分类的状态\n\n\n\n                  \n                  Note\n                  \n                \n\n\nA：实际上是表示了2^{n}种状态 1LL &lt;&lt; n 等效于 2^n\nB：二进制位一共有n位，i 从零到 n 解 state二进制位\n\n对于每个元素 k[i]，根据 state 的二进制位判断该元素属于组 a 还是组 b\n\nC: 刷新ans,这确保了 ans 始终存储的是所有分组方式中最小的最大和\n例子解释，当 n = 3 时\n每个 state 的二进制位表示每个元素属于哪一组。例如，对于 n = 3（有 3 个元素的情况）：\n\nstate = 0（000）：所有元素都在组 b\nstate = 1（001）：第一个元素在组 a，其余元素在组 b\nstate = 2（010）：第二个元素在组 a，其余在组 b\nstate = 3（011）：第一个和第二个元素在组 a，第三个在组 b\n…\nstate = 7（111）：所有元素都在组 a\n\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n状态压缩的复杂度为 O(2^n)  在 n &gt; 29 时大概率TLE\n\n\n"},"ACM/算法/素数筛":{"slug":"ACM/算法/素数筛","filePath":"ACM/算法/素数筛.md","title":"素数筛","links":["tags/数学","tags/数论","tags/素数"],"tags":["数学","数论","素数"],"content":"数学 数论 素数\n9 素数筛\n9.1 一般双重筛\n\n通过不断试除来判断某一数字k有无因数\n时间复杂度为O(N^2)\n\nbool prime(long long i)\n{\n    if (i == 2)\n        return 1;\n    else if (i == 1)\n        return 0;\n    for (size_t k = 2; k * k &lt;= i; k++) {\n        if (i % k == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    for (size_t i = 2; i &lt;= n; i++) {\n        if (prime(i)) {\n            cout &lt;&lt; i &lt;&lt; endl;\n        }\n    }\n    return 0;\n}\n9.2 埃拉托斯特尼筛法\n\n核心思路是先标记素数，然后把素数的所有倍数全标记为非素数\n时间复杂度是O(n\\log{\\log{n}})\n对于任意一个大于1的正整数n,那么它的x倍就是合数(x &gt; 1)。利用这个结论，我们可以避免很多次不必要的检测。\n如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。\n\nvector&lt;int&gt; prime;\nvector&lt;bool&gt; IsPrime(1e7);\n \nvoid Eratosthenes(long long n)\n{\n    IsPrime[0] = IsPrime[1] = 0; //前两项不为素数，记作0\n    for (size_t i = 2; i &lt;= n; i++) //先全部记作1\n    {\n        IsPrime[i] = 1;\n    }\n    //memset(IsPrime,1,sizeof(IsPrime)); //似乎使用memset的时间复杂度也是O(N)\n    for (size_t i = 2; i &lt;= n; i++)\n    {\n        //素数筛选\n        //从第三项开始，如果这个数被标记为1，就把它记作素数，放入数组 \n        //同时从 i*i 项开始，每次将 i 的倍数标记为非素数\n        if (IsPrime[i])\n        {\n            prime.push_back(i);\n            if ((long long)i * i &gt; n) continue; //超过n的不计\n            for (size_t j = i*i ; j &lt;= n; j += i)\n            {\n                IsPrime[j] = 0;\n            }\n        }\n    }\n}\n \nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    Eratosthenes(n);\n    for (auto &amp;&amp;i : prime) cout &lt;&lt; i &lt;&lt;endl;\n    return 0;\n}\n\n我们可以只筛选到\\sqrt{N}来降低操作次数\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &quot;\\n&quot;\nusing namespace std;\n \nvector&lt;int&gt; prime;\nvector&lt;bool&gt; IsPrime(1e7);\n \nvoid Eratosthenes(long long n)\n{\n    IsPrime[0] = IsPrime[1] = 0; //前两项不为素数，记作0\n    for (size_t i = 2; i &lt;= n; i++) //先全部记作1\n    {\n        IsPrime[i] = 1;\n    }\n    //memset(IsPrime,1,sizeof(IsPrime)); //似乎使用memset的时间复杂度也是O(N)\n    for (size_t i = 2; i*i &lt;= n; i++)\n    {\n        //素数筛选\n        //从 i*i 项开始，每次将 i 的倍数标记为非素数\n        if (IsPrime[i])\n        {\n            for (size_t j = i*i ; j &lt;= n; j += i)\n            {\n                IsPrime[j] = 0;\n            }\n        }\n    }\n    //计入数组\n    for (size_t i = 2; i &lt;= n; i++)\n    {\n        if (IsPrime[i])\n        {\n            prime.push_back(i);\n        }\n    }\n}\n \nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    Eratosthenes(n);\n    for (auto &amp;&amp;i : prime) cout &lt;&lt; i &lt;&lt;endl;\n    return 0;\n}\n\n我们也可以改写0/1来实现非初始化bool数组\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &quot;\\n&quot;\nusing namespace std;\n \nvector&lt;int&gt; prime;\nvector&lt;bool&gt; IsPrime(1e7);\n \nvoid Eratosthenes(long long n)\n{\n    IsPrime[0] = IsPrime[1] = 0; //前两项不为素数，记作0\n    for (size_t i = 2; i*i &lt;= n; i++)\n    {\n        //素数筛选\n        //从 i*i 项开始，每次将 i 的倍数标记为非素数\n        if (!IsPrime[i])\n        {\n            for (size_t j = i*i ; j &lt;= n; j += i)\n            {\n                IsPrime[j] = 1;\n            }\n        }\n    }\n    //计入数组\n    for (size_t i = 2; i &lt;= n; i++)\n    {\n        if (!IsPrime[i])\n        {\n            prime.push_back(i);\n        }\n    }\n}\n \nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    Eratosthenes(n);\n    for (auto &amp;&amp;i : prime) cout &lt;&lt; i &lt;&lt;endl;\n    return 0;\n}\n9.3 欧拉筛法\n\n时间复杂度O(n)\n埃氏筛法仍有优化空间，它会将一个合数重复多次标记。我们可以用改进的筛法欧拉筛来计算\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &quot;\\n&quot;\nusing namespace std;\n \nvector&lt;int&gt; prime;\nvector&lt;bool&gt; not_prime(1e7);\n \nvoid Euler(long long &amp;n)\n{\n    for (size_t i = 2; i &lt;= n; i++)\n    {\n        //如果该数标记为 0 即 非(非素数),计入素数数组\n        if (!not_prime[i])\n        {\n            prime.push_back(i);\n        }\n        // 换言之，i 之前被 prime[j] 筛过了\n        // 由于 prime 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被\n        // prime[j] 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break掉\n        for (auto &amp;&amp;j : prime)\n        {\n            if(i*j &gt; n) break;\n            not_prime[i*j] = 1;\n            if(i%j == 0) break;\n        }\n    }\n}\n \nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    Euler(n);\n    for (auto &amp;&amp;i : prime) cout &lt;&lt; i &lt;&lt; endl;\n    return 0;\n}"},"ACM/算法/约瑟夫问题":{"slug":"ACM/算法/约瑟夫问题","filePath":"ACM/算法/约瑟夫问题.md","title":"约瑟夫问题","links":["tags/数学","tags/模拟","tags/递归与递推"],"tags":["数学","模拟","递归与递推"],"content":"数学 模拟 递归与递推\n约瑟夫问题\n\n人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。\n现在我想知道幸存者的编号(编号从0开始)的多少\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n考虑在有n - 1个人，处决k的情况下最后一个人的编号是f(n - 1,k),那么对n个人而言，有递推式==f(n,k) = (f(n-1,k) + k)\\mod n==\n递推式求解抽象化：考虑对f(n-1,k)，扩展到n人时，我们只需要将第k个人处决，问题便又回到了对n-1人中找f(n-1,k)的问题上，但我们删除编号k个数时候,所有数的编号都会进行变化映射,即新的环的起点发生了变化,即集体向后移动k位且保证在n范围内,所以需要取模与n\n即 : ==f(n,k) = (f(n-1,k) + k)\\mod n==\n\n\n\nint josephus(int n, int k)\n{\n    int s = 0;\n    for (int i = 2; i &lt;= n; i++) s = (s + k) % i;\n    return s + 1;\n}\n\n上述算法时间复杂度O(n),空间复杂度O(1),但对 k = 2的情况我们可以有特殊解法使时间复杂度降低到O(\\log n) : 引用自Wikipedia\n\n答案的最漂亮的形式，与n的二进制表示有关：把n的第一位移动到最后，便得到f(n)。如果n的二进制表示为n=b_{0}b_{1}b_{2}b_{3}\\dots b_{m}则f(n)=b_{1}b_{2}b_{3}\\dots b_{m}b_{0}。这可以通过把n表示为2^{m}+l来证明。\n\n\nint yuesefu(int n)\n{\n    // 找到最高位的值，即n的最高位所代表的2的幂\n    int highestBit = 1;\n    while (highestBit &lt;= n) {\n        highestBit &lt;&lt;= 1; // 将最高位左移\n    }\n    // 移动后的结果\n    return (n - (highestBit &gt;&gt; 1)) &lt;&lt; 1 + 1;\n // return (n -  highestBit / 2) * 2 + 1\n}"},"ACM/算法/线性丢番图方程":{"slug":"ACM/算法/线性丢番图方程","filePath":"ACM/算法/线性丢番图方程.md","title":"线性丢番图方程","links":["tags/数学","tags/丢番图","tags/数论","ACM/算法/扩展欧几里得算法"],"tags":["数学","丢番图","数论"],"content":"数学 丢番图 数论\n20 线性丢潘图方程(Diophantine equation)\n\n线性丢番图方程（Diophantine equation）通常指的是形如 ax+by=c的方程，其中 a,b,c 是整数，而我们感兴趣的是找到整数解 x,y。\n孩子们，牛客周赛77第三题会这个秒杀了（怪不得那群人可以20min ak，全是板子题）\n\nx,y 存在解的情况下，a,b 满足以下条件\n\nc 必须是 a 和 b 的最大公约数 (gcd) 的倍数\n\n具体而言，当 c\\mod({\\gcd(a,b)}) = 0 时存在x,y 使上述方程存在整数解\n\n扩展：\n若上述条件满足，则存在无穷多组解 (x,y) ,一旦找到一组特殊的解(x_0,y_0)，则所有解都可以被表示出来，其表示方式如下\nx = x_0 + k\\left(\\frac{b}{g}\\right)\ny = y_0 - k\\left(\\frac{a}{g}\\right)\n其中g = \\gcd(a,b)\n\n\n其具体作用为，在确定线性丢潘图方程有解的情况，可以使用扩展欧几里得算法展欧几里得算法找出其中一个特解(x_0,y_0) , 然后找出所有解的通项\n\n找出丢潘图方程通项代码模板\n\n需要用到扩展欧几里得算法进行实现\n\n\n如下：\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \n// 扩展欧几里得算法\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n{\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a; // 返回gcd(a, b)\n    }\n    int r = exgcd(b, a % b, x, y);\n    int t = y;\n    y = x - (a / b) * y;\n    x = t;\n    return r;\n}\n \nint main()\n{\n    int a, b, c;\n    cout &lt;&lt; &quot;请输入线性丢番图方程(ax+by=c)的系数a, b和常数c : &quot; &lt;&lt; endl;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    int g = __gcd(a, b); // 计算gcd(a, b)\n    if (c % g != 0) {\n        cout &lt;&lt; &quot;方程无整数解.&quot; &lt;&lt; endl;\n        return 0;\n    }\n    // 使用扩展欧几里得算法找到一个特解\n    int x0, y0;\n    exgcd(a / g, b / g, x0, y0);\n    x0 *= c / g;\n    y0 *= c / g;\n    cout &lt;&lt; &quot;一个特解为: x = &quot; &lt;&lt; x0 &lt;&lt; &quot;, y = &quot; &lt;&lt; y0 &lt;&lt; endl;\n    // 输出一般解\n    cout &lt;&lt; &quot;一般解的形式为:&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;x = &quot; &lt;&lt; x0 &lt;&lt; &quot; + &quot; &lt;&lt; b / g &lt;&lt; &quot; * k&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;y = &quot; &lt;&lt; y0 &lt;&lt; &quot; - &quot; &lt;&lt; a / g &lt;&lt; &quot; * k&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;其中k为任意整数.&quot; &lt;&lt; endl;\n    return 0;\n}\n\n\n                  \n                  Tip\n                  \n                \n\n\n由于 g 已经是 a 和 b 的最大公约数，因此 \\frac{a}{g} 和 \\frac{b}{g} 互质（即它们的最大公约数为1）。这样做的目的是为了简化问题，使得新的系数 \\frac{a}{g} 和 \\frac{b}{g} 成为互质的整数，从而可以使用扩展欧几里得算法来求解简化后的方程。\n因为有了简化过程，所以结果出来时要乘上 \\frac{c}{g}来回复正常解\n\n\n"},"ACM/算法/线段树Seg/支持动态修改的线段树":{"slug":"ACM/算法/线段树Seg/支持动态修改的线段树","filePath":"ACM/算法/线段树Seg/支持动态修改的线段树.md","title":"支持动态修改的线段树","links":["ACM/算法/线段树Seg/支持区间查询的线段树"],"tags":[],"content":"动态修改\n作为一颗线段树，如果它只能查询而不能修改，就很容易被上位替代，而支持在O(\\log n) 下进行区间修改和区间查询，则是线段树最大的优势\n要实现区间修改，我们需要引入 lazy propagation即懒标记\n懒标记的作用我们用如下例子表示：\n\n假设我们需要对区间 [2,5] 的元素都+10，且当前节点[1,8] 覆盖了 [2,5]\n我们可以：\n\n不立即递归更新子节点\n在当前节点打上懒标记\n记录这个区间整体应该要+10\n只有当 下次访问到这个区间的子节点的时，才下传这个标记\n\n\n变化\n和支持区间查询的线段树的线段树相比，我们的结构体的存储信息应该多加上懒标记的信息\n同时我们需要多加一些函数来应用和下传懒标记，以及区间修改\n我们这次以支持模下运算的加法和乘法演示\nstruct Seg\n{\n    struct Node\n    {\n        i64 sum = 0, add = 0, mul = 1;\n    };\n    i64 n;\n    i64 mod;\n    vector&lt;Node&gt; seg;\n    Seg(i64 n, i64 mod)\n    {\n        this-&gt;n = n;\n        this-&gt;mod = mod;\n        seg.resize((n &lt;&lt; 2) + 4);\n    }\n    // 合并逻辑\n    Node merge(const Node &amp;L, const Node &amp;R)\n    {\n        Node res;\n        res.sum = (L.sum + R.sum) % mod;\n        res.add = 0;\n        res.mul = 1;\n        return res;\n    }\n    //懒标记应用\n    void applyadd(i64 idx, i64 l, i64 r, i64 val)\n    {\n        seg[idx].add = (seg[idx].add + val) % mod;\n        seg[idx].sum = (seg[idx].sum + val * (r - l + 1) % mod) % mod;\n    }\n    void applymul(i64 idx, i64 l, i64 r, i64 val)\n    {\n        seg[idx].mul = (seg[idx].mul * val) % mod;\n        seg[idx].sum = seg[idx].sum * val % mod;\n        seg[idx].add = seg[idx].add * val % mod;\n    }\n    // 懒标记向下应用\n    void push(i64 idx, i64 l, i64 r)\n    {\n        i64 &amp;_add = seg[idx].add;\n        i64 &amp;_mul = seg[idx].mul;\n        if (_add == 0 &amp;&amp; _mul == 1) return;\n        i64 mid = (l + r) &gt;&gt; 1;\n        applymul(idx &lt;&lt; 1, l, mid, _mul);\n        applymul(idx &lt;&lt; 1 | 1, mid + 1, r, _mul);\n        applyadd(idx &lt;&lt; 1, l, mid, _add);\n        applyadd(idx &lt;&lt; 1 | 1, mid + 1, r, _add);\n        _add = 0;\n        _mul = 1;\n    }\n    void build(i64 idx, i64 l, i64 r, const vint &amp;a)\n    {\n        if (l == r) {\n            seg[idx].sum = a[l];\n            seg[idx].add = 0;\n            return;\n        }\n        i64 mid = (l + r) &gt;&gt; 1;\n        build(idx &lt;&lt; 1, l, mid, a);\n        build(idx &lt;&lt; 1 | 1, mid + 1, r, a);\n        seg[idx] = merge(seg[idx &lt;&lt; 1], seg[idx &lt;&lt; 1 | 1]);\n    }\n    // 1是加法，2是乘法\n    void update(i64 idx, i64 l, i64 r, i64 ql, i64 qr, i64 val, i64 op)\n    {\n        if (op == 1) {\n            if (ql &lt;= l &amp;&amp; r &lt;= qr) {\n                applyadd(idx, l, r, val);\n                return;\n            }\n        }\n        if (op == 2) {\n            if (ql &lt;= l &amp;&amp; r &lt;= qr) {\n                applymul(idx, l, r, val);\n                return;\n            }\n        }\n        push(idx, l, r);\n        i64 mid = (l + r) &gt;&gt; 1;\n        if (ql &lt;= mid) update(idx &lt;&lt; 1, l, mid, ql, qr, val, op);\n        if (qr &gt; mid) update(idx &lt;&lt; 1 | 1, mid + 1, r, ql, qr, val, op);\n        seg[idx] = merge(seg[idx &lt;&lt; 1], seg[idx &lt;&lt; 1 | 1]);\n    }\n    Node query(i64 idx, i64 l, i64 r, i64 ql, i64 qr)\n    {\n        if (ql &lt;= l &amp;&amp; r &lt;= qr) return seg[idx];\n        push(idx, l, r);\n        i64 mid = (l + r) &gt;&gt; 1;\n        i64 res = 0;\n        if (qr &lt;= mid)\n            return query(idx &lt;&lt; 1, l, mid, ql, qr);\n        else if (ql &gt; mid)\n            return query(idx &lt;&lt; 1 | 1, mid + 1, r, ql, qr);\n        else\n            return merge(query(idx &lt;&lt; 1, l, mid, ql, qr), query(idx &lt;&lt; 1 | 1, mid + 1, r, ql, qr));\n    }\n    void build(const vint &amp;a)\n    {\n        build(1, 1, n, a);\n    }\n    void update(i64 l, i64 r, i64 val, i64 op)\n    {\n        update(1, 1, n, l, r, val, op);\n    }\n    i64 query(i64 l, i64 r)\n    {\n        return query(1, 1, n, l, r).sum % mod;\n    }\n};\n其实主要思想就是懒标记的使用和下传"},"ACM/算法/线段树Seg/支持区间查询的线段树":{"slug":"ACM/算法/线段树Seg/支持区间查询的线段树","filePath":"ACM/算法/线段树Seg/支持区间查询的线段树.md","title":"支持区间查询的线段树","links":[],"tags":[],"content":"引子：线段树是什么\n不知道你有没有被某些算法题搞得焦头烂额，例如给你Q次询问求区间和，区间最大最小，区间子段和这些神秘题目，但是现在，他们都将变成板子题！\n线段树是一种二叉树结构,其实作用是可以快速修改和查询,我们先从支持查询的线段数开始\n线段树思想\n\n线段树通过将一段区间不断二分，直到分解成单个节点的元素，然后通过合并子区间的信息从而得到父区间的结果，将区间问题变成 分治合并问题\n\n实现\n一颗完整的静态线段树需要进行\n\n建树\n合并\n查询\n\n这些操作\n维护信息\n根据题目的意义，我们的节点可能维护的信息是不一样的\n\n区间和(sum)\n区间最值(max / min)\n区间最大子段和 (sum,lmax,rmax,tmax)\n一般这些信息都被维护在一个结构体节点下\n\n\n我们接下来的演示都以 区间子段和 为例子进行演示\n\nstruct Node{\n\ti64 sum,lmax,rmax,tmax;\n}\n这个表示我们每个节点保存的信息是这个区间的区间和，区间前缀最大值，区间后缀最大值，区间子段最大值\n合并策略\n在有了维护信息之后我们就需要进行确定合并策略，不同的题目有不同的合并策略\n确定合并策略的思考点主要是去寻思两个区间的信息怎么通过一些手段变成他们合并后的信息\n下面给出一些合并策略\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n区间和\n\nres.sum = L.sum + R.sum;\n\n区间最大/最小值\n\nres.max = max(L.max,R.max);\nres.min = min(L.min,R.min);\n\n区间最大子段和\n\nres.sum = L.sum + R.sum;\nres.lmax = max(L.lmax,L.sum + R.lmax);\nres.rmax = max(R.rmax,L.rmax + R.sum);\nres.tmax = max({\n\tL.tmax,\n\tR.tmax,\n\tL.rmax + R.lmax\n});\n\n\n\n我们的写法则是：\nNode merge(const Node &amp;L, const Node &amp;R)\n{\n\tNode res;\n\tres.sum = L.sum + R.sum;\n\tres.lmax = max(L.lmax, L.sum + R.lmax);\n\tres.rmax = max(R.rmax, R.sum + L.rmax);\n\tres.tmax = max({L.tmax, R.tmax, L.rmax + R.lmax});\n}\n建树\n做好了一切的准备后我们便可以开始建树\n在建树的时候，我们主要用数组模拟树，同时使用位运算优化建树过程，递归的构建整棵树\n \nvector&lt;Node&gt; seg;\ni64 n;\n// 建树需要开四倍空间\nSeg(i64 n): n(n),seg(n * 4 + 4){}\n \nvoid build(i64 idx, i64 l, i64 r, const vint &amp;v)\n{\n\tif (l == r) {\n\t\ti64 val = v[l];\n\t\tseg[idx] = {val, val, val, val};\n\t\treturn;\n\t}\n\ti64 mid = (l + r) &gt;&gt; 1;\n\tbuild(idx &lt;&lt; 1, l, mid, v);\n\tbuild(idx &lt;&lt; 1 | 1, mid + 1, r, v);\n\tseg[idx] = merge(seg[idx &lt;&lt; 1], seg[idx &lt;&lt; 1 | 1]);\n}\n建树的时间复杂度为O(n)\n查询\n当查询到[ql,qr]区间时候：\n\n若当前节点 [l,r] 完全在区间 [ql,qr] 时，直接返回\n若有交叉，则递归到左右子区间\n再合并左右结果\n\nNode query(i64 idx, i64 l, i64 r, i64 ql, i64 qr)\n{\n\tif (ql &lt;= l &amp;&amp; r &lt;= qr) return seg[idx];\n\ti64 mid = (l + r) &gt;&gt; 1;\n\tif (qr &lt;= mid) {\n\t\treturn query(idx &lt;&lt; 1, l, mid, ql, qr);\n\t}\n\telse if (ql &gt; mid) {\n\t\treturn query(idx &lt;&lt; 1 | 1, mid + 1, r, ql, qr);\n\t}\n\telse {\n\t\treturn merge(query(idx &lt;&lt; 1, l, mid, ql, qr), query(idx &lt;&lt; 1 | 1, mid + 1, r, ql, qr));\n\t}\n}\n则整个树就建立完成了，这是最基本的静态查询线段树,线段树的区间查询是O(\\log n)\nstruct Seg\n{\n    struct Node\n    {\n        i64 sum, lmax, rmax, tmax;\n    };\n    i64 n;\n    vector&lt;Node&gt; seg;\n    Seg(i64 n): n(n), seg(4 * n + 4, Node()) { }\n    //\n    Node merge(const Node &amp;L, const Node &amp;R)\n    {\n        Node res;\n        res.sum = L.sum + R.sum;\n        res.lmax = max(L.lmax, L.sum + R.lmax);\n        res.rmax = max(R.rmax, R.sum + L.rmax);\n        res.tmax = max({L.tmax, R.tmax, L.rmax + R.lmax});\n    }\n    void build(i64 idx, i64 l, i64 r, const vint &amp;v)\n    {\n        if (l == r) {\n            i64 val = v[l];\n            seg[idx] = {val, val, val, val};\n            return;\n        }\n        i64 mid = (l + r) &gt;&gt; 1;\n        build(idx &lt;&lt; 1, l, mid, v);\n        build(idx &lt;&lt; 1 | 1, mid + 1, r, v);\n        seg[idx] = merge(seg[idx &lt;&lt; 1], seg[idx &lt;&lt; 1 | 1]);\n    }\n    Node query(i64 idx, i64 l, i64 r, i64 ql, i64 qr)\n    {\n        if (ql &lt;= l &amp;&amp; r &lt;= qr) return seg[idx];\n        i64 mid = (l + r) &gt;&gt; 1;\n        if (qr &lt;= mid) {\n            return query(idx &lt;&lt; 1, l, mid, ql, qr);\n        }\n        else if (ql &gt; mid) {\n            return query(idx &lt;&lt; 1 | 1, mid + 1, r, ql, qr);\n        }\n        else {\n            return merge(query(idx &lt;&lt; 1, l, mid, ql, qr), query(idx &lt;&lt; 1 | 1, mid + 1, r, ql, qr));\n        }\n    }\n};"},"ACM/算法/贪心":{"slug":"ACM/算法/贪心","filePath":"ACM/算法/贪心.md","title":"贪心","links":["tags/贪心"],"tags":["贪心"],"content":"贪心\n贪心\n\n每一步再选择中都选择当前状态下的最优解\n通过局部最优解做到全局最优解\n例：\n\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n{\n    int N ,sum = 0,p = 1,j =0,emp = 0;\n    cin &gt;&gt; N;\n    int arr[N] = {0};\n    int arrp[N] = {0};\n    for (size_t i = 1; i &lt;= N; i++)\n    {\n        cin &gt;&gt; arr[i];\n    }\n    sort(arr+1,arr+N+1);\n    \n    if (N == 1)\n    {\n        cout &lt;&lt; arr[1];\n        return 0;\n    }\n \n    while (1)\n    {\n        if (N - j == 2 || N - j == 1)\n        {\n            sum += arr[2];\n            break;\n        }\n        sum += arr[1] + 2*arr[2] + arr[N-j];\n        j += 2;\n    }\n    cout &lt;&lt; sum;\n    \n    return 0;\n \n}\n\n\n                  \n                  Note\n                  \n                \n\n\n\n这题的题解找个时间我再写\n\n\n\n"},"ACM/算法/递归":{"slug":"ACM/算法/递归","filePath":"ACM/算法/递归.md","title":"递归","links":["tags/递归与递推","ACM/算法/深度优先搜索-DFS","ACM/算法/递推"],"tags":["递归与递推"],"content":"递归与递推\n递归\n递归的定义：函数的自我调用\n例：\n\n利用递归实现阶乘\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint out(int n)\n{\n\tint res;\n\tif (n == 1)\n\t{\n\t\tres = 1;\n\t}\n\telse\n\t{\n\t\tres = out(n-1)*n; //在这里又调用了一次out,即out(n-1) = out(n-2)*(n-1)\n\t}\n\treturn res;\n}\n \nint main()\n{\n\tcout &lt;&lt; out(5);\n\treturn 0;\n}\n\n基于递归的算法\n\n深度优先搜索 DFS\n\n\n\n\n学递归有感而发：\n\n只有上帝和出题人知道递归传参究竟是怎么传的\n\n\n\n\n递归的缺陷\n使用递归计算斐波那契数列数列第n项(n &lt; 50)\n\nint f(int n)\n{\n\tint res;\n\tif (n == 1 || n == 2)\n\t{\n\t\tres = 1;\n\t}\n\telse\n\t{\n\t\tres = f(n-1)+f(n-2);\n\t}\n\t\n\treturn res;\n}\n \nint main()\n{\n\tfor (size_t i = 1; i &lt;= 50; i++)\n\t{\n\t\tcout &lt;&lt; i &lt;&lt;&quot;\t&quot;&lt;&lt;f(i) &lt;&lt;endl;\n\t}\n\t\n\treturn 0;\n}\n\n运行不难发现，在第46项以后，运行极为缓慢\n由此引入 递推\n"},"ACM/算法/递推":{"slug":"ACM/算法/递推","filePath":"ACM/算法/递推.md","title":"递推","links":["tags/递归与递推"],"tags":["递归与递推"],"content":"递归与递推\n递推\n\n从1开始，向下求解，直到输出正确函数\n用若干重复计算解决实际问题的方法\n找规律构成递推式\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n{\n\tlong arr[60] = {0};\n\tarr[1] = 1;\n\tarr[2] = 1;\n\tfor (size_t i = 3;i &lt;= 50; i++)\n\t{\n\t\tarr[i] = arr[i-1] + arr[i-2];\n\t}\n\tfor (size_t i = 1; i &lt;= 50; i++)\n\t{\n\t\tcout &lt;&lt; i &lt;&lt;&quot;\t&quot;&lt;&lt; arr[i] &lt;&lt;endl;\n\t}\n\treturn 0;\n}\n\n又找到一道递推好题 洛谷P1044[栈]\n上代码：\n\n/*\n    P1044递推解法\n    注意到待入栈数n里的第k个数: 设其方案有f[k] (k &gt; 0)\n    则再设 k 前面的数的排列方式有 f[k-1] 种\n    k 后面的数的排列方式有 f[n-k]种\n    根据组合数原理: f[k] = f[k-1] * f[n-k]\n    则有  f[n] = sum_{k = 0}^{n-1} f[k] 即 f[n] = f[0]f[n-1] + f[1]f[n-2] ...... + f[n-1]f[0]\n    简单分析不难发现f[0] = 1 , f[1] = 1, f[2] = 2;\n*/\n \n#include &lt;bits/stdc++.h&gt;\n#define endl &quot;\\n&quot;\nusing namespace std;\n \nint main()\n{\n    int n;\n    long long f[20] = {1,1,2};\n    cin &gt;&gt; n;\n    //在这里 i 表示上文的 n ; j 表示上文的 k;\n    //因为f[0] , f[1] , f[2] 均已明确 i 从 3 开始算;\n    for (size_t i = 3; i &lt;= n; i++)\n    {\n        for (size_t j = 1; j &lt;= i; j++)\n        {\n            f[i] += f[j-1]*f[i-j];\n        }\n    }\n    cout &lt;&lt; f[n];\n    return 0;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n主要在于对N里的任何一项k存在：f(k) = f(k-1)\\times f(n-k)\nf(k)表示第k项的情况:\n则f(N) = \\sum_{k=1}^{N-1}f(k)\n即：f(n) = f(0)f(n-1) + f(1)f(n-2) ...... + f(n-1)f(0)\n\n\n"},"ACM/算法/高精度":{"slug":"ACM/算法/高精度","filePath":"ACM/算法/高精度.md","title":"高精度","links":["tags/模拟","tags/高精度"],"tags":["模拟","高精度"],"content":"模拟 高精度\n高精度\n\n一般而言，在long long 格式下的字符占用有8个字节，其范围是-2^63^~2^63^-1(19位数)这个区间，那么，超过这个区间的计算我们又该如何进行呢？\n\n1 高精度加法\n\n在进行超过19位数相加的大数加法的时候，我们可以模拟竖式加法的原理，对数组进行操作\n如图\n\n\n\n使用字符串获取大数字\n将字符串的数字提取出来逆序储存在数组中\n对数组中的数组做加法并存储到另一个数组中\n逆序输出数组\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n{\n    string s1,s2;\n    int a1[210],a2[210],a3[210] = {0};\n    getline(cin,s1);\n    getline(cin,s2);\n    for (size_t i = 0; i &lt; s1.size(); i++)\n    {\n        a1[s1.size()-i-1] = s1[i] - &#039;0&#039;;\n    }\n    for (size_t i = 0; i &lt; s2.size(); i++)\n    {\n        a2[s2.size()-i-1] = s2[i] - &#039;0&#039;;\n    }\n    int len = max(s1.size(),s2.size()); \n    for (size_t i = 0; i &lt; len;i++)\n    {\n        a3[i] = a1[i] + a2[i];\n    }\n    for (size_t i = 0; i &lt; len; i++)\n    {\n        if (a3[i] &gt;= 10)\n        {\n            a3[i + 1] = a3[i]/10;\n            a3[i] = a3[i]%10;\n        }\n    }\n    if (a3[len] != 0)\n    {\n        len++;\n    }\n    for (int i = len - 1; i &gt;= 0; i--)\n    {\n        cout &lt;&lt; a3[i];\n    }\n    return 0;\n}\n\n更好用的字符串 string类型的高精度\n\nstring largeadd(string&amp; a, string&amp; b)\n{\n    if (a.size() &lt;= b.size()) swap(a, b);\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++) {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        int bi = b[b.size() - i - 1] - &#039;0&#039;;\n        int sum = ai + bi + p;\n        if (sum &gt;= 10) {\n            p = 1;\n            sum -= 10;\n        } else p = 0;\n        a[a.size() - 1 - i] = sum + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++) {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == &#039;9&#039; &amp;&amp; p == 1) {\n            a[a.size() - i - 1] = &#039;0&#039;;\n        } else {\n            a[a.size() - i - 1] = ai + p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    if (p == 1) a.insert(a.begin(), &#039;1&#039;);\n    return a;\n}\n2 高精度减法\n\n与加法类似，主要是注意借位与进位的不同\n负数的处理\n\nstring largemin(string a, string b)\n{\n    int flag = 0;\n    if (b.size() &gt;= a.size()&amp;&amp; b &gt;= a) {\n        swap(a, b);\n        flag = 1;\n    }\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++) {\n        int ai = a[a.size() - 1 - i] - &#039;0&#039;;\n        int bi = b[b.size() - 1 - i] - &#039;0&#039;;\n        int diff = ai - bi - p;\n        if (diff &lt; 0) {\n            p = 1;\n            diff += 10;\n        } else p = 0;\n        a[a.size() - i - 1] = diff + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++) {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == 0 &amp;&amp; p == 1) {\n            a[a.size() - i - 1] = &#039;9&#039;;\n        } else {\n            a[a.size() - i - 1] = ai - p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    while (*a.begin() == &#039;0&#039; &amp;&amp; a.size() &gt; 1)\n        a.erase(a.begin());\n    if (flag) a.insert(a.begin(), &#039;-&#039;);\n    return a;\n}\n3 高精度乘法\n\n\n                  \n                  Tip\n                  \n                \n\n\n对于乘法来说，高精度的最佳计算思维就是将两个数拆分，用一个数的个十百位依次去乘以另一个数\n拿我们常用的，主要的步骤有以下几点：\n\n字符串化数字，倒置字符串\n两位相乘，计算结果与储存位数\n数组变字符串\n\n\n\n\n//#pragma GCC optimize(2)\n#include &lt;bits/stdc++.h&gt;\n#define endl &#039;\\n&#039;\nusing namespace std;\n \nstring largemuiti(string a, string b)\n{\n    if (a == &quot;0&quot; || b == &quot;0&quot;) return &quot;0&quot;;\n    int len1 = a.size();\n    int len2 = b.size();\n    vector&lt;int&gt; result(len1 + len2, 0);\n    for (int i = len1 - 1; i &gt;= 0; i--) {\n        for (int j = len2 - 1; j &gt;= 0; j--) {\n            int mult = (a[i] - &#039;0&#039;) * (b[j] - &#039;0&#039;);\n            int sum = result[i + j + 1] + mult;\n            result[i + j + 1] = sum % 10;\n            result[i + j] += sum / 10;\n        }\n    } \n    string res = &quot;&quot;;\n    for (size_t i = 0; i &lt; result.size(); i++) {\n        if (!(result[i] == 0 &amp;&amp; res.empty())) {\n            res += to_string(result[i]);\n        }\n    }\n    return res;\n}\n \nint main()\n{\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cout &lt;&lt; largemuiti(&quot;123&quot;, &quot;234&quot;);\n    return 0;\n}"},"ACM/题解/Atcoder/ABC-418":{"slug":"ACM/题解/Atcoder/ABC-418","filePath":"ACM/题解/Atcoder/ABC-418.md","title":"ABC-418","links":[],"tags":[],"content":"A\n签到,使用substr()方法即可得出答案\nB\n注意到当 t 连续出现三次的时候可以组成一个覆盖率1的情况"},"ACM/题解/Codeforces/CR1037-div.3-题解":{"slug":"ACM/题解/Codeforces/CR1037-div.3-题解","filePath":"ACM/题解/Codeforces/CR1037 div.3 题解.md","title":"CR1037 div.3 题解","links":[],"tags":[],"content":"CR1037 题解\nA\n题意 :\n输入一个数n,找到最小的和它有共同数字的数 k\n思路:\n显然k就是这个数n的所有位数的最小的那一位\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    string s = to_string(n);\n    sort(all(s));\n    cout &lt;&lt; s[0] &lt;&lt; endl;\n}\n\nB\n题意:\n给定一个包含n个元素的数组A和一个数k ,A中的每个元素由 0,1 构成,需要我们寻找k数量的连续0串且每个串之间需要有一个元素相隔\n思路:\n直接模拟即可\nvoid solve()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vint v(n);\n    for (auto &amp;&amp;i : v) {\n        cin &gt;&gt; i;\n    }\n    int cnt = 0;\n    int now = 0;\n    for (size_t i = 0; i &lt; n; i++)\n    {\n        if(v[i] == 0)now++;\n        if(v[i] == 1)now = 0;\n        if(now == k){\n            i++;\n            cnt++;\n            now = 0;\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; endl;\n}\n\nC\n题意:\n给定两个数 n,k 和一个有 n 个元素的数组 A ,有一个从0开始的每秒加1的水位,数组A中的元素a_i表示第i座塔的高度,你初始在a_k 高度的塔上,你可以花费 |a_j - a_i| 的时间从第i座塔移动到第j座塔,当水位完全超过你所在塔的高度的时候便会失败\n你需要判断能否到达最高的塔而不失败\n思路:\n我们考虑贪心,因为水位上涨速度与我们移动速度是一致的,故只要从我们目前所在高度的 a_i 到最高位置 a_{max} 之间从小到大两两的距离差都小于初始高度a_i 我们就可以到达最高的塔\nvoid solve()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vint v(n);\n    for (auto &amp;&amp;i : v) {\n        cin &gt;&gt; i;\n    }\n    int under = v[k - 1];\n    // 贪心:一开始所在位置就是我们能跨越的最大位置,而且我们只需要看比一开始大的\n    ranges::sort(v);\n    vint res;\n    for (size_t i = 0; i &lt; n; i++) {\n        if (v[i] &gt;= under) {\n            res.emplace_back(v[i]);\n        }\n    }\n    vint diff(n,0);\n    for (size_t i = 0; i + 1 &lt; res.size(); i++) {\n        diff[i] = res[i + 1] - res[i];\n    }\n    cout &lt;&lt; (ranges::max(diff) &gt; under ? &quot;NO&quot; : &quot;YES&quot;) &lt;&lt; endl;\n}\n\nD\n题意:\n给定 n 个赌场,其有三个参数 l,r,real ,再给定初始金币 k ,规定持有金币数量p每个赌场只能允许p \\in [l,r] 进入并且会将 p 变为 real ,并且每个赌场只能进入一次\n我们需要知道我们在参加任意次赌场后获得的最大金币数量为多少\n思路:\n由于我们需要最大的金币数量,所以我们每一次游玩后都想要金币尽可能上涨,这里我们考虑使用 大堆顶 即优先队列来筛选,其存放数据为\\{r,real\\}\n具体做法是\n\n先将所有赌场的进入门槛 l 从小到大排序\n然后进行循环,首先令 now = k\n\n对当前金币now ,将l \\le now 的放入大堆顶,这样存放进入的数据中会按照real的大小排序\n对堆里的数据,先排除 r &lt; now 的\n如果堆空了或者堆顶的real \\le now 的话说明已经没有比 now 还大的元素了,那么我们就退出循环\n否则就将 now 赋值为堆顶的real 代表这一轮找到了最大的real_i 然后重复循环\n\n\n\nstruct st\n{\n    int l, r, re;\n};\n \nvoid solve()\n{\n    int n,k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;st&gt; v(n);\n    for (size_t i = 0; i &lt; n; i++)\n    {\n        auto &amp;&amp;[l, r, t] = v[i];\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n    }\n    ranges::sort(v, [](st a, st b) { return a.l &lt; b.l; });\n    priority_queue&lt;pii&gt; pq;\n    int now = k;\n    int idx = 0;\n    while (1)\n    {\n        while (idx &lt; n &amp;&amp; v[idx].l &lt;= now)\n        {\n            pq.emplace(v[idx].re, v[idx].r);\n            idx++;\n        }\n        // 排除 r &lt; now的\n        while (!pq.empty() &amp;&amp; pq.top().second &lt; now)\n        {\n            pq.pop();\n        }\n        // 如果空或者没有比x大的,那么就退出\n        if (pq.empty() || pq.top().first &lt;= now) {\n            break;\n        }\n        // 提升now\n        now = pq.top().first;\n        pq.pop();\n    }\n    cout &lt;&lt; now &lt;&lt; endl;\n}\n"},"ACM/题解/Codeforces/Codeforces-Global-Round-29(1+2)":{"slug":"ACM/题解/Codeforces/Codeforces-Global-Round-29(1+2)","filePath":"ACM/题解/Codeforces/Codeforces Global Round 29(1+2).md","title":"Codeforces Global Round 29(1+2)","links":[],"tags":[],"content":"A\n注意到我们先走的一步必须小于后走的一步\n\n当 x &lt; y时候一步x一步y即可\n当y = 1 时候无论如何走都无法走到\n当x &gt; y 时候，必须满足x - 1 &gt; y因为第一步走1,然后走向上走y，最后走到(x,y),即三步\n\nAc solution\nvoid solve()\n{\n    i64 x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    if (x &lt; y) {\n        cout &lt;&lt; 2 &lt;&lt; endl;\n        return;\n    }\n    if (x - 1 &gt; y &amp;&amp; y != 1) {\n        cout &lt;&lt; 3 &lt;&lt; endl;\n        return;\n    }\n    cout &lt;&lt; -1 &lt;&lt; endl;\n    return;\n}\nB\n我们的目标是将2个一样的n排列放入一个长度为2n的数组中并且两个相同元素下标差为当前元素的倍数\n注意到这样的排序：\n[n,n-1,\\cdots,3,2,1,n,1,2,3,\\cdots,n-1]\n满足题意\n同样成立的还有\n先排序所有偶数，在结果{\\cdots,2,x,2,\\cdots}中的x位置填入最大奇数，然后以此往下排列即可\nAc solution\nvoid solve()\n{\n    i64 n;\n    cin &gt;&gt; n;\n    vector&lt;i64&gt; res(2 * n + 1);\n    i64 idx = 1;\n    for (i64 i = n; i &gt;= 1; i--) {\n        if (i % 2 == 0) {\n            res[idx] = i;\n            res[idx + i] = i;\n            idx++;\n        }\n    }\n    idx = n / 2 + 1;\n    for (i64 i = n; i &gt;= 1; i--) {\n        if (i &amp; 1) {\n            res[idx] = i;\n            if (i == 1) {\n                res[2 * n] = 1;\n                break;\n            }\n            res[idx + i] = i;\n            while (res[idx] != 0) {\n                idx++;\n            }\n        }\n    }\n    for (i64 i = 1; i &lt;= 2 * n; i++) {\n        cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;\n    }\n \n    cout &lt;&lt; endl;\n}\nC\n思维题，考虑下面情况\n\n\n“1010” : 选择两个兔子互相向下标2位置跳，冲突，得以固定\n\n\n“11011”: 无约束，兔子任意跳跃，无法固定\n\n\n“1010101”: 对于下标1,3兔子可以用第一种方式固定，但是对于下标为5的兔子就无法固定\n\n\n“000” ：兔子互相面向跳跃，得以固定\n\n\n我们不难看出，只需要寻找类似 “101010…”的交替子串就可以确定这一堆兔子能否被固定，具体而言，就是当交替子串的’0’个数是偶数时候可以固定，遍历一遍即可，复杂度O(n)\nAc solution\nvoid solve()\n{\n    i64 n;\n    string s;\n    cin &gt;&gt; n &gt;&gt; s;\n \n    bool ok = 1;\n    for (i64 i = 0; i &lt; n &amp;&amp; ok;) {\n        i64 j = i;\n        while (j + 1 &lt; n &amp;&amp; s[j + 1] != s[j]) j++;\n        if (s[i] == &#039;1&#039; &amp;&amp; s[j] == &#039;1&#039;) {\n            i64 cnt0 = 0;\n            for (i64 k = i; k &lt;= j; k++)\n                if (s[k] == &#039;0&#039;) cnt0++;\n            if (cnt0 &amp; 1) ok = 0;\n        }\n        i = j + 1;\n    }\n \n    cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;\n}\nD\n我说 D &lt;&lt; C\n显然对于偶数，其对差值的贡献为0,我们只需要考虑奇数的情况，排序然后模拟就好了，每次经过一次奇数，下一次奇数都会是对方先选，所以Alice一定会先选最大的奇数\n主要是排序贡献的复杂度O(n\\log n)\nAc solution\nvoid solve()\n{\n    i64 n;\n    cin &gt;&gt; n;\n    vint v(n);\n    map&lt;i64, i64&gt; mp;\n    for (i64 i = 0; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n        mp[v[i]]++;\n    }\n    vpii vp(all(mp));\n    ranges::sort(vp, [](pii a, pii b) { return a.second &gt; b.second; });\n    i64 ans1 = 0, ans2 = 0;\n    i64 cur = 0;\n    for (auto &amp;&amp;[a, b] : vp) {\n        if (a % 2 == 0) {\n            ans1 += b * (a / 2);\n            ans2 += b * (a / 2);\n        }\n        else {\n            if (cur == 0) {\n                ans1 += b * ((a + 1) / 2);\n                ans2 += b * (a / 2);\n            }\n            else {\n                ans2 += b * ((a + 1) / 2);\n                ans1 += b * (a / 2);\n            }\n            cur ^= 1;\n        }\n    }\n    cout &lt;&lt; ans1 &lt;&lt; &quot; &quot; &lt;&lt; ans2 &lt;&lt; endl;\n}"},"ACM/题解/散题题解/题解I":{"slug":"ACM/题解/散题题解/题解I","filePath":"ACM/题解/散题题解/题解I.md","title":"题解I","links":["ACM/算法/数论/整除分块"],"tags":[],"content":"Problem - 2144D - Codeforces\n\n\n                  \n                  Background \n                  \n                \n\n\n给定一个数组A和两个整数k,x其中x &gt; 1你需要求出\\sum\\limits_{i=1}^{n-1} \\left\\lceil \\frac{a_{i}}{x} \\right\\rceil,同时k表示a_{i}变为\\left\\lceil \\frac{a_{i}}{x} \\right\\rceil后需要的代价,但是如果原本的数组中存在元素 \\left\\lceil \\frac{a_{i}}{x} \\right\\rceil 就不用付出代价,你的任务是最大化 \\sum\\limits_{i=1}^{n-1} \\left\\lceil \\frac{a_{i}}{x} \\right\\rceil - q其中q代表付出的总代价\n\n\n\n我们最核心需要解决的问题是解决题目的求和式子,对于这个式子,我们可以将其映射到[1 - n]长度数组中,这样方便我们进行下面的整除分块\n同时这是一个变形的整除分块问题,与一般整除分块的分子分母呈反关系,我们来研究这个式子\n对于\\sum\\limits_{i=1}^{n} \\left\\lceil \\frac{{i}}{x} \\right\\rceil有固定x,其值一定是类似1\\ 1\\ 1\\ 2\\ 2\\cdots上升的,而对于每个块的长度,不难看出都是x\n有了块长,块值,我们可以这样书写这个代码\nfor(i64 l = 1,k = 1;l &lt;= n;l += x,k++){\n\ti64 r = max(n,l + x - 1);\n\t// k是整除数\n\t// x是当前分母\n}\n这个算法复杂度为O\\left(\\left\\lceil \\frac{{n}}{x} \\right\\rceil\\right)\n那对于这一题我们就可以枚举分母x然后对每个分母求和进行整除分块,同时我们前面映射到连续[1 - n]的cnt数组也是方便我们进行分块\nAC solution\nvoid solve()\n{\n    i64 n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vint c(n);\n    vint cnt(2e5 + 10);\n    i64 maxnum = -1;\n    // cout &lt;&lt; mp[0] &lt;&lt; endl;\n    for (i64 i = 0; i &lt; n; i++) {\n        cin &gt;&gt; c[i];\n        cnt[c[i]]++;\n        maxnum = max(maxnum, c[i]);\n    }\n    i64 ans = LLONG_MIN;\n    if (maxnum == 1) {\n        cout &lt;&lt; n &lt;&lt; endl;\n        return;\n    }\n    vint pre(maxnum + 10);\n    for (i64 i = 1; i &lt;= maxnum; i++) {\n        pre[i] = pre[i - 1] + cnt[i];\n    }\n    for (i64 x = 2; x &lt;= maxnum + 1; x++) {\n        i64 kk = 0;\n        i64 p = 0;\n        for (i64 l = 1, op = 1; l &lt;= maxnum; l += x, op++) {\n            // op 整除数\n            i64 r = min(l + x - 1, maxnum);\n            if (l &gt; r) continue;\n            // 块长 \n            i64 LR = r - l + 1;\n            // 块内容\n            i64 k2 = pre[r] - pre[l - 1];\n            // 块贡献\n            p += k2 * op;\n            kk += (cnt[op] &gt;= k2 ? k2 : cnt[op]);\n        }\n        ans = max(ans, p - max(0ll, n - kk) * k);\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nProblem - D - Codeforces\n\n\n                  \n                  backgrounds \n                  \n                \n\n\n我们需要从一个无穷序列12345\\cdots910111213\\cdots中求出第k个下标前所有数的总和\n\n\n\n一个很麻烦的数学与数论模拟\n我们的主要思路是求出k下标代表的数然后求和前面所有数的数位和然后加上自身的剩余的数字\n对于这个无穷数列,我们可以将其看作是多个数块\n\n1数块,由 [1,9] 构成,每个数1位,一共占据9个位置\n2数块,由 [10,99] 构成,每个数占2位,一共占据90 \\times 2 = 180个位置\nd数块,由 [10^{d-1},10^{d}-1] 构成,每个数占d位,一共占据9 \\times 10^{d-1} \\times d 个位置\n\n我们需要确定k处于第几个数块之中,然后将k所属数块前的所有数块的数位和加起来,最后再计算k所处的不完整数块的和,并且相加\n计算数位之和不能使用常规思路,否则会超时,这里介绍一种计算\\sum\\limits_{i = 1}^{n}d(i)的思路\n\n\n                  \n                  Important\n                  \n                \n\n\n当我们计算d(i)时候我们可以按照数位的贡献来计算,例如计算d(114)\n\n个位数的贡献:\n\n从 [1 , 110] 0~9完整的循环了11次,其和为11*45\n从 [111,114] 有1 2 3 4,和为10\n\n\n十位数的贡献:\n\n从 [1,99] 0~9 在100个数中完整循环1次,和为1*10*45\n从 [100,110] 有和为10\n\n\n以此类推迭代\n\n\n\n\nsolution\nunordered_map&lt;i64, i64&gt; mp;\ni64 f(i64 n)\n{\n    if (mp.contains(n)) return mp[n];\n    if (n &lt; 10) return n * (n + 1) / 2;\n    string s = to_string(n);\n    i64 d = s.size();\n    i64 p = 1;\n    for (i64 i = 0; i &lt; d - 1; i++) {\n        p *= 10;\n    }\n    // 第一个数位\n    i64 d1 = n / p;\n    i64 res = 1;\n    res = d1 * f(p - 1)             // 这部分计算 0-99, 100-199, 200-299 中除了最高位之外的数字和\n          + (d1 * (d1 - 1) / 2) * p // 这部分计算最高位的和，例如 100-199 的最高位&#039;1&#039;，200-299的最高位&#039;2&#039;\n          + d1 * (n % p + 1)        // 这部分计算当前最高位的和,例如 300-345 的最高位&#039;3&#039;\n          + f(n % p);               // 这部分计算末尾不完整部分\n \n    mp[n] = res;\n    return res;\n};\n有了解决方案就可以按我们说的方法去写代码了,代码写起来还是很考验代码力的\nAC Solution\nvoid solve()\n{\n    i64 k;\n    cin &gt;&gt; k;\n    i64 sum = 0, d = 1, cnt = 9, pow10 = 1;\n    while (1) {\n        // 第几个数块\n        i64 d_block = d * cnt;\n        if (k &gt; d_block) {\n            k -= d_block;\n            i64 l = pow10, r = pow10 * 10 - 1;\n            sum += f(r) - f(l - 1);\n            // 更新到下一个块\n            d++;\n            cnt *= 10;\n            pow10 *= 10;\n        }\n        else\n            break;\n    }\n    i64 num = (k - 1) / d;\n    if (num &gt; 0) {\n        i64 l = pow10, r = l + num - 1;\n        sum += f(r) - f(l - 1);\n    }\n    i64 last = (k - 1) % d + 1;\n    i64 pnum = pow10 + num;\n    string pnums = to_string(pnum);\n    for (i64 i = 0; i &lt; last; i++) {\n        sum += (pnums[i] - &#039;0&#039;);\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}\n2139 C\n被初见杀了，主要思路是从结果出发，将题目限定条件带入就能得到正解\n\n这类题的特点是正常往下进行会有很多支路，但是从结果出发就会发现只有一条路径走向结果\n\nAC solution\nvoid solve()\n{\n    i64 k, x;\n    cin &gt;&gt; k &gt;&gt; x;\n    i64 have = (1ll &lt;&lt; k);\n    i64 sum = have * 2;\n    i64 b = sum - x;\n    i64 cnt = 0;\n    vint res;\n    while (x != have) {\n        if (x * 2 &gt; sum) {\n            x -= b;\n            b *= 2;\n            res.emplace_back(2);\n        }\n        else if (x * 2 &lt; sum) {\n            b -= x;\n            x *= 2;\n            res.emplace_back(1);\n        }\n    }\n    ranges::reverse(res);\n    cout &lt;&lt; res.size() &lt;&lt; endl;\n    for (auto &amp;&amp;i : res) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}\nProblem - 2149E - Codeforces\n\n\n                  \n                  Note\n                  \n                \n\n\n想要实现这个，其实可以用容斥差分来写\n对于目标:正好到 k 个可以分解为\n\n最多有 k 个\n最多有 k - 1个\n\n\n\n\n我们令G(k,t)表示最长为t的子区间中最多有k个的情况，那么我们的答案即可表示为：\nG(k,r) - G(k,l-1) -G(k-1,r)+G(k-1,l-1)\n对于每一个情况，我们采用滑动窗口的形式来解决问题\nAC solution\nvoid solve()\n{\n    i64 n, k, l, r;\n    cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; r;\n    vint a(n);\n    for (i64 i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n    // 我们统计最多为k and k - 1 的区间然后相减\n    // 做一次容斥差分\n    auto f = [&amp;](i64 x, i64 len) -&gt; i64 {\n        if (x &lt; 0 || len &lt;= 0) return 0;\n        map&lt;i64, i64&gt; freq;\n        i64 dis = 0;\n        i64 res = 0;\n        i64 L = 0;\n        for (i64 R = 0; R &lt; n; R++) {\n            freq[a[R]]++;\n            if (freq[a[R]] == 1) {\n                dis++;\n            }\n            // 保证元素数小于k\n            while (dis &gt; x) {\n                freq[a[L]]--;\n                if (freq[a[L]] == 0) dis--;\n                L++;\n            }\n            // 保证长度小于len\n            while (R - L + 1 &gt; len) {\n                freq[a[L]]--;\n                if (freq[a[L]] == 0) dis--;\n                L++;\n            }\n            // 以R为右端点的合法区间数\n            res += R - L + 1;\n        }\n        return res;\n    };\n \n    i64 ans = f(k, r) - f(k, l - 1) - f(k - 1, r) + f(k - 1, l - 1);\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n\nProblem - 1095C - Codeforces\n贪心 + 二进制拆分\n\n这题思路想出来不难，但是对于代码力有一定要求\n我们不难发现，对于这个k符合的条件应该是小于数n且大于n的二进制中1的数量\n那我们就按照这个思路，记录有多少个1,并且拆分这些1,具体来说，对于一个二次幂数2^p，我们可以拆成2\\cdot 2^{k-1} 这样使用的1就增加了一个，我们的目标是使用k个1\n\nAc solution\nvoid solve()\n{\n    i64 n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    i64 p = __builtin_popcountll(n);\n    if (k &gt; n || k &lt; p) {\n        cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n        return;\n    }\n    vint cnt(64, 0);\n    for (i64 i = 0; i &lt; 63; i++) {\n        if ((n &gt;&gt; i) &amp; 1) cnt[i]++;\n    }\n    i64 cur = p;\n    while (cur &lt; k) {\n        i64 i = 62;\n        for (; i &gt;= 0; i--) {\n            if (cnt[i] &gt; 0) break;\n        }\n        cnt[i]--;\n        cnt[i - 1] += 2;\n        cur++;\n    }\n    vint ans;\n    for (i64 i = 0; i &lt; 63; i++) {\n        while (cnt[i] &gt; 0) {\n            ans.emplace_back(1ll &lt;&lt; i);\n            cnt[i]--;\n        }\n    }\n    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n    for (auto &amp;&amp;i : ans) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n}\n1057-D\n这是一道DP，我们的目标是将所有的元素在环形数组中左右至少有一个元素与其相邻，我们每次的操作可以将任意一个元素+1 or -1\n我们注意两种可行的操作\n\n将元素a_i,a_{i+1}变为一致的\n将元素a_{i},a_{i+1},a_{i+2}变为一致的\n\n我们设计这样一个dp，其中dp[i]表示复原前i个所需要的最小代价\n那么根据我们上面的可行操作设计两种状态转移\n\ndp[i + 2] = min(dp[i + 2],dp[i] + cost)\ndp[i + 3] = min(dp[i + 3],dp[i] + cost)\n其中cost是上面两种操作所花费的cost\r\n同时我们需要注意由于是环状数组，所以我们需要向后偏移三次实现最后面和开始的计数\n\n现在我们来论证为什么是这两个操作\n\n对于操作1,实际上是将数组分为2个2个的块，保证每个块都是相等的\n对于操作2,实际上保证的3个的块是相等的\n\n对于更多的如(4个，5个)，都可以通过操作2和操作3叠加而来\n\n\n\nAC Solution\nvoid solve()\n{\n    i64 n;\n    cin &gt;&gt; n;\n    vint a(2 * n + 2);\n    for (i64 i = 1; i &lt;= n; i++) {\n        i64 num;\n        cin &gt;&gt; num;\n        a[i] = num, a[n + i] = num;\n    }\n    i64 ans = 1e18;\n    auto clac = [](i64 a, i64 b, i64 c) { return max({a, b, c}) - min({a, b, c}); };\n    for (i64 l = 1; l &lt;= 3; l++) {\n        vint dp(n + 1, 1e18);\n        dp[0] = 0;\n        for (i64 i = 0; i &lt; n; i++) {\n            if (i + 2 &lt;= n) {\n                i64 cost = abs(a[i + l] - a[i + 1 + l]);\n                dp[i + 2] = min(dp[i + 2], dp[i] + cost);\n            }\n            if (i + 3 &lt;= n) {\n                i64 cost = clac(a[l + i], a[l + i + 1], a[l + i + 2]);\n                dp[i + 3] = min(dp[i + 3], dp[i] + cost);\n            }\n        }\n        ans = min(ans, dp[n]);  \n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n1043-E\n神秘题目:\n\n给定一个数组，问你删去0 \\sim k 个数情况下MEX的可能的值有多少种\n\n我们考虑MEX(v) = m 时候的情况，即 0 \\sim m- 1至少出现一次，同时 m 必须不存在\n接着我们考虑删除 k 个数的影响\n我们删除k个数后，可能的MEX取决于\n\n我们不能清空某个值出现的情况\n可以保留某一个区间的完整性\n\n我们利用差分数组来计算答案，从删去freq[i]开始，MEX = i + 1 的情况，由于删除的元素最多为n个，所以区间的右端为n - i + 1\n特别的，当出现freq[i] == 0时候，表示MEX最多到i，之后不会继续\nans数组是diff数组的前缀\nAC solution\n//#pragma GCC optimize(3)\n#include &lt;bits/stdc++.h&gt;\n#define endl &#039;\\n&#039;\n#define all(v) v.begin(), v.end()\nusing namespace std;\nusing i64 = long long;\nusing i128 = __int128;\nusing vint = vector&lt;i64&gt;;\nusing vvint = vector&lt;vint&gt;;\nusing vstr = vector&lt;string&gt;;\nusing pii = pair&lt;i64, i64&gt;;\nusing vpii = vector&lt;pii&gt;;\ntemplate &lt;typename T&gt;\nusing vec = vector&lt;T&gt;;\nconst constexpr i64 MOD = 998244353;\n \nvoid solve()\n{\n    i64 n;\n    cin &gt;&gt; n;\n    vint v(n);\n    map&lt;i64, i64&gt; freq;\n    for (i64 i = 0; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n        freq[v[i]]++;\n    }\n    vint diff(n + 2);\n    for (i64 i = 0; i &lt;= n; i++) {\n        diff[freq[i]]++;\n        diff[n - i + 1]--;\n        if (!freq[i]) break;\n    }\n    vint ans(n + 2, 0);\n    for (i64 i = 0; i &lt;= n; i++) {\n        ans[i] = diff[i];\n        if (i != 0) {\n            ans[i] += ans[i - 1];\n        }\n    }\n    for (i64 i = 0; i &lt;= n; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;\n    }\n \n    cout &lt;&lt; endl;\n}\n \nsigned main()\n{\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2);\n    int T = 1;\n    cin &gt;&gt; T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}"},"Linux/常见命令/chomd":{"slug":"Linux/常见命令/chomd","filePath":"Linux/常见命令/chomd.md","title":"chomd","links":["Linux/常见命令/ls"],"tags":[],"content":"基本作用\nchomd主要作用是修改文件权限或者目录权限\n权限详解\n在Linux中，权限被分为三组，每组包含三种权限:\n\n所有者 (Owner / User - u): 文件的创建者或被指定为所有者的用户。\n组 (Group - g): 与文件关联的用户组中的所有用户。\n其他用户 (Others / World - o): 除了所有者和组成员之外的所有其他用户。\r\n每组权限组都包含以下三种基本权限：\n\n\n读取 (Read - r):\n\n对于文件: 允许查看文件内容。\n对于目录: 允许列出目录中的文件（但必须同时有执行权限才能进入目录）。\n\n\n写入 (Write - w):\n\n对于文件: 允许修改、保存或删除文件。\n对于目录: 允许在目录中创建、删除或重命名文件（但必须同时有执行权限才能进入目录）。\n\n\n执行 (Execute - x):\n\n对于文件: 允许将文件作为程序或脚本运行。\n对于目录: 允许进入（cd）目录并访问其内容。\r\n我们可以使用ls -l来查看文件权限\n\n\n\n\n两种用法\n1.符号模式\n符号模式可以使用字符来增量的修改权限\r\n语法：\nchmod [who][operator][permissions] file/directory\n\nwho (作用对象)：\n\nu (user): 所有者\ng (group): 组\no (others): 其他用户\na (all): 所有用户 (u, g, o 的总和)\n如果省略 who，则默认作用于 a (all)，但受 umask 影响。\n\n\noperator (操作符)：\n\n+: 添加指定的权限。\n-: 移除指定的权限。\n=: 设置指定的权限，并移除未指定的其他权限。\n\n\npermissions (权限)：\n\nr: 读取 (Read)\nw: 写入 (Write)\nx: 执行 (Execute)\r\n例子：\n\n\n\nchmod u+x script.sh \n#为文件所有者增加执行权限\nchmod a=rwx script2.sh \n#为所以用户添加读写执行的权限\nchmod u+w directory/\n#为目录所有者添加写权限\n\n数字模式\n数字模式使用八进制数字表示每组权限\r\n每个权限都有自己的对应值\n\nr(读) = 4\nw(写) = 2\nx(执行) = 1\n-(无权限) = 0\r\n通过将每组权限的数字值相加，可以得到一个三位八进制数字。这三位数字分别代表所有者、组和其他用户的权限。\n\n权限组合的数字值：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n权限组合数字值---0--x1-w-2-wx3r--4r-x5rw-6rwx7\n语法：\nchmod [xxx] file/director\n其中xxx是一个三位8进制数字\n\n第一位数字：所有者的权限 (Owner)\n第二位数字：组的权限 (Group)\n第三位数字：其他用户的权限 (Others)\r\n例：\n\nchmod 644 file\n\n6 (rw-) 给所有者：读、写\n4 (r—) 给组：读\n4 (r—) 给其他用户：读\n这是普通文件常见的权限设置，所有者可读写，其他人只读。\n\n"},"Linux/常见命令/find":{"slug":"Linux/常见命令/find","filePath":"Linux/常见命令/find.md","title":"find","links":[],"tags":[],"content":"Find命令在linux里用于在指定的目录下搜索文件和目录,可以根据各种条件来查找\n\n基本用法\n以下是一些基本的用法\nfind [路径] [表达式]\n\n[路径]:开始搜索的目录,如果不指定则默认为当前目录\n[表达式]: 告诉find你需要查找什么文件(文件名,类型,大小写) 以及找到之后要执行什么操作\n\n\n常用搜索条件\n按名称搜索\n参数 -name\n用于根据文件名称搜索,支持 shell 通配符\n\n搜索名为 test.txt 的文件:\n\nfind . -name &quot;test.txt&quot;\n\n在当前目录与子目录查找 test.txt\n\n\n搜索所有 .log 结尾的文件\n\nfind /var/log -name &quot;*.log&quot;\n\n在 /var/log 目录下查找所有 .log 文件\n\n\n忽略大小写搜索\n\nfind . -iname &quot;report.pdf&quot;\n\n会匹配 Report.pdf REPORT.pdf …\n\n\n按类型搜索\n参数 -type\n用来指定要搜索的是文件、目录、符号链接等。\n\nf：普通文件\nd：目录\nl：符号链接 (symbolic link)\n搜索名字为 imicola 的目录\n\nfind . -type d -name imicola\n\n按大小搜索\n参数 -size\n可以根据文件大小搜索文件\n单位:\n\nc 字节bytes\nk 千字节 即KB\nM 即MB\nG 即GB\n\n\n找到文件后执行操作 (-exec)\n语法规则 : ... -exec [cmd] {} \\;\n\n[cmd] 是执行的命令\n{} 是占位符,会将find找到的每一个文件路径替换\n\\; 是 -exec 命令的结束符,必须存在\n\nfind /tmp -name &quot;*.tmp&quot; -exec rm {} \\;\n\n找到所有 .tmp后缀文件并删除\n\n"},"Linux/常见命令/grep":{"slug":"Linux/常见命令/grep","filePath":"Linux/常见命令/grep.md","title":"grep","links":[],"tags":[],"content":""},"Linux/常见命令/kill":{"slug":"Linux/常见命令/kill","filePath":"Linux/常见命令/kill.md","title":"kill","links":[],"tags":[],"content":"Linux的 kill 命令用于向进程发送指定信号以终止或控制进程。\n默认情况下，它发送SIGTERM通知进程优雅退出，允许程序执行清理操作。\n若进程无响应，可使用-9参数发送SIGKILL强制终止（如kill -9 PID）。\n需通过ps、pgrep等命令获取目标进程的PID（进程ID）。常用参数包括：-l列出所有信号，-p指定进程组等。\n\n注意：强制终止可能导致数据丢失，操作前需谨慎确认PID；部分情况需管理员权限（如终止系统进程）。例如：killall nginx可终止所有nginx进程。\n"},"Linux/常见命令/less":{"slug":"Linux/常见命令/less","filePath":"Linux/常见命令/less.md","title":"less","links":["基础入门/MIT-Missing-Semester/编辑器(vim)"],"tags":[],"content":"less 命令是一个非常强大的 Linux 工具，用于在终端中查看文件内容或输入内容。\n它比 cat 命令更适合查看大文件，因为它不会一次性将整个文件加载到内存中，而是允许你逐页或逐行浏览。\n基本用法\n基本语法是:\nless [文件名称]\n如我们要查看 file.txt 的内容可以输入\nless file.txt\n\nless界面操作\n与vim类似的是,less界面使用 j k 空格 b 来进行基本的导航\n\nj k 向 下/上 滚动一行\n空格 b 向 下/上 滚动一页\ng G 跳转到文件 头/尾\n{数字} + g/G 跳转到指定行\nd u 向 前/后 滚动半屏\n\n搜索\n\n/ 向下搜索,使用 n/N 导航\n? 向上搜索,使用 n/N 导航\n\n其他操作\n\nq 退出\nh 显示帮助信息\n= 显示当前文件状态\n-S 禁用行折叠\n&amp; 过滤显示行\n"},"Linux/常见命令/ls":{"slug":"Linux/常见命令/ls","filePath":"Linux/常见命令/ls.md","title":"ls","links":[],"tags":[],"content":"基本作用\nls命令的作用是列出指定目录包含的文件，如果用户没有指定，则列出当前工作目录下的文件\n-a\n一般情况下，ls不会输出以.开头的文件，如果想要知道这些文件，可以使用 ls -a,会显示所有文件，也可以使用ls -A,这样会在ls -a的基础上不显示.he\n-l\n对输出\ndrwxr-xr-x 2 imicola users 4096 Mar 22 20:16 astrbot\n1. 文件类型和权限 (drwxr-xr-x)\n这是最左边的10个字符，它们描述了文件类型以及用户、组和其他用户的访问权限。\n\n第一个字符 (d): 表示文件类型。\n\nd: 目录 (directory)\n-: 普通文件 (regular file)\nl: 符号链接 (symbolic link)\nb: 块设备文件 (block device file) (例如硬盘)\nc: 字符设备文件 (character device file) (例如终端或串行端口)\np: 命名管道 (named pipe)\ns: 套接字 (socket)\n\n\n接下来的九个字符 (rwxr-xr-x): 这九个字符分为三组，每组三个字符，分别代表 所有者、所属组 和 其他用户 的权限。每个三字符组的顺序都是 读 (r)、写 (w) 和 执行 (x)。如果某个权限没有被授予，对应的位置会显示为连字符 (-)。\n\n第一组 (rwx): 所有者 (owner) 的权限。\n\nr: 读 (read) 权限\nw: 写 (write) 权限\nx: 执行 (execute) 权限\n\n\n第二组 (r-x): 所属组 (group) 的权限。\n第三组 (r-x): 其他用户 (others) 的权限。\n\n\n以 drwxr-xr-x 为例：\n\nd: 这是一个目录。\nrwx: 文件所有者拥有读、写和执行权限。\nr-x: 所属组的成员拥有读和执行权限，但没有写权限。\nr-x: 其他用户拥有读和执行权限，但没有写权限。\n\n\n\n2. 硬链接数 (2)\n这列显示了指向文件或目录的 硬链接数量。\n\n对于文件，它表示有多少个文件名指向同一个物理文件。\n对于目录，它表示该目录本身以及其直接包含的子目录数量（每个子目录都有一个 . 和 .. 链接，加上其本身的名称）。\n\n3. 文件所有者 (imicola)\n这表示文件的 所有者用户名。该用户对文件拥有第一组权限 (例如 rwx)。\n4. 所属组 (users)\n这表示文件所属的 组名。属于该组的用户对文件拥有第二组权限 (例如 r-x)。\n5. 文件大小 (4096)\n这表示文件或目录的 大小，通常以字节为单位。对于目录，这个大小通常不是其内部所有文件大小的总和，而是目录本身存储其内容（如文件名和子目录信息）的大小。\n6. 最后修改时间 (Mar 22 20:16)\n这表示文件或目录的 最后修改时间。它包括月份、日期和时间。\n7. 文件名或目录名 (astrbot)\n这表示文件或目录的 名称。"},"Linux/常见命令/sed":{"slug":"Linux/常见命令/sed","filePath":"Linux/常见命令/sed.md","title":"sed","links":[],"tags":[],"content":"sed(stream editor) 是非交互式文本流编辑器，它逐行处理文本，依据输入的指令对文本进行转换\n\n基本用法\nsed [选项] &#039;脚本&#039; 文件名\n# 或者\n命令 | sed [选项] &#039;脚本&#039;\n\n\n                  \n                  Tip\n                  \n                \n\n\nsed 命令的构造是抽象的，这里我们只举一些常用例子\n\n\n\n替换\n语法 ： s/正则表达式/替换内容/标注\n\n标注: 可选参数\n\ng 替换所有匹配项目(默认只会替换每行第一个)\ni 忽略大小写\np 打印发生替换的行 (需要与-n选项一起使用)\nw 将更改写入文件\n\n\n\n例如：将系统日志中所有”Error”(忽略大小写)变成”ERROR!!” 并且打印\njournalctl | sed -n &#039;s/error/ERROR!!/gip&#039;\n删除\n使用d命令删除行命令有\n\n删除具体行 sed &#039;5d&#039;(删除第5行) &amp; sed &#039;2,4d&#039;(删除2-4行)\n删除包含正则表达式的行 /正则表达式/d\n\n打印\n\n默认情况下 sed 是打印所有行，你需要使用参数 -n 静默输出让他只打印命令的行\n\n使用p命令删除行命令有\n\n打印具体行 sed &#039;5d&#039;(打印第5行) &amp; sed &#039;2,4d&#039;(打印2-4行)\n打印包含正则表达式的行 /正则表达式/d\n\n插入/追加/修改\n\n插入i ，追加a, 修改c ： [行数](操作符)\\新文本 or /正则表达式/(操作符)\\新文本\n插入是在匹配行前一行插入\n追加是在匹配行后一行插入\n替换是将匹配行替换成新内容\n\n\n多命令\n我们可以使用 ; 或 -e 分隔多命令，其中 ; 需要在单引号里使用 -e 需要在单引号外面使用\n删除空行并且用”bar” 替换 “foo”\nsed &#039;/^$/d; s/foo/bar/g&#039; filename.txt\n# 或者\nsed &#039;/^$/d&#039; -e &#039;s/foo/bar/h&#039; filename.txt"},"Linux/常见命令/sort":{"slug":"Linux/常见命令/sort","filePath":"Linux/常见命令/sort.md","title":"sort","links":[],"tags":[],"content":"sort 命令简介\nsort 命令是 Linux/Unix 系统中一个非常实用的工具，主要用于对文本文件的行进行排序。它可以根据不同的规则对文本内容进行升序或降序排列。\n基本用法\n最简单的用法是直接对文件进行排序并输出到标准输出：\nsort filename\n这会按字母顺序（默认升序）排列 filename 中的每一行。\n常用选项\n\n-r (或 --reverse):反向排序（降序）。\n\nsort -r filename\n\n-n (或 --numeric-sort): 按数值排序。当行中包含数字时，这个选项会按照数字的大小而不是字母顺序来排序。\n\nsort -n filename\n\n-k (或 --key): 指定排序的键（列）。你可以指定从哪一列开始排序，以及到哪一列结束。\n\nsort -k 2 filename # 按第二列排序\n你也可以指定列的范围，例如 -k 2,3 表示从第二列到第三列进行排序。\n\n-u (或 --unique): 去重。只保留唯一的行，重复的行只显示一次。\n\nsort -u filename\n\n-o (或 --output): 将排序结果输出到文件。\n\nsort filename -o sorted_filename\n这会将排序后的内容保存到 sorted_filename 中，而不会直接输出到屏幕。\n\n-t (或 --field-separator): 指定字段分隔符。当你的数据不是以空格分隔时，可以使用此选项。\n\nsort -t &#039;,&#039; -k 2 filename # 以逗号为分隔符，按第二列排序\n简单示例\n假设你有一个名为 data.txt 的文件，内容如下：\napple 10\nbanana 5\ncherry 20\ndate 15\n\n\n按字母顺序排序：\n\nsort data.txt\n# 输出：\n# apple 10\n# banana 5\n# cherry 20\n# date 15\n\n按数字大小（第二列）排序：\n\nsort -n -k 2 data.txt\n# 输出：\n# banana 5\n# apple 10\n# date 15\n# cherry 20\nsort 命令是处理文本数据的强大工具，熟练掌握它的常用选项能大大提高你的命令行操作效率。"},"Linux/折腾/neovim":{"slug":"Linux/折腾/neovim","filePath":"Linux/折腾/neovim.md","title":"neovim","links":[],"tags":[],"content":"\nvim是一个传统命令行文字编辑器\nneovim是vim的改进，在vim的核心逻辑上有着更强的社区扩展与插件扩展性的终端IDE\n\n"},"Linux/折腾/从零开始安装linux":{"slug":"Linux/折腾/从零开始安装linux","filePath":"Linux/折腾/从零开始安装linux.md","title":"从零开始安装linux","links":[],"tags":[],"content":"\nlinux是一种独立于win,macOS的操作系统，对嵌入式，代码工作，开发实验有强大的支撑作用\n在开始安装之前可以先选择你的需求：主要分为虚拟机安装与双系统共存\n\n虚拟机安装优点\n\n简单易上手，在windows下就能实现大部分linux的功能\n具有强大的可修改性，遇到不喜欢的删掉重新安装即可\n存在及其强大的回滚与测试环境(毕竟没人会在实体机上 rm -rf / )\n可以更灵活的分配虚拟机资源\n\n缺点\n\n对系统占用大，没办法完全发挥linux体量小，占用小的优点\n虚拟机中的图形性能可能不如直接在物理硬件上运行，特别是对于需要高性能图形处理的应用\n虚拟机可能无法提供与物理机相同的实时响应能力，尤其是在高负载情况下\n虚拟机可能不能为你提供完全兼容的硬件配置\n\n实体机(双系统)安装的优点\n\n完全发挥linux的轻量级，省资源的优点\n对硬件几乎完全适配\n安装双系统对windows启动和linux启动能提供更深刻的认识\n双系统将win和linux从硬件层面隔离\n\n缺点\n\n麻烦\n如果选用Arch系的linux发行版有可能会一次更新直接崩溃\n系统回滚麻烦\n需要你有一个U盘\n\n1.0 选择你的linux版本\n\n\n两大选择：Ubuntu 或 Arch系\n\n\narch系的有\n\n原生arch linux\n基于arch linux 的发行版 manjaro [笔者装的就是这个]\n\n\n\n国产新秀deepin\n\n\n\n\n                  \n                  TIP\n                  \n                \n\n\n新手建议装Ubuntu或deepin,特别是deepin(有开箱即用的优点，甚至原生支持中文输入法[笔者觉得manjaro的中文输入法是真的难用])\nUbuntu和arch系的区别就是软件/系统更新的区别\n\nUbuntu每两年发布一个LTS（长期支持）版本，提供长达5年的安全更新和维护\nArch采用滚动发布模型，意味着用户总是能够使用最新的软件和内核\n\\to [虽然滚动更新模式可以让用户始终保持最新，但有时候更新可能会破坏系统的稳定性]\nUbuntu提供了一个直观的图形用户界面，使得新用户可以轻松上手\nArch Linux允许用户从安装开始就自定义他们的系统，提供了极大的灵活性\n!!!在安装难度上 Ubuntu &lt; arch发行版manjaro &lt;&lt;&lt;&lt; 原生arch linux\n据说arch linux 的网络配置都要手搓命令行和网关配置\n\n\n\n\n2.0 虚拟机安装\n由于笔者没在虚拟机上装过，所以可能有不准确的信息，欢迎和笔者报错\n2.1 下载VMware\n\n\nVMware Workstation Pro\n\n\n\n注意：在这里不要选择安装带有 linux 字样的软件，这里的linux表示在linux上运行的软件，因为我们是在windows上运行的，所以我们要安装 Windows版本的\n\n\n\n安装时可能出现要求许可证的情况，可以选择购买或下载个人版\n\n\n\n以下内容出现在本文纯属计算机二进制的意外组合造成的结果\n\n4A4RR-813DK-M81A9-4U35H-06KND\nNZ4RR-FTK5H-H81C1-Q30QH-1V2LA\nJU090-6039P-08409-8J0QH-2YR7F\n4Y09U-AJK97-089Z0-A3054-83KLA\n4C21U-2KK9Q-M8130-4V2QH-CF810\nMC60H-DWHD5-H80U9-6V85M-8280D\nZA30U-DXF84-4850Q-UMMXZ-W6K8F\nAC590-2XW97-48EFZ-TZPQE-MYHEA\nYF39K-DLFE5-H856Z-6NWZE-XQ2XD\nAC15R-FNZ16-H8DWQ-WFPNV-M28E2\nCZ1J8-A0D82-489LZ-ZMZQT-P3KX6\nYA11K-6YE8H-H89ZZ-EXM59-Y6AR0\n\n\n\n\n2.2 下载Linux系统iso(系统映像文件)\n\n\nUbuntu\n\n\nArch linux[^1 ]\n\n\nmanjaro\n\n\n\n建议选择KDE Plasma或GNOME\njust 桌面配置，后续可以改\n\n\n\ndeepin\n\n\n2.3 配置虚拟机\n\n\n打开VMware\n\n\n创建新的虚拟机[选择(自定义)]\n\n\n\n选择“安装程序光盘映像文件”，点击输入框旁边的“浏览”按钮\n\n\n\n\n\n根据下载路径,找到下载好的镜像安装包,双击选择\n\n\n注意安装位置！！！不许安装在C盘！！！\n\n\n每个处理器的内核数量修改成 2，单击“下一步”\n\n\n内存选择建议 4 GB，单击“下一步”\n\n\n网络类型选择桥接1\n\n\n默认两步\n\n\n硬盘容量默认是 20 GB，按自己需求选择，不建议太小\n\n\n接着默认下去\n\n\n2.3 以Ubuntu系统为例 安装过程的配置\n\n\n打开虚拟机\n\n\n稍等片刻后，进入如下图的界面\n\n\n\n\n改中文\n默认安装\n\n\n\n\n下图所示的界面检测到本台电脑（虚拟机）没有操作系统，询问是否要安装操作系统，默认选项“格式化磁盘然后安装Ubuntu”就是安装操作系统的选项，只是会清空虚拟机所有的磁盘*（是本台虚拟机的磁盘，不是宿主机的磁盘，所以不要大惊小怪）*，直接点“Install Now”即可\n\n\n时区选上海\n\n\n然后输入姓名、电脑名、账户和密码 一定要记得你的密码，很多终端操作都会用到这个密码\n\n\n漫长安装\n\n\n安装完成后会提示你重启，重启即可\n\n\n有可能会遇到升级成 Ubuntu Pro， Ubuntu 系统的改善建议之类的提升，跳过即可\n\n\n3.0 双系统安装\n\n\n                  \n                  Important\n                  \n                \n\n\n双系统的安装复杂程度比虚拟机难出一个量级，且有潜在的对系统危险性的操作，错误地执行这些操作可能会给你的电脑带来无法进入系统之类的结果\n在尝试安装双系统之前，请警惕这一过程可能带来的风险：操作失误可能导致数据丢失或系统无法启动。确保在开始之前备份所有重要数据，并且完全理解每一步操作的含义。如果你不熟悉分区、格式化或BIOS/UEFI设置，请先在虚拟机上练习或寻求专业人士的帮助。此外，安装过程中可能会覆盖启动项，确保你了解如何修复或恢复启动问题。\n\n\n\n3.1操作之前\n\n下载软件\n\n傲梅分区助手[用于为磁盘分区，创建系统所需要的磁盘空间，修改为GPT引导]\nRufus[用于将iso写入u盘 建议下载老版本3.15]\ndiskgenius[用于删除旧的EFI分区]\n\n\n\n3.1.1检查自己即将装系统的磁盘，确保其是GPT引导\n\n\n如何操作？\n\n右键win标识弹出这个窗口，选择磁盘管理\n\n\n\n\n选择将要装系统的磁盘，右键选择属性，选择“卷”\n\n\n\n在卷里查看自己的引导方式\n\n\n\n如果是GPT，很好，你过关!\n\n\n如果不是，执行下面操作\n1. 打开傲梅分区助手\n2. 右键选中磁盘\n3. 选择转化为GPT硬盘 你是MBR就会有转化为GPT硬盘，这里笔者的已经是GPT硬盘了\n\n\n\n\n等待转化完成\n\n3.1.2关闭windows快速启动\n\n\n\n\n\nwin + X打开终端管理员\n\n\n输入powercfg -h on确保休眠模式打开\n\n\n关闭终端\n\n\n打开控制面板\n\n\n\n\n选择硬件和声音\n选择电源设置\n\n\n\n选择更改当前不可用的设置\n\n\n\n关闭快速启动\n打开终端管理员\n输入 powercfg /a检查\n重启\n\n\n\n\n3.1.3进入Bios/UEFI [!操作失误有风险]\n\n\n上网寻找如何进入自己电脑品牌的Bios\n进入bios\nSecureBoot 改成 Disabled，禁用安全启动(部分机型需设置 BIOS 密码才可以修改 Secure Boot，找到Set Supervisor Password 设置密码)\n退出biso\n重启进入windows\n\n\n3.1.4EFI扩容\n\n\n                  \n                  Important\n                  \n                \n\n\nEFI区含有windows启动的引导文件，我们扩容的EFI实际上是删去原来的EFI分区建立一个新的Fat32分区并建立引导文件，操作不当可能会导致无法进入Windows系统内\n\n\n\n\n参考了b站BV1CT411c7n4的方法\n\n\n\n\n从C盘划分区域用于扩大EFI分区\n\n\n\n打开磁盘管理\n\n\n\n压缩一个卷[大小一定要超过320M][建议1G]\n\n\n\n搜索cmd\n选择以管理员身份运行\n\n按照下面输入\ndiskpart\nlist disk\nselsct disk 0\nlist partition\ncreate partition efi\nformat quick fs = fat32\nassign letter = P [输入这个时请确保P盘符没有被占用，如果被占用，则修改]\nlist volume\nlist partition [检查新建的分区是否存在,一般没问题]\nexit\nbcdboot C:\\windows /s P: /f UEFI [注意这里的P一定要与上文建立的新盘符相同]\nexit\n\n\n\n现在新的UEFI/boots启动已经完成\n重启\n删去原来的EFI分区\n启动diskgenius\n选择大小为260/100M的带有fat32标识的磁盘分区\n选择删除分区[请确保新的EFI分区已经建立]\n\n重启\n如果正常进入系统说明扩容成功\n\n\n\n现在隐藏盘符P\n打开傲梅分区助手\n\n\n执行操作并退出\n\n\n\n3.2 开始操作\n3.2.1 安装前操作\n3.2.1.1 制作启动盘\n\n下载你需要的linux版本的iso文件,[linux下载](###2.2 下载Linux系统iso(系统映像文件))\n插入U盘\n用Rufus制作启动盘\n\n\n\n修改引导类型选项，选择非可引导，修改分区类型，选择GPT\n\n点击“选择”，选择你下载的iso文件\n等待\n点击开始\n等待结束\n结束后退出\n\n\n\n\n3.2.1.2 为linux划分磁盘\n\n\n打开 磁盘管理\n\n\n从你要安装盘中选择一个空间大的盘选择压缩盘[不能是C盘!!!]\n\n\n压缩大小看个人实际需求，建议大于45G,笔者划分了128G[把博德之门删掉正好]\n\n\n压缩完成后无需格外操作，退出\n\n\n3.3 关机进入U盘启动安装linux\n\n\n                  \n                  Tip\n                  \n                \n\n\n这里以安装manjaro为例子\n\n\n\n\n首先高级重启电脑\n路径：Windows设置--更新和安全--高级选项--恢复--高级启动--立即重新启动\n\n3.4进入U盘启动界面开始安装\n成功从U盘启动后，首先会进入配置界面，唯一需要注意的是driver的选择\ndriver选择free还是nofree因电脑配置而异，以下仅供参考：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCPU显卡选择Intel无独显freeAMD无独显freeAMDNVIDIAno freeIntelAMDfreeIntelNVIDIAno free\n设置完毕后，enterBoot进入桌面\n\n\n然后会让你选择开始安装，建议先调整为中文，联网[在桌面右下角]\n\n\n\n\n\n时区选上海，键盘样式默认即可\n\n\n\n\n\n                  \n                  Important\n                  \n                \n\n分区\n\n选择手动分区\n\n找到你划分空间的那个盘\n\n选择你划分出来的磁盘空间[一般叫做未分配区域]\n选择创建:\n创建如下四个区域\n\n\nswap区域，一般8G,文件系统选择linuxswap\n\n\n\nboot区域，一般500M~1G,文件ext4，挂载点/boot\n\n创建root根目录，大小在20G~40G，建议大一点\n\n建立/home挂载点\n\nimportant\n建立挂载点\n返回C盘所在的硬盘空间\n找到带有FAT32的大小为1G的分区\n点击编辑\n\n全部完成后检查一遍，点击下一步\n输入用户名，密码，选择“为管理员账户使用相同的密码”记住密码！！！\noffice建议不装\n所有完成后点击安装\n\n\n3.3 安装完成后的操作\n\n安装完成后可以重新启动，然后就会看到UEFI引导，选择系统进入\n可以看这个完成安装后的初始化\n\n\nby imicola\n参考文献：\n\n【Liunx】manjaro双系统安装（折腾）教程\n教你从零开始搭建双系统——Linux(Manjaro)和Win双系统\nManjaro安装、配置、调试超详细攻略\n基于VMware虚拟机的Ubuntu22.04系统安装和配置（新手保姆级教程）\n对EFI系统分区扩容\n[201020] Manjaro（KDE桌面环境）小白向完全安装教程（附Linux简要介绍） \nWin10和Manjaro双系统安装、双系统gubr正确引导进入任意一个\n\n\n注释\n\n关于arch linux的安装，这篇博客可以提供一些指引作用\n\nFootnotes\n\n\n校园网可能无法使用桥接功能，可以买个路由器来解决，原理就是用路由器的 DHCP 功能，来管理分配 IP 地址，这样就可以使用桥接网络了，嫌麻烦也可以选择使用主机网络 ↩\n\n\n"},"Linux/折腾/最好的linux发行版——WSL2的使用":{"slug":"Linux/折腾/最好的linux发行版——WSL2的使用","filePath":"Linux/折腾/最好的linux发行版——WSL2的使用.md","title":"最好的linux发行版——WSL2的使用","links":[],"tags":[],"content":"在微软开源WSL2之前我就已经对WSL2产生了十足的好感，没想到微软直接开源了WSL2,现在WSL2社区也是好起来了，只看 wsl --list online 上的发行版就达到了20种\n正话：什么是WSL?\nwsl全称是 Windows Subsystem for Linux,即适用于 Linux 的 Windows 子系统，可以让你在 Windows 上近乎无损的使用 Linux 命令行\n下面我提供一种配置方式，采用发行版是 manjaro for wsl2\n配置\n先看效果：\r\n\n第一步，你需要先去 github 下载 manjaro for wsl2的发行版 release\n下载后解压文件并双击 manjaro.exe 会在目录下建立虚拟硬盘，你的wsl文件都存在这个虚拟硬盘中\n然后会开始创建wsl系统，接着根据提示输入用户名，root密码\n设置完成后开始配置linux与wsl使其利于工作流\n配置wslconf\n在 Windows 目录 C:\\Users\\[用户名] 下创建名为 .wslconfig文件，将下述内容写入文件\n[wsl2]\n \nnetworkingMode=mirrored\n \nfirewall=true                     # 开启 Windows 防火墙\n \nkernelCommandLine=cgroup_no_v2=all\n \n[experimental]\n \nhostAddressLoopback=true\n \nautoMemoryReclaim=gradual         # 开启自动回收内存，可在 gradual, dropcache, disabled 之间选择\n \ndnsTunneling=true                 # 开启 DNS Tunneling\n \nsparseVhd=true                    # 开启自动释放 WSL2 虚拟硬盘空间\n打开 PowerShell 输入 wsl --shutdown 让wsl关机使配置生效\n配置pacman镜像源\nsudo pacman-mirrors --country China # 由于网络因素可能部分镜像网站显示 error, 但运行结束后会自动更新可用的镜像列表\nsudo pacman -Syu # 选择2 dbus-daemon-units\nsudo pacman -S yay # 安装 AUR Helper, 它可以执行pacman的几乎所有操作，并在此基础上添加了很多额外用法。\n配置终端\nsudo pacman -S zsh\n安装zsh\n下载 oh-my-zsh 框架\nsh -c &quot;$(wget -O- raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;\n配置插件环境\ngit clone github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n \ngit clone github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n \ngit clone gitee.com/lxgyChen/autojump\n \n#安装主题\ngit clone github.com/spaceship-prompt/spaceship-prompt.git &quot;$ZSH_CUSTOM/themes/spaceship-prompt&quot; --depth=1 \nln -s &quot;$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme&quot; &quot;$ZSH_CUSTOM/themes/spaceship.zsh-theme&quot;\n安装 auto jump\ncd autojump\n./install.py\n# 如果遇到权限问题输入 sudo chomd +x ./install.py\n安装fzf\nsudo pacman -S fzf\n更新 ~/.zshrc\nplugins=(\n    git\n    sudo\n    copypath\n    copyfile\n    autojump\n    zsh-syntax-highlighting\n    zsh-autosuggestions\n)\n \n# 确保 Oh My Zsh 在设置了 plugins 变量之后加载\nsource $ZSH/oh-my-zsh.sh\n \n# 修正 autojump 路径\n[[ -s $HOME/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source $HOME/.autojump/etc/profile.d/autojump.sh\nautoload -U compinit &amp;&amp; compinit -u\n \nSPACESHIP_TIME_SHOW=&quot;true&quot;\nSPACESHIP_USER_SHOW=&quot;always&quot;\nSPACESHIP_USER_COLOR=&quot;212&quot; #粉色\nSPACESHIP_RUST_VERBOSE_VERSION=true\n \nalias cls=&quot;clear&quot;\nalias vi=&quot;nvim&quot;\nalias vim=&quot;nvim&quot;\n \nsource &lt;(fzf --zsh)"},"SRE入门/Go语言/0.为什么要学习golang":{"slug":"SRE入门/Go语言/0.为什么要学习golang","filePath":"SRE入门/Go语言/0.为什么要学习golang.md","title":"0.为什么要学习golang","links":[],"tags":[],"content":"这就和问我为什么要演奏春日影一样\n很多容器都是用go语言写的，学习go语言还是有必要的"},"SRE入门/Go语言/1.Go语言语法":{"slug":"SRE入门/Go语言/1.Go语言语法","filePath":"SRE入门/Go语言/1.Go语言语法.md","title":"1.Go语言语法","links":[],"tags":[],"content":"语言特性\nless can be more\n这是go语言的核心思想\n在go语言中，没有继承，多态，甚至是类\n在go的文档中说Go语言几乎和C/C++一样快实则不然\n语法\n变量定义\n在go语言中，主要采用类型后置的命名方式：\nvar age int = 25 \\\\ 经典定义方式\nvar age = 25 \\\\ 自动推断，类似C++中 auto\nage := 25 \\\\ 简短定义，等效上一条\n在Golang中支持批量的定义\nvar(\n\ta string\n\tb int\n\tc bool\n\td float32\n)\n\n我们需要注意Golang的命名规则，即首字母大写的命名在包外是可以访问的\n\n输入输出流(CLI下)\n在go语言中，我们有两种对输入输出流进行控制的语法，分别是 fmt 包和 bufio 包\n\n\n                  \n                  Tip\n                  \n                \n\n\n这两个包没有绝对的谁好谁坏的区别，对于fmt包而言，其适合格式化,对于 bufio 来说则更加侧重于性能\n\n\n\nfmt包的标准输入输出：\nimport (\n\t&quot;fmt&quot;\n)\n \nfunc main() {\n\ta := 114\n\t// 标准输出\n\tfmt.Print(&quot;hello go&quot;)       // 普通的打印\n\tfmt.Println(&quot;hello Gooooo&quot;) // 等效于在Print中加\\n\n\tfmt.Printf(&quot;%d&quot;, a)         //  类似于C的printf\n\t// 标准输入\n\tfmt.Scan(&amp;a) // 从标准输入中读取，注意需要传入地址\n\tvar str string\n\tfmt.Scanln(&amp;str)\n\tfmt.Println(a)\n\tfmt.Println(str)\n}\nbufio的输入输出\nfunc f2() {\n\t// 标准读入\n\treader := bufio.NewReader(os.Stdin) // 创建一个输入流,类似于Java\n\tvar x int\n\tvar str string\n\tfmt.Fscan(reader, &amp;x) // 搭配Fscan进行读入\n\tfmt.Fscan(reader, &amp;str)\n\t// 标准输出\n\twriter := bufio.NewWriter(os.Stdout) // 创建一个输出流\n\tfmt.Fprintln(writer, x)\n\tfmt.Fprintln(writer, str)\n\twriter.Flush() // 必须要刷新缓冲区否则可能不会显示输出\n}\n基本数据类型\nGolang的语言更加明确的数字类型命名\n在go语言中，有以下几种基本的数据类型:\n\n整型\n浮点型\n复数\n布尔\n字符串\n\n整型\n在go语言中整型可以分为两大类,其后面的数字表示了其占用的二进制位\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无符号有符号uint8int8uint16int16uint32int32uint64int64\n浮点型\ngo语言支持两种浮点型，float32 和 float64，不存在double\n对于float32其范围大概为3.4 \\times 10^{38}，float64的范围大约为1.8 \\times 10^{308},两个浮点数都有常量Math.MaxFloat32 &amp;&amp; Math.MaxFloat64\n复数\ncomplex32 和 complex64\n其中后缀数字表示实部和虚部的位数\n布尔\n在go语言中我们用 bool 对布尔值进行声明\n在Go语言中，没有1/0对布尔值的隐式转换，在建立布尔值的时候只能使用true或者false\n布尔型无法参与数值运算，也无法与其他类型进行转换。\n字符串\n在go语言中，使用字符串和使用原生数据类型是一样的。在Golang的字符串内部使用的是UTF-8编码，所以我们可以直接使用非ASCII字符\ns1 := &quot;hello&quot;\ns2 := &quot;你好&quot;\n对于字符串而言有许多和其他语言一致的\\转译字符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n转义含义\\r回车符（返回行首）\\n换行符（直接跳到下一行的同列位置）\\t制表符’单引号”双引号|反斜杠\n在go语言中也内置了和python一样好用的多行字符串\n要实现一个多行字符串时，我们需要使用 反引号 字符 `\ns1 := `第一行\n第二行\n第三行\n`\n反引号中的换行被作为字符串中的换行，所有的转义符号均无效，文本会原样输出\n字符串常用操作\nGo语言的字符串是一个不可变字节序列，本身并不是一个类，但是Go提供了一些函数来处理字符串\n查找与包含类：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能方法说明是否包含strings.Contains(s, substr)返回 bool，判断 substr 是否在 s 中查找位置strings.Index(s, substr)返回子串第一次出现的索引，不存在返回 -1最后位置strings.LastIndex(s, substr)返回子串最后一次出现的索引前缀判断strings.HasPrefix(s, prefix)判断是否以某字符串开头后缀判断strings.HasSuffix(s, suffix)判断是否以某字符串结尾统计次数strings.Count(s, substr)计算子串在字符串中出现的次数\n分割与合并：\n在处理CSV或路径的时候会十分有用，主要有两个函数：\n\n分割 Split : 将字符串切分成片\n\ns := &quot;abc,edf,ghi&quot;\nitem := strings.Split(s, &quot;,&quot;)\nfmt.Println(item)\n//output: [abc edf ghi]\n\n合并: 将切片连接成字符串\n\nsil := []string{&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;}\ns2 := strings.Join(sil, &quot;-&quot;)\nfmt.Println(s2)\n//output: abc-def-ghi\n字符\n组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来\n在string中有两种字符类型：\n\nuint8类型，或者叫 byte 型，代表了ASCII码的一个字符。\nrune类型，代表一个 UTF-8字符。\n\n\n实际上，rune 是一个int32\n\n字符串的修改\n因为go的字符串是一个不可变字符组，所以当我们需要修改字符串的时候需要我们将字符串变为rune[]或者byte[]，然后在最后的时候转化回去\nfunc changeString() {\n\ts1 := &quot;hello&quot;\n\t// 强制类型转换\n\tbyteS1 := []byte(s1)\n\tbyteS1[0] = &#039;H&#039;\n\tfmt.Println(string(byteS1))\n \n\ts2 := &quot;你好世界&quot;\n\truneS2 := []rune(s2)\n\truneS2[0] = &#039;不&#039;\n\tfmt.Println(string(runeS2))\n}\n\n但需要注意的是，这种转化会带来内存上的分配和拷贝问题，会对性能有一些开销问题\n\n类型转换\n在Go语言中，只有强制类型转化，没有隐式类型转化，其语法为 T(表达式)，其中T表示要转化的类型\n流程语句\n在go语言中，流程语句的书写习惯会更加偏向Python，比如if语句无需括号扩起，for range语法等\nif语句\n在Go语言中if语句有这些特点:\n\n可省略条件表达式括号。\n持初始化语句，可定义代码块局部变量。\n代码块左括号必须在条件表达式尾部。\n\nfunc f7() {\n\ta := &quot;喵&quot;\n\tif  b := &quot;喵&quot;; a == b {\n\t\tfmt.Println(&quot;喵喵&quot;)\n\t}\n}\n循环\n在Go语言中只有for循环，对于for循环有几种变体：\nfunc f8() {\n\ts1 := []int{1, 2, 3, 4}\n\t// 传统意义下的循环\n\tfor i := 0; i &lt; 4; i++ {\n\t\tfmt.Print(s1[i])\n\t\tfmt.Print(&quot; &quot;)\n\t}\n\t// 代替while循环\n\tn := 4\n\tfor n &gt; 0 {\n\t\tn--\n\t\tfmt.Print(s1[n])\n\t\tfmt.Print(&quot; &quot;)\n\t}\n\t// range 循环\n\tfor idx, v := range s1 {\n\t\tfmt.Println(v)\n\t\t/*\n\t\t\trange会遍历指定的切片\n\t\t\t需要注意的是，这里的v是在循环第一步就被拷贝了的\n\t\t\t所以对这个v进行修改不会改变s1中的元素\n\t\t\t如果需要修改可以使用idx进行修改\n\t\t*/\n\t\tif idx == 2 {\n\t\t\ts1[idx] = 1\n\t\t}\n\t}\n\t// range 次数循环\n\tfor range 4 {\n\t\tfmt.Println(&quot;喵&quot;)\n\t}\n\tp := 5\n\tfor range p*2 - 1 {\n\t\tfmt.Println(&quot;喵&quot;)\n\t}\n\t// 死循环\n\tfor {\n\t\tfmt.Println(&quot;喵&quot;)\n\t}\n}\n数组与切片\n在Go中，数组类似和传统意义上的数组一致，是一种定死底层内存的数据结构，对于切片而言，其可以说是一种可扩展容量的数组\n数组\n数组是具有固定长度且编号连续的数据序列，具有以下特点\n\n固定长度:在声明的时候必须指定长度且不可更改\n值类型：在 Go 中，数组是值类型。如果你把一个数组赋值给另一个数组，它是完全拷贝一份数据。\n注意长度也是构成数组类型的一部分，[3]int 和 [4]int 是两种完全不同的类型\n\n切片\n在Go语言中，有一种和C++中vector类似的数据结构，切片\n切片是对一个连续片段的引用，其本身并不储存任何数据，本质是一个很小的结构体，包含三个字段:\n\n指针：指向底层数组中切片开始的位置\n长度：切片当前包含的元素的个数\n容量：从切片起始位置到底层数组末尾的元素个数\n\n注意切片是引用的，当我们将一个切片赋值给另外一个变量的时候我们实际上传入的是引用，所以当我们修改其中一个的时候，另外一个也会变\n切片的初始化\n原始的切片声明没办法实现复杂的初始化，我们可以用make语法对切片进行初始化\nfunc f5() {\n\tn := 3\n\ts1 := make([]int, n) \n\tfor idx := range s1 {\n\t\ts1[idx] = idx + 1\n\t}\n\tfmt.Println(s1)\n}\n我们利用make函数还可以进行类似C++中预先分配内存的操作\nfunc f6() {\n\tn := 3\n\ts1 := make([]int, 0, 2*n)\n\tidx := 1\n\tfor range n * 2 {\n\t\ts1 = append(s1, idx)\n\t\tidx++\n\t}\n\tfmt.Println(s1)\n}\n切片的复制\n正如我们前面所说，如果我们直接将一个切片传入另外一个切片的时候，直接赋值的引用，要实现切片的赋值可以参考下面的两个语法\nfunc f4() {\n\ts1 := []int{1, 2, 3}\n\t// 使用append在一个空的数组后直接追加之前的元素\n\ts2 := append([]int{}, s1...)\n\t// 使用copy函数\n\ts3 := make([]int, len(s1)) // 注意这里s3的长度需要大于等于s1\n\tcopy(s3, s1)\n\ts3[0] = 2\n\ts2[0] = 114\n\tfmt.Println(s1, s2, s3)\n}\nmap\nGo语言的map通过make语法声明：\nmp := make(map[int]string)\nmp[5] = &quot;喵&quot;\n我们需要注意的是map中的键并非有序的，这个map更类似C++中的unordered_map\n在go语言中，map的声明格式为 map[KeyType]ValType\n我们推荐使用make语法初始化\nm := make(map[string]int)\nm[&quot;age&quot;] = 25\nmap的comma ok\n在获取 map 的值时，如果键不存在，Go 会返回该类型的零值（如 int返回0）。为了区分“值为0”和“键不存在”，我们通常这样做：\nval, ok := m[&quot;key&quot;] \nif ok { \n\tfmt.Println(&quot;找到值:&quot;, val) \n} else { \n\tfmt.Println(&quot;键不存在&quot;) \n}\nmap的遍历\n我们可以使用for range对map进行遍历，但是我们需要注意的是，对map进行遍历的时候输出的顺序是随机的\nmap的删除\n我们可以用delete函数删除map的一个键值对,语法规则是delete(map,key)其中，map表示要删除键值对的map；key:表示要删除的键值对的键\n结构体\n和其他语言一样，在Go语言中，结构体是将多个不同的数据结构组合在一起的自定义类型\n因为在Go语言中不存在Class,所以OOP类型的语法都是通过结构体进行的\n声明\ntype User struct{\n\tID     int\n\tname   string\n\tEmail  string\n}\n对于结构体的实例化的方法有以下四种：\n// 实例化方法\n\t// 1.直接实例化\n\tvar u0 User\n\t// 2.结构化实例(推荐)\n\tu1 := User{id: 1, name: &quot;喵&quot;, Email: &quot;?&quot;}\n\t// 3.指针化实例\n\tu2 := &amp;User{} // 返回的是一个空结构体指针\n\t// 4. 使用new实例化\n\tu3 := new(User)\n\n在Go语言中，结构体在内存中是连续分布的，这使得结构体的访问速度非常快，对CPU缓存是友好的\n\n结构体标签\n在创建结构体元素的时候，我们可以为结构体打上标签\ntype User struct {\n\tid    int    `json:&quot;id&quot;`\n\tname  string `json:&quot;name&quot;`\n\tEmail string `json:&quot;Email&quot;`\n}\n这种标签可以通过标准库中的reflect在运行时被解析，用于序列化，数据库映射等\n方法\n与其他语言不同，Go语言中结构体的方法不能放在结构体内部，而是脱离于结构体之外的\n它的语法是在 func 关键字后加一个接收者(Receiver)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型语法能否修改结构体的值值接受者func (u User) f()否拷贝一份副本，适合只读操作指针接受者func (u *User) f()是推荐方式，效率高且能修改状态\nfunc (u *User) SetName(newName string) {\n    u.Name = newName\n}\n组合与嵌套（伪继承）\n在Go语言中不支持类的继承，而是提倡通过 匿名嵌套 来实现继承\ntype Animal struct {\n\tName string\n}\n \nfunc (a *Animal) Getname() {\n\tfmt.Println(a.Name)\n}\n \ntype Dog struct {\n\tAnimal  // 此时dog已经继承Animal的方法和成员\n}\n \nfunc main() {\n\td := Dog{}\n\td.Name = &quot;狗&quot;\n\td.Getname()\n}\n这种继承方式被成为组合，在一个结构体里不止能有一个父类，可以有很多父类\ntype C struct{\n\tA\n\tB\n}\n函数\nGo语言摒弃了常规函数的类继承负担，设计的非常纯粹\n函数声明和语法\nGo语言的函数定义使用 func 关键字，其特点是变量名在前，类型在后\nfunc add(a int,b int) int{\n\treturn a + b\n}\n \n// 如果有类型一致的可以简写\nfunc add(a,b int) int{\n\treturn a + b\n}\n多返回值\n不同于C++或Java只能返回一个类型，Go语言原生支持返回多个值\n\n常规返回:\n\nfunc divide(a,b float64) (float64,error){\n\tif b == 0{\n\t\treturn 0,errors.New(&quot;算术错误&quot;)\n\t}\n\treturn a / b,nil\n}\n\n命名返回：我们可以为返回值命名，这些初始的命名会被初始化为0值\n\nfunc getRectProps(width,height float64) (area, perimeter float64){\n\tarea = weight*height\n\tperimeter = (weight+height)*2\n\treturn     // 裸返回，自动返回开头写的两个变量\n}\n变长参数\n如果我们不确定会传入多少个参数，可以使用 ... 语法,在函数内部，这个参数会被当成切片处理\nfunc sum(nums ...int) int{\n\ttot := 0\n\tfor _, n := range nums{\n\t\ttot += n\n\t}\n\treturn tot\n}\n匿名函数和闭包\nGo语言中支持匿名函数且这些函数可以作为闭包存在，即可以捕获并且记住其定义时所在作用域的变量\nfunc f1() func() int {\n\ti := 0\n\tres := func() int {\n\t\ti++\n\t\treturn i\n\t}\n\treturn res\n}\n \nfunc main() {\n\tcounter := f1()        // 获取一个闭包\n\tfmt.Println(counter()) // 输出: 1\n\tfmt.Println(counter()) // 输出: 2\n\tfmt.Println(counter()) // 输出: 3\n}\n在上面的代码中你可能注意到了我们给res和counter都赋值了函数，这代表在Go语言中函数是可以被作为变量赋值，作为参数传递和作为返回值的\n异常处理\n在Go语言中，没有类似 try-catch 语句的异常捕获机制，其错误不是被抛出的，而是被当作普通的变量返回的\n在go中我们有两种放回错误的方式：\n\nerrors.New(&quot;message&quot;):最基础的方式,每次调用都会创建一个全新的地址，即便错误信息一模一样，它们也不相等\nfmt.Errorf(&quot;error is: %v&quot;, detail):用于格式化错误信息\n"},"SRE入门/Go语言/2.接口":{"slug":"SRE入门/Go语言/2.接口","filePath":"SRE入门/Go语言/2.接口.md","title":"2.接口","links":[],"tags":[],"content":"语法\n我们使用 type [接口名称] interface{} 来声明一个接口\ntype Sayer interface {\n\tSay(messge string) error\n}\n当我们需要实现一个接口的继承的时候，我们可以直接实现这个接口里的方法\ntype Dog struct {\n    name string\n}\n \nfunc (dog *Dog)Say(messge string) error{\n\tfmt.println(dog.name + &quot;说：&quot; + messge)\n\treturn nil\n}\n \n// 在实现的时候我们可以\nvar sa Sayer\nd := &amp;Dog{&quot;name&quot;}\nsa = d\nsa.Say()       //接口可以调用d的方法了，此时我们实现了接口\n工程约束\n\n命名约定：\n\n单一方法接口：以er结尾，例如Reader,Writer\n不要预先定义：接口应该由使用者定义，而不是生产者定义\n\n\n接口设计：越小越好\n\nGo语言鼓励组合小接口而不是去创建一个庞大的接口\n\n\n接受接口，返回结构体\n\n在设计一个函数的时候，应该尽量接受接口，以提高函数的通用性\n函数应该返回具体的结构体\n\n\n\n接口能干什么\n下面我们用一个简单的需求展现interface的功能\n需求描述：多渠道告警系统\n\n我们的任务是编写一个告警小程序。这个程序需要支持多种通知方式（如邮件、短信），并且要能够轻松扩展新的通知方式（比如以后要加一个“钉钉告警”），而不需要修改核心的业务逻辑代码。\n\n\n\n接口定义:\n定义一个名为 Notifier 的接口，它必须包含一个方法：Notify(message string) error\n\n\n具体实现\n实现两个结构体，并让它们都满足 Notifier 接口：\n\n\n\nEmailNotifier: 结构体里包含一个 Address 字段。调用 Notify 时，打印：“向邮件地址 [xxx] 发送了消息：[内容]”。\nSMSNotifier: 结构体里包含一个 PhoneNumber 字段。调用 Notify 时，打印：“向手机号 [xxx] 发送了短信：[内容]”。\n\n\n核心业务逻辑（关键点）\n编写一个函数 SendAlerts：\n\n参数：接受一个 Notifier 接口的切片（[]Notifier）和一条消息字符串。\n功能：循环遍历切片，调用每个元素的 Notify 方法。\n\n\n\n在 main 函数中：\n\n创建一个包含一个 EmailNotifier 和一个 SMSNotifier 的切片。\n调用 SendAlerts 函数，把这个切片传进去。\n进阶思考:\n\n\n如果你现在想增加一个 WeChatNotifier，你是否需要修改 SendAlerts 函数的代码？如果不需要，恭喜你，你已经理解了接口带来的“开闭原则”（对扩展开放，对修改关闭）。\n\n\n参考：\npackage main\n \nimport (\n\t&quot;fmt&quot;\n)\n \ntype Notifier interface {\n\tNotify(message string) error\n}\n \ntype EmailNotifier struct {\n\tAddress string\n}\n \ntype SMSNotifier struct {\n\tPhonenumber string\n}\n \nfunc (emi *EmailNotifier) Notify(message string) error {\n\tfmt.Println(&quot;向邮件地址&quot; + emi.Address + &quot;发送了信息:&quot; + message)\n\treturn nil\n}\n \nfunc (sms *SMSNotifier) Notify(message string) error {\n\tfmt.Println(&quot;向手机号&quot; + sms.Phonenumber + &quot;发送了信息&quot; + message)\n\treturn nil\n}\n \nfunc SendAlerts(notify []Notifier) error {\n\tfor _, n := range notify {\n\t\tn.Notify(&quot;Testmessage&quot;)\n\t}\n\treturn nil\n}\n \n// 新增WeChatNotifier\ntype WeChatNotifier struct {\n\tWechatID string\n}\n \nfunc (wec *WeChatNotifier) Notify(message string) error {\n\tfmt.Println(&quot;向微信号:&quot; + wec.WechatID + &quot;推送：&quot; + message)\n\treturn nil\n}\n \nfunc main() {\n\tnois := []Notifier{&amp;EmailNotifier{&quot;test1&quot;}, &amp;SMSNotifier{&quot;test2&quot;}}\n\tSendAlerts(nois)\n\tnois = append(nois, &amp;WeChatNotifier{&quot;test3&quot;})\n\tSendAlerts(nois)\n}"},"SRE入门/Go语言/3.多线程与并发":{"slug":"SRE入门/Go语言/3.多线程与并发","filePath":"SRE入门/Go语言/3.多线程与并发.md","title":"3.多线程与并发","links":[],"tags":[],"content":"不要通过共享内存来通信，而要通过通信来共享内存"},"SRE入门/Todo/寒假期间Todo":{"slug":"SRE入门/Todo/寒假期间Todo","filePath":"SRE入门/Todo/寒假期间Todo.md","title":"寒假期间Todo","links":[],"tags":[],"content":"\n 学习Go语言\n\n 基本语法\n 接口\n 并发与多线程\n\n\n Linux知识补全\n\n[ ]\n\n\n"},"TODO/CS61系列/CS61A-计算机程序结构与解释":{"slug":"TODO/CS61系列/CS61A-计算机程序结构与解释","filePath":"TODO/CS61系列/CS61A 计算机程序结构与解释.md","title":"CS61A 计算机程序结构与解释","links":[],"tags":[],"content":"CS61系列是伯克利CS专业入门课，其中：\n\nCS61A强调抽象，让学生掌握用程序来解决实际问题，而不关注底层的硬件细节。\n\n注意CS61A虽然明面上是Python的语言课程，其中会有很多抽象的思想和程序构造与运行的原理\n本课程一共39课时，使用记录式学习而非任务驱动，而具体安排将会被放在 google tasks\n\n Lecture1 : Wecome [7.24 → 7.26]\n Lecture2 : Functions [7.26 → ?](中间爽玩了三天)\n Lecture3 :\n"},"imicola的思绪小屋/在之前":{"slug":"imicola的思绪小屋/在之前","filePath":"imicola的思绪小屋/在之前.md","title":"在之前","links":[],"tags":[],"content":"一份人生不应该只有理性的学习与对学业事业的偏执追求，一份人生包含的应该是万物，是存在与世界上的，能被我们所看到的光景。也有属于我们自己的理想与思考"},"imicola的思绪小屋/思考/圆形监狱":{"slug":"imicola的思绪小屋/思考/圆形监狱","filePath":"imicola的思绪小屋/思考/圆形监狱.md","title":"圆形监狱","links":[],"tags":[],"content":"1785年，边沁提出了一种监狱结构，这种监狱主体呈现圆形，圆周上是囚禁监狱犯人的牢房，圆心是可以观察到每一个犯人的瞭望塔。边沁认为，这种监狱结构可以使用最少的人来监管最多的犯人，因为瞭望塔每个犯人都暴露在可见的监管下，同时监管的不可知性让犯人有自束压力从而保持在自我约束下。\n多年以后，一位叫福柯的哲学家用圆形监狱来隐喻权力在社会上的运作，福柯指出权力有其“可见性”与“不可知性”从而在社会上运作。但我们今天不考虑复杂的事物，我们从圆形监狱这个概念本身去探讨一些东西。\n首先，我们发现，犯人完成自我约束的主要因素有两个，一个是来自外部的，以瞭望塔为象征的来自更上层的监管，因为其来自“他者”，我们姑且称其为“他者监管”；还有一种是以犯人心理因为惧怕“他者监管”而产生的自我约束，我们称其为“自我监管”。那我们从这两个不同的“监管”的角度去看待一些社会现象和剖析一些行为吧。\n我们先从更大的“他者监管”来说起，我们试想一下，如果要实现他者的监管，这个“他者”应该具有什么样的熟悉呢？很显然，“权威”，“强制执行力”，“绝对上层”。听着是不是和“权力”很相似？我们再继续往下想想，权力是一个很明确的东西吗？其实并非，权力可以是法律，是规矩，是领导老师等等。这其实体现了权力的“去中心化”与“离散化”。人们收到的外部监管并不来自某一个特定的明确的东西，而是非常多的，非常不明确的“监管网络”。\n现在我们从一个例子去了解“他者监管”——《1984》。\n\n《1984》简述的是在未来的1984年1在极权统治下的大洋国，主人公温斯顿在老大哥的全天候监控中逐渐觉醒。他偷偷写日记质疑政权，与茱莉亚相恋并加入地下反抗组织兄弟会，却被伪装成革命者的思想警察奥勃良诱捕。经过残酷的肉体折磨与精神洗脑，温斯顿最终背叛爱人和自我，成为彻底臣服于双重思想的行尸走肉。\nDeepSeek\n\n上面的概括来自deepseek，如果有兴趣也可以去阅读一番，是反乌托邦的经典名著。我们从书中这么一个高压社会来观察其“他者监管”的体现。第一是“老大哥”，书中有说过，“老大哥一直在看着你”，其实体现了一直“监管的不可知性”。“老大哥”也是一种符号象征而已，真正进行“监管”的是无处不在的电幕和他人，这种精神上的无限监管和来自外界的监管构成了《1984》大洋国的“他者监管”。而且这种外显性质的老大哥监管和渗透到所有地方的电幕监管也正好体现了“他者监管”或者称权力的“去中心化”与“网络化”的特点。\n现在我们来看另一个监管，既“自我监管” ，在正式探讨之前我们需要了解一个事实。就是“自我监管”的产生来自什么地方？\n人会生来既监管自己吗？显然不会，所以自我监管的形成中绝对有外部（“他者监管”）的介入：社会规范对我们的符号化植入2，拉康的“大他者”理论3。这些都可以是更大的“他者监管”对自我进行的“诱导”4 。但是自我在对自我的监管中什么都没有做吗？其实不然，“自我意志”在“他者监管”提供的行为准则框架中为“自我监管”赋予了一定的能动性，我们个体在“他者的监管下”实行反思创造思想，其实是在重塑“自我监管”的部分监管逻辑。\n现在了解了“自我监管”的产生，我们要思考一个问题——“在‘他者监管’和‘自我监管’的双重监管下，人的自由意志真的自由吗？”当我们认为其是自由的时候，我们是否想过，我们以为的自由意志其实早就在社会（权力）对我们的符号化植入中变得固定下来了？我们是否想过，我们认为的自由选择实际上是在双重监管下做出的类似圆形监狱囚犯的自我约束行为？\n我们将这种个人抉择与社会权力结构的博弈形象的比做“带着镣铐舞蹈”，镣铐即社会权力结构，舞蹈则是我们的“自由意志”。我们必须清醒的认识到打破镣铐是不可能的，所以我们需要清醒的认识到镣铐和舞步都是存在的，并在此基础上跳出自己的舞步，在名为社会的圆形监狱里活成清醒的囚犯。\n\n下面是笔者碎碎念：\n四月真是非常非常忙的日子，有很多的比赛考试（何尝不是一种“他者监管”）qaq，写这篇文章的契机是前段时间在B站上刷到了这么一个作品“[考研数学张宇]圆形监狱”的音mad作品，原曲是r-906的Panopticon，笔者本人其实就非常喜欢r-906的歌曲，加上视频确实有多的一层精神内核和符合笔者目前大一的大学生被考研（就业）压力心理，所以就写了这么一篇文章。\n其实回顾我的人生发现到处都是“他者监管”和“自我监管”的影子，从高考到高考考差了第一时间想的是考研考上一个更好的大学，这就是我的自由意志决定的“伪自由”，是“他者”比如社会形式，就业压力带给我的选择。唉qwq。但是最近有在开始学习画画，想给自己除了打a（ACM），写作业（其实也不怎么写（逃）），玩游戏这些空闲时间找些事情做，不得不说，画画真是一件非常能让人静下心来的事情，非常有代入性，让人能快速进入“心流”状态（好久没体验过了说）\n就这样吧，祝你好梦（或者祝你美好一天？）\n\nFootnotes\n\n\n《1984》写于1948年，故称1984年为未来。 ↩\n\n\n对于符号化植入，比较通俗的解释是潜移默化的行为教化行为，而在这个过程中作为被教化的主体不会感受到强硬的教化感 ↩\n\n\n对于“大他者”，拉康的定义并非指具体的人，而是“象征秩序的总和”，包括语言、社会规范、法律、文化传统等结构性存在。比如当你说“我应该结婚”，这个“应该”并非来自你内心的真实需求，而是大他者（社会对“正常人生”的定义）通过语言和文化灌输的结果 ↩\n\n\n准确说，应该是提供框架，因为自我监管不只有外部因素影响，在下文便会提及，“自我思想”在“自我监管”的产生中仍然占据相当大一部分 ↩\n\n\n"},"imicola的思绪小屋/思考/透过他物窥见人——人背后之物性":{"slug":"imicola的思绪小屋/思考/透过他物窥见人——人背后之物性","filePath":"imicola的思绪小屋/思考/透过他物窥见人——人背后之物性.md","title":"透过他物窥见人——人背后之物性","links":[],"tags":[],"content":"在影视和文学作品中有一类十分奇特的手法，这种手法带着浓厚的魔幻主义色彩，用一种现实主义之外的手段将某一人物（物体）的特征推向一个近乎极端的方向。相信不少朋友可以在标题和笔者的描述中猜出个大概来。没错，它便是在文化作品中的“物化人”以及“人化物”的手法。\n有的朋友可能有疑问：“上述的两种手法不就是拟人与拟物吗？为什么要大费周章的用新名词来代替它呢？”这其实牵扯到我们现在探讨的核心问题：究竟何为物化人（人化物），这样的手法有什么作用。\n我们先从简单的“物化人”来探讨，同时笔者也会结合一个朋友对我的回答来共同回答这个问题。\n首先让我们先来定义下物化人：没有人性的物体，包括但不限于动物，植物，自然现象，物体在文化作品中被赋予人性，即理智，人格，感性等一切人特有的“属性”。这类手法最容易出现在子供向作品与中国诗歌中出现。\n简单回答了定义后，我又去征集了下朋友的意见。这位对心理学抱有强烈兴趣的朋友这样回答了我的问题,他指出：我们都有”领地意识”，而这份”领地意识“中又有一个重要的概念叫领地共享，因为一个集群中的人（甚至是动物）都会有这种领地归属感，所以认同感便自然产生了，随后便形成了同类认同。有了这前面的铺垫，对于将动物，植物，甚至是无机物都披上“人”的底色的这种手法的解释，特别是在子供向作品中，便十分清楚了，这是同质化的过程，是一种从读者方面发出的需求。\n\n这是一种需求的体现，是让孩子们更容易接受的需求。由于“同类认同”的天性，孩子们更倾向于从与自己相似的事物中获取知识和构建价值观。 \nFawnKanzler\n\n看了在心理学上的解释，那我们不如从另一个角度再来看看这个问题，从偏向哲学与文学方面来看这个问题。所谓物化人，可以理解为作者想与读者建立一种亲近感，而这种亲近感有利于读者更好感受作者的作品思维。有美学知识的朋友或许知道，当我们进行审美活动时，我们都是以”人”作为主体，以自己的审美感受出发，来判断事物和物体的美。而这种思维使我们在审美体验中产生了一种”人化”审美客体的倾向，就像有一个指向自己的力一样，将我们的审美对象人化。而这种物化人的手法，直接的将我们不自觉的人化过程摆在你面前，帮助你跳过了人化客体的过程，进而增强了我们的审美体验。而在文学方面，这种建立了和读者亲近感的手法最终想要达成的目的是什么呢？我觉得是价值表达和情感表达。当文学作者试图将一个物品人化时，他的原初动力依然是表达自己的价值观与情感。倒不如说几乎所有文学作品都是为了表达上述两个观念。所以这种手法是将一个熟悉或陌生的物体转化为所有人都熟悉的，将自己的思想与读者搭上线的一种手段。\n\n聊完物化人，我们再来看看更深刻一点，有点违背人的本性的人的物化。\n不知各位看完上面视频的感受如何，但我想感受一定不会是正面的，甚至有些厌恶、恶心。影片来自2008年《东京！》三部曲中的第一个《室内设计》。影片内容还是十分有深度的，并且影片在B站就可以看，推荐对存在主义之类感兴趣的朋友去看看。而在这个片段中，我们感受的正是人化物的手法在影视作品中的体现。与物化人不同，人化物更忤逆人的天性，如果说物化人是同质化的过程，那么人化物便是去质化的过程。而去质化意味着要从一个”质”中脱离出去，即从”人”这层包含太多太多的身份意义中脱离出去，而完全暴露一个物(人)的特征。从人向物走去，是不符合人的天性同类认可的，自然会引起人的不适。\n与马克思的劳动异化不同的是，文学作品中的异化往往更加激进，试图将这个人都所以称之为人的特点褪去，只留下物的特征。虽然我们也可以找到譬如《变形记》中的格里高利的异化是来批判讽刺资本主义的小说，但就论其本身的将人变为不受所有人待见，被所有人恐惧的甲虫，其实更加凸显了当时社会上的底层工作者的地位。而马的思想更集中在人在劳动中逐渐丧失自我从而异化的过程上。\n\n因此，结果是，人（工人）只有在运用自己的动物机能——吃、喝、生殖，至多还有居住、修饰等等——的时候，才觉得自己在自由活动，而在运用人的机能时，却觉得自己只不过是动物。动物的东西成为人的东西，而人的东西成为动物的东西。\n吃、喝、生殖等等，固然也是真正的人的机能。但是，如果使这些机能脱离了人的其它活动，并使它们成为最后的和唯一的终极目的，那末，在这种抽象中，它们就是动物的机能。\n马克思《1844年经济学哲学手稿》\n\n那我们便不由得好奇作者在这里使用这么一个不讨人喜，有些激进的手法的原因了。按照我的那位朋友的说法“吸引了兴趣，引人深思。”引人深思固然没错，但吸引兴趣这点有待商榷，按照我们上文的讨论，这样的手法是反人类的，是与人的天性相悖的，这样的情况对我们读者的吸引力并不会有多少提高，甚至有减弱的倾向。那么作家不惜放弃读者感受也要使用的手法究竟为了什么呢？我认为有两点，一点是文学作品的目的上，即作家想表达的价值观和思想感情上。另一个是作者有意刻画的冲突。我们主要来讲讲冲突，我认为可以分为两方面的冲突，即与文章情节的冲突与人物人性的冲突。如果说物化人是物的“升华”，使人包容了物，感受了物的话，那么人化物便是人的”退化”,将人蜕去人的身份，从更奇怪，更独特的视角，以饱含所变之物的特征的立场来看所有人。而这个退化的过程与文章正常情节是冲突的，与文章的其他人物是冲突的，甚至与我们读者的思维认知是冲突的。这样的强而有力的冲突感被我朋友如此说明\n\n让人难以在潜意识中接受它，从而产生一种呼应的态势，再辅以人化物的冲突违和，将潜意识中这种思想具象于意识之中，使作品产生引人深思的效果。\nFawnKanzler\n\n物化人是作者表达自己思维的工具，而人化物则更像作家一种”哲性”的思考。是一种跳出现实主义的颇具”浪漫”色彩的文学书写。\n在此总结一下，人化物与物化人都是文学手法，本质都是”异变”,只是方向的不一致，进而带来的效果不一样。而这两种手法都可以认为是作者表达自己的思想的手段，是用来与读者建立精神联系的方法。"},"imicola的思绪小屋/闲谈/大学小记":{"slug":"imicola的思绪小屋/闲谈/大学小记","filePath":"imicola的思绪小屋/闲谈/大学小记.md","title":"大学小记","links":[],"tags":[],"content":"有些意外的是，上大学没有想象中的那么轻松，但确实比高中时期的压抑感少许多。特别是处于大一这样的一个几乎对未来是一种迷茫心态的时期。但有一点不同的是，在高中线性式的时光中我们的目标十分明确，无非就是考个高中，上个好大学。相反，大学太开放了，开放到令人焦虑。\n高考完后，就有一种无形的焦虑感一直伴随着我。也许是为了让自己放松（？）让自己心情缓缓，暑假就把自己一直处于学习和看书的状态。人忙起来就会忘记自己的焦虑和低沉的确没错，但这只是一种逃避的行为。那些焦虑仍然埋在心底，待到我静静躺在床上时，从图书馆出来时，在公园散步时，这些焦虑又会如同潮水上涨般涌上心头，给予我一份无助感。\n在大学待了几天后，这种焦虑感的来源似乎有些许清晰，正是我开头说的开放带来的焦虑。\n把你放在空无一人的超市，塞到广阔无限的草原，一种惊慌失措感会席卷你。进入一个全新的环境，没有了之前人生的线性方向感，让你自己做出可能会影响你接下来人生的选择，这种“空旷”的心理感觉和前文所述的空旷环境所带来的感受是一样的。不确定的因素带来的恐慌化作焦虑，用不确定的明天让我陷入无助感的深渊。大学间人和人的距离大抵远了许多，至少我感觉如此，总觉得多了些坦率和天真，少了高中时期的那一份互相的信任。\n也可能是我属于保守派（雾），也许是我仍需要一些时间去摸清大学的脉络，过去的毕竟已经成为过去式了，我十分感谢我的高中生活，以及我遇到的所有出现在我高中的人，包括那位赵主任，喜欢怀旧似乎是我的特点之一，我每次向前思考时都喜欢跨越很长很长的时间刻度，将自己从下一秒到入土全盘想好，但不确定又会给我迎头一棒，渐渐的，不知道什么时候，我开始回避思考未来，除了对自己基本的规划外，我更开始将眼光放在几天之内甚至一天之内。但军训实在是太无聊了，人无聊就喜欢瞎想事情，我也喜欢瞎想（\n某知名哲学家萨特的名言“存在先于本质”让我第一次了解到了存在主义，让我从高中那段时间的消沉稍微走出来了，虽然哲学意义上的思想我没法理解过多，但他那让人“自信的认识自己”的理论确实是让人回过神来的良方。但在走出高中之后，又是一种新的认知危机感向我袭来，当我试图用过去安慰我的理论再来安慰自己的时候，就好像产生了耐药性一般。\n说实话，刚上大学的心态难以和高中的心态作比较。倒也正常，几天的经历怎么能和最痛苦与最欢乐的并存时光相比较呢？大学创造的未来估计可能会发光，但那种焦虑带动下的动力我想不会好太多。但细细一想，在初入高中的时候我何尝不也抱着这样的心态呢？不确定的生活不仅带来混乱和意想不到的失败，同时不也带来了惊喜和意想不到的平静吗？\n作为悲观主义的我（可能？）有些难以接受现实大学的理想生活，比起在社团或校园里发光发热更喜欢窝在图书馆的小咸鱼罢了。"},"imicola的思绪小屋/闲谈/时隔半年对高中的感悟":{"slug":"imicola的思绪小屋/闲谈/时隔半年对高中的感悟","filePath":"imicola的思绪小屋/闲谈/时隔半年对高中的感悟.md","title":"时隔半年对高中的感悟","links":[],"tags":[],"content":"时隔半年，在大一的寒假里，因为要去给高二学弟学妹们演讲，回忆了许多高中的事情。对我而言，高中尤其是高二下到高考的那一段时间，是难以忘却的。在经历了大学半年不知道是沉淀还是拷打之后，对高三那纯粹的为某一个目标努力的时光感到有些惋惜（?\n但值得注意的是，高三时光确实是苦的，苦到我难以再去设身处地的经历一次，也导致我没有去选择复读，在这里对我高中复读的同学表示纯粹的敬意。但是最让我不敢复读的缘由是高考上的发挥失利，我其实在高三成绩还算上游的，每次考试都可以稳定班级前10，甚至两次深圳模拟都在前5。但是高考失利了，在我们班大概30多的水平，直接让我对高考有了心里阴影，不敢再面对高考。\n高中在人生占比很低，以一个人活到70岁为例，高中只占据了那个人的4.2%的人生,但它也可以是你人生中占比最大的一个时光。你的第一个18岁，第一场恋爱，第一次确确实实的思考人生，第一次为自己而哭泣。高中是一个人社会观和人生观形成的时间。而在这形成的时间里，某些记忆才能刻入心中。高中三年学的知识对人生影响不如大学一个学期学习的影响大。但是高中三年对你造成的影响是刻入人生的。对高中的怀念实际上是怀念那些与你朝夕相处的朋友，那个你当年喜欢却没开口的同学，那场轰轰烈烈却最终不了了之的爱情，那些跳出规矩，疯狂作死的夜晚，那些留在学校却胜过留在家中的周末，那些考试前一天晚上的晚自习。\n我翻看我的成绩表的时候，内心有一股遗憾难以平息，但我想到了我们物理老师涂涂的话：“当你进入大学，从大学毕业就是为国家做贡献，无论你是什么大学，你其实都在为国家做贡献，只不过扮演的角色不同罢了”。现在想想确实如此，虽然进入社会起点已经低人一等，但是人毕竟是要活下去的。以这个为前提，就不会觉得自己落差有多大了，因为每个人的是以活下去为前提生活的，向上看有许多比自己高的人，但向下，差于自己的人也不少。平凡的活下去，找些自己能去做的事情，找点自己的爱好满足自己，爱自己胜过爱世界。﻿\n现在在大学时，也常常怀念高中，怀念那个一成不变的日子，怀念那个一天被拉的好长的时光。当你猛灌生活的苦水的时候，你会不得不怀念高中那白开的味道。纯粹而值得怀念的时光。‘"},"imicola的思绪小屋/闲谈/闲谈-疾病，人生之苦":{"slug":"imicola的思绪小屋/闲谈/闲谈-疾病，人生之苦","filePath":"imicola的思绪小屋/闲谈/闲谈-疾病，人生之苦.md","title":"闲谈-疾病，人生之苦","links":[],"tags":[],"content":"其实我身体一直不是很好，听父母所说，在出生时期我就因为身体原因做过手术，小学初中时候更是是不是就会发一次高烧，有一次因为扁桃体问题更是切除了一半有余的扁桃体。进入高中，虽然没有那么频繁的发烧了，但是也比同龄人发烧次数高。\n记得小学初中的时候发烧，当时在深圳吊水打消炎药的治疗方式还很常见，在同龄人都害怕针头扎入肌肤的感觉的时候，我早就明白了吊水扎针不会痛的道理，当时一周手上可以出来5,6个针眼，而我像是习惯一般，发烧的浑身酸痛、头晕目眩、乏力这样的症状，对一个10岁多一点的孩童似乎成为了常事，好在那个年龄也是精力最为旺盛的时候，渐渐地，我熟悉了医院那一处角落，那是给孩子们打吊水专门安放的角落，会有个电视机为孩子们放些动画片，幼年的我通过这台电视看了很多很多集的海绵宝宝(很奇怪，这个电视好像就只放海绵宝宝)。那个角落里，有因为吊水两个小时被囚禁在椅子上叫苦不堪的我，同样也有在旁边一脸疲惫的父母，也有各种各样的人们，有形色匆匆的医生，有脸上写满温柔的儿科护士和在她手下哇哇大哭的将要被打针的孩童，有从外面买一口粥回来给自己儿女吃的父母。\n渐渐地，有一场变化改变了人生与世界\n新冠\n其实新冠似乎是有两次高峰期，第一次好像发生在初中时期，当时全校都放了假到家里去上网课。第一次的新冠对我似乎没有多大的影响，只不过是在家上了一场网课，爽玩了一段时间。但是第二次发生在高二的时候，我记得当时是自愿留校学习和回家上网课。显然“好学”的我并没有回家(实际上是不知道用什么理由和老师与父母说)。当时我们班50人陆陆续续离开，到后面就只剩下20左右的人了，但是说实话，那段时间反而显得有些纯粹，因为大部分人都回了家，老师讲课的速度变得忽然就像是开了0.5倍速一样，作业也是大砍特砍，一节晚自习就可以干掉所有作业，然后剩下的时间就如同大考前没有作业的晚自习一样，是属于高中学生的独特浪漫时间。到了后期学校不知道是不是因为无形大手的力量将所有留校的人遣返回家了。\n说实话，新冠让很多人感受到了生命的脆弱，这其中当然包括我，在2022年平安夜那天夜晚，我阳了。所以说不要信西方神(？ 我依稀记得当时烧到40度的我，在潜意识里第一次感受到了生命对死亡的畏惧，合不拢眼，意识迷离。在床上看着体温计上的数字变高，吃完布洛芬后又因为退烧作用满身大汗，又在药效之后绝望的看着体温计的数字继续变高。幸运的是，命运似乎没有置我于死地，在当了两天的“蒸汽轮机”之后体温便逐渐冷静下来，让我终于可以放松下来，还是非常感谢我的父母在我发烧和阳的时候的不离不弃。\n上了高三，还有一场大病是让我印象深刻的。大概是高考前100多天作用，大家都进入非常紧张的备考阶段(对了，写这篇文章的时候正好是2025高考，在这里祝福各位考生考完的全对，还没考科目的全会)。有一天晚自习我就感觉脑子发懵不对劲，我习惯的以为是高中以来发生不知道多少次的小感冒，打算等下晚自习回宿舍吃药撑过去，结果这次身体似乎打算给我一次”意外之喜”。半夜，在强烈的不适感和手环的振动中醒来，瞟一眼手环，上面赫然写着”心率过高，请注意身体健康”，我再一看心率——190(谁说在床上不能做有氧运动）。顿时感觉不妙，拿出因为在高中经常发烧而常备的体温计一量——39.6。意识到这绝对不是普通发烧的我在凌晨3点拨通了父母和班主任的电话，在一辆出租车上跨越整个深圳回到了家里。等到第二天去医院检查的时候，被告知是肺炎，需要休息7天并且挂吊水。显然，在一个要高考的高中生脑子里，高考优先级是特别高的，于是我只在家里休息了5天时间，这期间我甚至还问过能不能将吊水药物拿去学校，在学校附近的社康打，但没能成功。\n上了大学，虚弱的身体也没能争一口气，特别是跨越南北的地理位置，让本来不好的身体更是雪上加霜。仅仅大一一年，我少说就发烧了5次，感冒次数更是数不清楚。像是在写这篇文章的时候，其实我还在一场发烧之中，而且这次尤其严重，周五晚上开始体温维持在38度以上，去附近医院打完吊水(不知道为什么感觉东北这边特别喜欢打吊水)已经凌晨12点半了，可惜医院吊水丝毫无用，第二天早上醒来体温突破39大关来到39.6。吃了两颗布洛芬然后经历痛苦的退烧降温过程后总算好了点，然后去医院又被扎了一针，囚禁了两个半小时。依旧无用。最后回到酒店吃布洛芬压下去的。至于为什么是酒店而不是宿舍？首先是怕传染给舍友，其次是舍友都是东北超人，在制造动静和察言观色这些能力上只能说需要提升。\n从我出生到现在，估计有5%的时光在和疾病打交道，不知道是不是因为这个原因，让我在高中的时候选择了生物竞赛以及在高中无聊的时间摸索医学的知识。每一次的发烧，都是一次迷离，一次脱离现实而又被现实紧紧牵挂的体验，小初时期父母的陪伴，高中时候舍友的关心和老师的牵挂。都算是人生之苦上的外界的甜。\n至于大学？是一次教会我要戒甜的教训，不会有人因为你放弃自己的乐趣，不是人人都是有情之人，总有人的情商和智商是不能够令人满意的，独立成为大学生活的必修课，脱离群体，脱离因为一场游戏会焦急的大喊的人，脱离双非学校的灌水式教育。我现在才意识到上交生存手册上的那句背后的含金量\n\n国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃\n\n奇怪，怎么从疾病谈论到大学生活去了？主要还是两者与我而言有共通性吧，无聊，反复，难以撼动…"},"index":{"slug":"index","filePath":"index.md","title":"引导页","links":["C++/基础语法/C++语言入门","C++/STL/STL","ACM/算法/Readme","ACM/算法/DP-动态规划/","ACM/题解/","基础入门/MIT-Missing-Semester/前言","Linux/折腾/从零开始安装linux","杂项/正则表达式","Latex/Latex初学","TODO/大一下暑期计划/前言"],"tags":[],"content":"\n  从知识到人生\n  个人图书馆 for imicola\n\n\n由于GitHub-Pages弱加载问题，你可以尝试使用 shift + f5 来刷新页面资源来解决资源未更新问题\n\n\n  \n  \n    🚀 C++ 程序设计\n    从入门到进阶，探索C++的强大功能与优雅实现。\n    \n      基础语法\n      STL 标准库\n    \n  \n  \n  \n    🧠 ACM 与算法\n    算法竞赛的笔记、解题思路与实战总结。\n    \n      算法笔记\n      动态规划\n      题解汇总\n    \n  \n  \n  \n    💻 计算机基础\n    探索计算机世界的基石，掌握高效工具与核心知识。\n    \n      MIT Missing Semester\n      Linux 探索\n    \n  \n  \n  \n    🛠️ 杂项与工具\n    一些零散的知识点、工具学习笔记和待办事项。\n    \n      正则表达式\n      Latex\n      暑期计划\n    \n  \n\n更新说明："},"基础入门/MIT-Missing-Semester/Shell":{"slug":"基础入门/MIT-Missing-Semester/Shell","filePath":"基础入门/MIT-Missing-Semester/Shell.md","title":"Shell","links":["Linux/常见命令/ls"],"tags":[],"content":"shell是什么？\n在开始之前，我们需要了解 shell 是什么？\n\nshell是一种文字交互界面，与GUI(用户图形化界面)不同，shell允许你执行程序，输入并获取某种半结构化的输出\n\n在以下的演示中，我们使用manjaro in wsl来使用shell,这里我们使用bash，既Bourne Again SHell来作为演示终端\n使用shell\n当我们打开终端时候，我们会看到类似下面的提示符\n[imicola@LAPTOP-1R3FN2QL ~]$ \n这是 shell 最主要的文本接口\n这个提示符告诉我们一些基本信息：\n\nimicola 是笔者用户名\nLAPTOP-1R3FN2QL 是电脑名称\n~ 表示工作目录，至于’~‘,实际上表示的是一整个目录结构，但是经常使用便被简写1\n$ 表示目前身份不是root用户\n\n我们可以输入命令并被shell解析，比如我们输入\n[imicola@LAPTOP-1R3FN2QL ~]$ date\nSun Jun  1 02:45:48 PM CST 2025\nshell就会告诉我们时间与日期\n我们同样可以使用shell去输入带有参数的命令，比如对echo命令，这个命令会打印你给它的参数，如下\n[imicola@LAPTOP-1R3FN2QL ~]$ echo hello\nhello\n则echo或输出hello\n\n当我们输入的参数本身带有空格的时候我们可以使用”hello world”来为echo传入一个字符串参数，我们还可以使用 hello\\ world来转译空格符号\n\n\n\n                  \n                  扩展:shell是如何找到命令并且运行的 \n                  \n                \n\n\n\n类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 环境变量 $PATH，它会列出当 shell 接到某条指令时，进行程序搜索的路径\n我们可以使用来查询我们的环境变量有什么\n\n[imicola@LAPTOP-1R3FN2QL ~]$ echo $PATH\n\n比如当我们执行echo指令时候，shell会在环境变量里通过$PATH搜索由：划分的一系列目录，基于名字搜索这个程序，当找到该程序后便执行程序\n我们也可以使用which指令确定某个程序名代表的是哪个具体的程序，这样可以绕过$PATH直接执行这个程序\n\n\n\n\n在shell中导航\n在谈论这些之前我们先需要认识导航是什么？\n\n我们从一个目录定位到另一个目录的行为称之为导航\n对于每个目录，其存在一个路径，在linux和macOS上使用/分割，在Windows上使用\\分割\n在linux或macOS上 / 也表示一个路径，代表系统的根目录，所有的文件夹都处于这个目录下\n对于Windows，每个盘都有一个根目录，如C:\\，D:\\\n对于本课程，我们从linux下考虑\n如果某个路径以/开头，则其为绝对路径，其他的都是相对路径。\n相对路径指的是相对于当前工作目录的路径\n当前工作目录可以使用命令pwd获取\n\n[imicola@LAPTOP-1R3FN2QL ~]$ pwd\n/home/imicola\n此外，切换目录可以使用cd命令。在路径中 .表示当前目录..表示上级目录\n[imicola@LAPTOP-1R3FN2QL ~]$ pwd\n/home/imicola\n[imicola@LAPTOP-1R3FN2QL ~]$ cd /home\n[imicola@LAPTOP-1R3FN2QL home]$ pwd\n/home\n[imicola@LAPTOP-1R3FN2QL home]$ cd ..\n[imicola@LAPTOP-1R3FN2QL /]$ pwd\n/\n[imicola@LAPTOP-1R3FN2QL /]$ cd ./home\n[imicola@LAPTOP-1R3FN2QL home]$ pwd\n/home\n[imicola@LAPTOP-1R3FN2QL home]$ cd imicola\n[imicola@LAPTOP-1R3FN2QL ~]$ pwd\n/home/imicola\n[imicola@LAPTOP-1R3FN2QL ~]$ ../../bin/echo hello\nhello\n注意到shell会实时显示当前的路径信息，我们也可以通过配置shell提示符来显示各种有用的信息，比如笔者自己配置的zsh显示效果如下：\n\n一般来说，当我们运行某个程序的时候，如果没有指定文件路径，则该程序会在当前目录下执行，比如我们需要知道一个目录下存在什么文件/文件夹，我们可以使用ls命令\n[imicola@LAPTOP-1R3FN2QL ~]$ ls\nastrbot  autojump  data  gewechat  imicola\n除非我们使用第一个参数指定目录，否则ls会告诉我们这个目录下的文件\n\n大多数的命令接受标记和选项（带有值的标记），它们以 - 开头，并可以改变程序的行为。通常，在执行程序时使用 -h 或 --help 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。\n\n比如ls -l可以更加详细的列出目录下文件或文件夹的信息\n15:52:39 with imicola in ~ …\n➜ ls -l\ntotal 20\ndrwxr-xr-x 2 imicola users 4096 Mar 22 20:16 astrbot\ndrwxr-xr-x 6 imicola users 4096 May 27 22:25 autojump\ndrwxr-xr-x 9 root    root  4096 Mar 22 20:43 data\ndrwxr-xr-x 3 imicola users 4096 Mar 27 15:45 gewechat\ndrwxr-xr-x 3 imicola users 4096 Mar 23 21:37 imicola\n对于 ls -l 输出的参数的含义，可以参考Linux命令ls\n同时我们应该掌握这些命令：\n\nmv(用于重命名或移动文件)\ncp(拷贝文件)\nmkdir(新建文件夹)\n\n我们可以使用man这个程序来获取程序参数、输入输出的信息，了解其工作方式\n在程序之间创建链接\n在shell中，程序有两个主要的”流”——输入流和输出流\n\n当程序试图读取信息的时候，它会从输入流中读取\n当程打印信息的时候，它会将信息输出到输出流中\n通常一个程序的输入和输出流都是终端，即将键盘作为输入流，显示器作为输出流，但我们也可以重定向这些流\n我们可以使用 &lt; file 和 &gt; file.这两个命令将程序的输入输出重定向到文件\n\n19:38:20 with imicola in ~/imicola/learn_test …\n➜ echo hello &gt; hello.txt &amp;&amp; cat hello.txt\nhello\n \n19:38:53 with imicola in ~/imicola/learn_test …\n➜ cat &lt; hello.txt &gt; hello2.txt\n \n19:39:37 with imicola in ~/imicola/learn_test …\n➜ cat hello2.txt\nhello\n\n这里解释第二条命令：我们将hello.txt的内容用cat读取然后输出流定向到hello2.txt\n\n\n==还可以使用 &gt;&gt; 来向一个文件追加内容==。使用管道(pipes)，我们能够更好的利用文件重定向。|操作符允许我们将一个程序的输出和另外一个程序的输入连接起来\n\n19:39:43 with imicola in ~/imicola/learn_test …\n➜ ls -l / | tail -n1\ndrwx------   2 root    root    4096 Apr  1 17:31 wslIjmBcD\n\ntall 命令表示显示最后几行(不加参数默认20行)，-n &lt;行数&gt; 表示显示几行，在这里我们将根目录的ls -l传入tall并且输出最后一行\n\nroot\nroot是类unix系统下的一类用户，也称根用户，一般情况下，我们不会直接以根用户的身份登录系统，因为这可能会导致某些错误，取而代之的是我们一般使用sudo命令来执行一些操作，在遇到一些权限问题或者拒绝访问时候，我们可以使用sudo命令进行访问\n\n\n                  \n                  以root用户登录系统 \n                  \n                \n\n\n在linux下，以root用户身份登录系统是非常危险的事情，请确保你确实需要再登录。\n我们可以使用\nsu root\n命令登录，这会要求你输入root用户密码\n\n\n\nFootnotes\n\n\n实际上这个~指向的是/home/user目录 ↩\n\n\n"},"基础入门/MIT-Missing-Semester/shell工具与脚本":{"slug":"基础入门/MIT-Missing-Semester/shell工具与脚本","filePath":"基础入门/MIT-Missing-Semester/shell工具与脚本.md","title":"shell工具与脚本","links":["基础入门/MIT-Missing-Semester/Shell","杂项/短路运算符","杂项/正则表达式","Linux/常见命令/find","fd","Linux/常见命令/grep","基础入门/MIT-Missing-Semester/数据整理"],"tags":[],"content":"shell脚本\n对于shell语言，我们已经在Shell里介绍了基本情况，但是如果我们想更进一步执行更复杂的操作的时候，单纯的一行一行的终端就难以满足我们。此时我们可以使用shell脚本来帮助我们执行\nshell脚本在复杂性上进一步提高\n大多数shell都有自己的一套脚本语言，包括变量,控制流和自己的语法规则，同时shell脚本针对shell所进行的工作进行了优化。\n在本章节我们会专注与bash脚本，因为它最流行也是用途最广泛的shell脚本语言\n基本语法规则\n\n在bash中为变量赋值的语法是=，例如: foo=bar,访问变量中储存的数值，其语法为$foo\n\n值得注意的是，对于foo = bar(使用空格隔开)是不能工作的，因为解释器会调用foo 并将 =和 bar 作为参数传入\n所以在使用shell脚本务必要注意空格的使用，因为空格会起到分割参数的功能。\n\n\nbash中的字符串通过 &#039; 和 &quot; 分隔符来定义，但是其含义并不一致\n\n用 &#039; 定义的字符串被成为原义字符串，其中字符串不会被转译\n用 &quot; 定义的字符串会将变量值进行替换\n\n\n\n22:28:21 with imicola in ~ …\n➜ homo=114\n \n22:28:53 with imicola in ~ …\n➜ echo &#039;$homo&#039;\n$homo\n \n22:29:28 with imicola in ~ …\n➜ echo &quot;$homo&quot;\n114\n\nbash通过 # 来进行注释\n\n和其他大多数编程语言一样，bash也支持 if , case , while 和 for这些控制流关键字，同样的，bash 也支持函数\nif\n\n在介绍if语法之前，我们需要知道\n\n在shell中，表示判断的命令通常是test或别称[ ,在实际应用中我们更喜欢使用其扩展 [[ 功能更加强大\n在一行书写多个命令的时候，需要使用 ; 分割。在 if , case 等结构中，then，do 等关键词前不需要 ; 但是如果在同一行，则需要\nif 使用 then...fi来定义代码快\nif语句用于执行条件判断，根据执行结构执行不同的代码块\n基本语法\n\n\n\nif condition; then\n\t# 如果condition为真(返回0),则执行以下命令\n\tcommand1\n\tcommand2\nfi\n\n带else\n\nif condition; then\n\t# condition 为真\n\tcommand1\nelse\n\t# condition 为假\n\tcommand2\nfi\n\n带elif\n\nif condition1; then\n\t# condition1为真\n\tcommandA\nelif condition2; then\n\t# condition1为假且condition2为真\n\tcommandB\nelse\n\t# 如果condition1 和 condition2均为假\n\tcommandC\nfi\n常用的条件判断：\n\n数值比较：\n\n[[ $a -eq $b ]]：等于 (equal)\n[[ $a -ne $b ]]：不等于 (not equal)\n[[ $a -gt $b ]]：大于 (greater than)\n[[ $a -ge $b ]]：大于等于 (greater than or equal)\n[[ $a -lt $b ]]：小于 (less than)\n[[ $a -le $b ]]：小于等于 (less than or equal)\n\n\n字符串比较：\n\n[[ &quot;$str1&quot; = &quot;$str2&quot; ]] 或 [[ &quot;$str1&quot; == &quot;$str2&quot; ]]：等于\n[[ &quot;$str1&quot; != &quot;$str2&quot; ]]：不等于\n[[ -z &quot;$str&quot; ]]：字符串为空 (zero length)\n[[ -n &quot;$str&quot; ]]：字符串非空 (non-zero length)\n\n\n文件测试：\n\n[[ -f &quot;file&quot; ]]：文件存在且是普通文件 (file)\n[[ -d &quot;dir&quot; ]]：文件存在且是目录 (directory)\n[[ -e &quot;path&quot; ]]：文件或目录存在 (exists)\n[[ -r &quot;file&quot; ]]：文件可读 (readable)\n[[ -w &quot;file&quot; ]]：文件可写 (writable)\n[[ -x &quot;file&quot; ]]：文件可执行 (executable)\n\n\n\n\ncase\ncase语法通常根据一个变量的值来进入指定的代码块，标准语法如下：\ncase experession in\n\tpattern1) # 如果experession匹配1\n\t\tcommandA\n\t\t;; # 匹配结束符\n\tpattern2)\n\t\tcommandB\n\t\t;;\n\tpattern3 | pattern4) # 可以使用 | 连接多个匹配项 \n\t\tcommandC\n\t\t;;\n\t*) # deflut情况\n\t\tcommandD\n\t\t;;\nesac\n\nwhile\n基本语法\nwhile condition; do\n\tcommand1\n\tcommand2\ndone\n\nfor\n基本语法\nfor item in list; do\n # 每次循环，item会取 list 中的一个元素\n # item是变量，list是提取的东西\n command1\n command2\ndone\n扩展语法\n类似与C语言\nfor(( initalization; condition; incement )); do\n\t# 循环体\n\tcommand1\ndone\n\n\n                  \n                  遍历文件行 \n                  \n                \n\n\n虽然不是标准的 for 循环语法，但通过管道和 while read 结合可以遍历文件的每一行。\nwhile TFS= read -r line; do\necho &quot;读取到行：$line&quot;\ndone &lt; &quot;filename.txt&quot;\n\n\n\n函数与参数\n我们通过下面这个例子了解函数\nmcd(){\n\tmkdir -p &quot;$1&quot;\n\tcd &quot;$1&quot;\n}\n这个函数表示创建一个文件夹并且cd进入这个文件夹\n这里的$1是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数，错误代码和相关变量，下面列举一些例子\n\n\n$0 - 脚本名\n$1 - $9 -脚本的参数。$1是第一个参数，以此类推\n$@ -所有参数\n$# -参数个数\n$? -前一个命令的返回值\n$$ -当前脚本的进程识别码\n!! -完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !! 再尝试一次。\n$_ -上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。\n\n\n更完整的列表可以在这里参考\n\n在命令中通常使用 STDOUT 来返回输出值，使用 STDERR 来返回错误以及错误码\n对错误码而言，返回值为0表示正常执行，其他所有非0返回值都表示有错误发生\n退出码可以搭配 &amp;&amp; (与操作符) 和 || (或操作符) 使用，用来进行条件判断，决定是否可以执行其他程序。\n注意，上述两个操作符号都属于短路运算符\n命令替换\n我们可以使用命令替换的方式来将变量的形式替换为命令的输出\n比如当我们通过$(cmd)来执行 cmd 指令的时候，他的输出结果会换掉 $(cmd)\n\n例如我们执行 for file in $(ls) shell会先执行 ls 然后遍历得到的这些返回值\n\n\n\n                  \n                  Tips\n                  \n                \n\n\n还有一个小众的特性叫做进程替换(process substitution),基本规则是 &lt;(cmd)\n当我们使用这个的时候 &lt;(cmd)会执行cmd并将结果输出到一个临时文件里,并将 &lt;(cmd)替换成临时文件名\n\n\n\n对于这个例子,我们可以通过下面的例子来解释 $(cmd)的作用\n#!/bin/zsh\n \necho &quot;程序运行开始于 $(date)&quot;\necho &quot;程序 $0 在 $# 个参数下运行与进程 $$&quot;\n \nfor file in &quot;$@&quot;\ndo\n    grep 114514 &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null\n    if [[ $? -ne 0 ]]; then\n        echo &quot;文件 $file 不存在114514,将在最后添加&quot;\n        echo &quot;114514&quot; &gt;&gt; &quot;$file&quot;\n    fi\ndone\n\n这个脚本会遍历你输入的所有文件参数并且寻找114514,如果没有找到则会在末尾添加一行114514\n\n通配\nshell的通配字符主要应用在文件路径的展开上,需要注意的是,通配不是正则表达式,而是更简单的快速选择文件的符号\n\n? 匹配一个字符\n\n如 file?.txt匹配file1.txt,fileA.txt等\n\n\n* 匹配任意字符\n\n如 *.py 匹配所有 .py 结尾的文件\n\n\n[] 匹配方括号中的任意一个字符\n\n如 [abc].txt 匹配 a.txt,b.txt,c.txt\n\n\n{} 列表生成,即扩展为逗号分隔的字符串列表\n\n如 {test1,test2}.txt 会被扩展成 test1.txt test2.txt\n\n\n\nshell 工具\n查看命令如何使用\n一般而言在shell中如果要查找某一个命令如何使用以及它可以使用的参数,我们一般使用指令\n\nman cmd\n但是有的时候英文解释看不懂,一般情况可以通过翻译以及搜索引擎了解,但是目前准确率相对较高且直接明了的方式是 询问ai\n\n查找文件\n查找文件我们一般使用find命令和fd命令,可以点击查看具体用法\n查找代码\n查找代码与文件内容我们一般使用 grep 命令,是用于对输入文本进行匹配的通用工具,同时我们也会在数据整理这节课上升入探讨\n查找 shell 命令\n对于以前输入的命令,shell一般会储存在 ~/.xxx_history\n我们可以使用history指令与 grep 寻找之前的指令,对于zsh与使用zsh框架的 oh-my-zsh都会可以使用上下键来查看历史记录\n\n对于大多数shell来说,可以使用 Ctrl + R 来对历史记录进行回溯搜索\n同时使用 oh-my-zsh的插件可以实现基于历史的补全\n\n文件夹导航\n对于一般而言 cd 足以在文件夹中进行导航,当我们想看见树状结构与文件目录的我们可以使用 tree 指令\n对于快速导航我们可以使用 auto jump这样的命令,快速跳跃到我们需要的目录里"},"基础入门/MIT-Missing-Semester/前言":{"slug":"基础入门/MIT-Missing-Semester/前言","filePath":"基础入门/MIT-Missing-Semester/前言.md","title":"前言","links":[],"tags":[],"content":"虽说这篇笔记是cs入门基础，但是笔者在写下这笔记的时候，大一都快结束了。并且笔者并非计算机科班出生的，秉着学习是高尚品格和提升计算机基础学习目的，所以打算自学这一篇课程\n课程是来自MIT的MIT-Missing-Semester,主要讲述的是大学老师不会提起但是一些非常重要的学问，在MIT课程简介上主要有以下的课程\n\nshell是什么\nshell工具与脚本\nvim和编辑器\n数据整理\n命令行环境\n版本控制(git)\n调试及性能分析\n元编程\n安全与密码学\n大杂烩\n\n对于这门课程入门，我给出的建议需要拥有一些折腾精神，这样在吸收新的知识的时候也不会感到枯燥无味\n主要是一些工具的使用，在实践性上会大于理论的东西，所以学起来难度也不会很大(至少比离散数学这种难绷课程好学多了)\n建议前置学习：\n\n基本计算机常识原理\n虚拟机的配置(能打开就行)\n"},"基础入门/MIT-Missing-Semester/命令行环境":{"slug":"基础入门/MIT-Missing-Semester/命令行环境","filePath":"基础入门/MIT-Missing-Semester/命令行环境.md","title":"命令行环境","links":["Linux/常见命令/kill","fg","jobs","nohup","基础入门/MIT-Missing-Semester/版本控制(Git)"],"tags":[],"content":"当我们在学习这一门课程的时候，我们是否发现自己都在一个进程中进行工作，而有的时候我们需要更好的工作，就需要对多个命令和进程之间进行协调\n在这一节中我们将学习一些改善我们工作流与体验的操作思想\n进程控制\n某些情况下我们需要中断正在执行的任务，比如当find在递归搜索一个非常大的目录的时候，大多数情况下，我们都可以使用 Ctrl-c 来停止命令的执行\n但是在有的时候，会无法结束进程，这需要我们去深入探讨其底层原理\n结束进程\n我们的shell在结束一个进程的时候，通常都是发送一个信号来 “通知” 进程结束，这个进程接受到这个信号后会做出一系列反应。就这一点而言，信号是一直 软件中断\n在上面的例子中，我们按下 Ctrl-C 时候，shell会发送一个SIGINT信号到进程\n当我们知道了进程信号，也就有规避信号的方法\n\n这个systest.py 接收 SIGINT 但没有终止程序\n#!/usr/bin/env python\nimport signal, time\n \ndef handler(signum, time):\n    print(&quot;\\nI got a SIGINT, but I am not stopping&quot;)\n \nsignal.signal(signal.SIGINT, handler)\ni = 0\nwhile True:\n    time.sleep(.1)\n    print(&quot;\\r{}&quot;.format(i), end=&quot;&quot;)\n    i += 1\n而是在我们使用 Ctrl + \\ 发送另外的指令 SIGQUIT才将这个程序退出\n当然为了优雅的退出程序，我们有一个更通用的退出信号 SIGTERM ，而发出这个信号需要我们使用 kill 命令\n暂停和后台执行进程\n当然，信号可以做的事情不只是终止进程，也可以让进程做其他事情，比如当我们输入 Ctrl-Z 时候shell会发送 SIGSTOP 信号，这个信号会让进程暂停并退出到终端界面\n使用 fg 和 bg 指令可以恢复命令暂停的工作，他们分别表示在前台继续或在后台继续\njobs命令会列出当前终端会话中尚未完成的全部任务。我们可以使用pid来引用这些任务，(也可以使用pgrep命令找出pid)。更加符合直觉的是，你可以使用 % + 任务ID 来选取任务，而jobs会打印任务编号\n如果我们想直接让任务在后台运行，我们可以使用 &amp; 后缀，过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人(可以搭配重定向使用)\n同时，让已经在运行的程序转入后台,我们可以键入 Ctrl-Z 然后紧接着输入 bg 就可以,但是注意这时候我们关闭终端，所有的后台程序都会被终止，因为这些程序本质是终端的子程序\n我们可以使用 nohup 命令规避这一点\n对于更多的关于信号的说明可以查看Wikipedia的条目Unix信号\n终端多路复用\n课程上说使用 tmux 终端多路复用来提高效率，我的评价是不如使用Window Terminal分页\ntmux 的快捷键需要我们掌握，它们都是类似 &lt;C-b&gt; x 这样的组合，即需要先按下 Ctrl+b，松开后再按下 x。tmux 中对象的继承结构如下：\n\n\n会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口\n\ntmux 开始一个新的会话\ntmux new -s NAME 以指定名称开始一个新的会话\ntmux ls 列出当前所有会话\n在 tmux 中输入 &lt;C-b&gt; d ，将当前会话分离\ntmux a 重新连接最后一个会话。您也可以通过 -t 来指定具体的会话\n\n\n\n窗口 - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分\n\n&lt;C-b&gt; c 创建一个新的窗口，使用 &lt;C-d&gt; 关闭\n&lt;C-b&gt; N 跳转到第 N 个窗口，注意每个窗口都是有编号的\n&lt;C-b&gt; p 切换到前一个窗口\n&lt;C-b&gt; n 切换到下一个窗口\n&lt;C-b&gt; , 重命名当前窗口\n&lt;C-b&gt; w 列出当前所有窗口\n\n\n\n面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell\n\n&lt;C-b&gt; &quot; 水平分割\n&lt;C-b&gt; % 垂直分割\n&lt;C-b&gt; &lt;方向&gt; 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键\n&lt;C-b&gt; z 切换当前面板的缩放\n&lt;C-b&gt; [ 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分\n&lt;C-b&gt; &lt;空格&gt; 在不同的面板排布间切换\n\n\n\n\n只能说不愧是上古时代的产物，快捷键比我命多\n\n别名\n当我们有一些特别常用的命令但是又特别长的时候，会非常麻烦。因此，大多数终端都支持设置别名\nalias alias_name=&quot;command_to_alisa arg1 arg2&quot;\n\n\n                  \n                  Note\n                  \n                \n\n\n= 两边是没有空格的，因为alias 是一个命令，只一个参数\n\n\n\n配置文件\n在linux内，很多程序的配置都是以纯文本的被称为 点配置 的文件来完成，如 zsh -&gt; ~/.zshrc vim -&gt; ./vimrc\nshell的配置也是通过这些文件来完成的，在我们启动时候，我们的shell程序会读取很多加载文件来完成加载\n对 bash 而言，在大多数系统下我们可以编辑 .bashrc 或 .bash_profile 来进行配置，在这些文件中我们可以添加需要在启动时候执行的命令，例如别名或我们的环境变量\n实际上，很多程序都会要求你在 shell 的配置文件中包含一行类似 export PATH =&quot;$PATH:/path/to/progtam/bin&quot;的命令\n\n\n                  \n                  Important\n                  \n                \n\n\n这种做法在现代高度自动化的软件包管理器下，已经变得十分少见，当包管理器被打包时候，打包者会处理安装细节，在安装包的时候就将软件安装在shell的环境变量路径下并处理所有依赖问题\n\n\n\n\n配置文件应该如何管理呢？\n这里推荐一种高效且支持同步的方法: &quot;dotfiles&quot;管理\n具体做法是将所有的配置文件集中储存在一个 Git 仓库中，然后通过脚本编写的符号链接将他们部署到正确的位置\n为什么推荐这么做？\n主要是版本控制，同步，上云，自动化部署，这些都会在 Git 章节讲述\n\n这时有人可能会有疑惑，文字形式的配置文件，那里面应该放些什么？可以放什么？\n对于这种问题，一般而言，我们可以通过在线文档或帮助手册来获取，当然我们可以在网上搜索特定程序的文章，有些作者会分享他们的配置。当然作为c-v程序员最快速的方法是在 GitHub 上搜索别人的 dotfile 仓库并且获取，当然我不建议你直接复制别人的文件拿来用\n可移植性\n可见文件的一个常见痛点就是可能没办法在多设备上生效\n当然我们可以为部署脚本下功夫来完成我们的多配置，比如书写两份 .vimrc 分别对应 Linux 和 Windows\n我们的shell脚本就可以长这样\nif [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]\nthen {\n\tcommand\n} fi"},"基础入门/MIT-Missing-Semester/数据整理":{"slug":"基础入门/MIT-Missing-Semester/数据整理","filePath":"基础入门/MIT-Missing-Semester/数据整理.md","title":"数据整理","links":["Linux/常见命令/grep","Linux/常见命令/less","Linux/常见命令/sed","杂项/正则表达式","Linux/常见命令/sort","paste","awk"],"tags":[],"content":"当我们试图在输出很多的地方(系统日志,长文本)中找到自己需要的东西的时候,我们就需要进行数据的整理\n在之前的学习中,我们就已经接触过一些数据整理的基本技术.比如当我们使用 | 管道运算符向 grep 发送东西的时候,实际上就是一种数据整理,例如 history | grep &quot;grep&quot; 就是在我输入过的命令中寻找 grep\n如何进行数据整理\n在linux里进行数据整理最核心的就是grep类的命令\n例如当我们试图在系统日志中找到 imicola 使用 root 用命令做过多少坏事,那么我们就可以用\n$ journalctl | grep imicola\n来获取日志中所有含有 imicola 的条目,但是我们很快便会发现,这个玩意输出的东西也是杂乱无章\n我们就可以进一步使用\n$ journalctl | grep imicola | grep root\n来细分提取出来的 imicola 里的有root的情况\n\n在整理数据的时候,这种对数据流的细分整理就是一种数据整理的方法,我们去除冗杂的信息只提取我们需要的信息\n\n有时候为了我们更好的阅读,我们可以在数据整理后通过管道命令传入给less命令\n\nless命令会创建一个分页器,这个分页器可以支持我们翻页浏览.具体的操作在命令介绍页有讲述\n\n\n有的时候，为了我们更好的进行数据整理，我们还可以把输出的数据使用 &gt; .log 保存下来，使用 vim 或其他工具编辑整理分类\n\n数据剔除与编辑\n有的时候我们筛选出数据之后还会有很多数据冗杂，这时候我们可以使用 sed 工具来对文本进行编辑\n点这里 → 看sed命令详情\n但是使用sed命令难免会出现一个问题:正则表达式怎么写？ 所以就需要我们学习 正则表达式\n\n数据排序\n使用 sort 来对数据进行排序，其排序策略一般是字典序，使用sort -n可以按照数字出现的顺序进行排序，同时 uniq -c 会把连续出现的行折叠为一行并且使用出现次数作为前缀\n关于 sort 也有很多扩展的用法，会在单独页详细介绍\n\n数据的排版\n与整理对应的是数据的排版，好的数据排版能给人直观易懂的效果,在这里我们需要引入两个命令 paste 和 awk(这一章命令怎么这么多？)\npaste 是一种用于合并文件行或流输出行的，他可以将多个文件中的对应行拼接在一起，默认使用制表符分割\n\n使用管道输出时候需要使用 - 参数 即 ls | paste -\n\nawk 严格而言，是一种编程语言，只不过其特别擅长处理文本，我们今天在这里只浅浅了解一下基本用法\n例如，当我们输入 awk &#039;{print $2}&#039; 的时候，会将每行的第二个基于awk的分隔符(默认是空格)的区域打印出来，简单而言，就是会将每行第二个单词打印出来，这就表示在我们输入 awk &#039;{print $n}&#039; 的时候会将一行中的第 n 个数据筛选出来\n同时 awk 也接受正则表达式和一些操作\n| awk &#039;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }&#039; | wc -l\n\n这个指令可以列出开头为c,结尾为e的在输入中只出现过一次(需要搭配前面的去重排序)的单词\n\n同时 awk 作为一个编程语言，我们也可以写编程语句与脚本来匹配文本\nBEGIN { rows = 0 }\n$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ {rows += 1}\nEND { print rows }\nBEGIN 也是一种模式，它会匹配输入的开头（ END 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出"},"基础入门/MIT-Missing-Semester/版本控制(Git)":{"slug":"基础入门/MIT-Missing-Semester/版本控制(Git)","filePath":"基础入门/MIT-Missing-Semester/版本控制(Git).md","title":"版本控制(Git)","links":[],"tags":[],"content":"版本控制系统(VCSs)是一类用于追踪源代码(或其他文件、文件夹)改动的工具。顾名思义，这些工具可以帮助我们实行版本控制和管理代码/文件的修改历史\n即使我们一个人进行工作，git都可以帮我们建立快照，记录每个改动的目的，基于多分支并行开发。而在多人协作开发的时候，我们可以看见别人对项目的修改，也可以解决并行开发从而引起的冲突\n\n而在现代IDE的加持和git的现代化下，我们可以很轻易的了解到git储存库内的提交和修改，也可以用可视化的方式看到git并行开发的数据\n要学习git的基本命令与操作我会建议你去 git小游戏 上进行游玩学习，而这里面会教授大部分git命令，所以我们在此不多赘述"},"基础入门/MIT-Missing-Semester/编辑器(vim)":{"slug":"基础入门/MIT-Missing-Semester/编辑器(vim)","filePath":"基础入门/MIT-Missing-Semester/编辑器(vim).md","title":"编辑器(vim)","links":["Linux/折腾/neovim"],"tags":[],"content":"写作与写代码其实是两件非常不同的事情,当我们写代码的时候其实大部分时间都在思考代码结构与编写模块上,这使得我们经常在文件之间切换,浏览,阅读,编辑代码\n作为程序员选择一个适合自己的代码编辑器是十分重要的\n\n学习一个编辑器\n学习一个编辑器的过程包以下的步骤\n\n阅读教程并摸索\n坚持使用这个编辑器来完成自己的编辑工作\n折腾一些更高效率的操作(插件/按键重映射)\n\n学习编辑器后效率是曲线上升的,最开始可能会降低编写代码效率,但是随着使用时间的上升,大约在20小时之后,编写代码的效率便会回到原来的水平,然后效率会越用越高\n\nvim\nvim起源于vi编辑器,是互联网初期发展时期的产物,同时现在也在不断更新与完善,出现了许多基于vim的编辑器比如neovim这类功能更加强大的编辑器,但是底层思想依旧没有改变\nvim哲学\n课程上这一节叫做vim的哲学,但是我认为这个应该叫vim的优势区间\n在我们编程的时候我们会把大量的时间花费字啊阅读和编辑代码而不是从0 to 1 的书写上.所以,vim的多模态功能便起到了作用\n\nvim对插入文字以及操控文字有着不同的摸索\nvim是可编程的,其本身的一些接口都是一个程序语言\nvim几乎只使用纯粹的键盘来进行编辑工作,避免了使用鼠标来提升编辑速度\n\n\n编辑模式\n\n\n                  \n                  Tips\n                  \n                \n\n\n在vim的按键中,我们需要区分大小写即X与x的区别,前者需要我们键入 Shift + x 而后者只需要键入 x 即可\n同时还有约定俗称的表示方法如 &lt;C-v&gt; 表示 Ctrl + v,有时候也会写成 ^v\n以及&lt;CR&gt;表示回车\n\n\n\nvim的设计以大多数时间都在阅读,浏览和进行少量改动为基础,因此其具有多种操作模式\n\n正常模式: 在文件中四处移动光标进行修改\n插入模式: 插入文本\n替换模式: 替换文本\n可视化模式(又可以细分为一般,行,块模式): 选择文本块\n命令模式: 执行命令\n\n在不同模式中敲击键盘按键的意义也不一样,当你在插入模式中按下 x 时候会输入字母x,但是在正常模式下会删除当前光标所在的字母,而在可视化模式下会删除所选择的文本块\n在默认设置下,vim会在左下角显示当前的模式.启动时候的默认模式是正常模式.\n我们可以按下 ESC 从任何其他的模式退回到正常模式,而在正常模式下\n\n按 i 进入插入模式(insert)\n按 R 进入替换模式(Replace)\n按 v 进入(一般)可视化模式(view)\n\n按 V 进入(行)可视化模式\n按 C-v 进入(块)可视化模式\n\n\n按 : 进入命令模式\n\n基本操作\n插入文本\n在正常模式下按 i 进入插入模式,在轻度使用vim进行编辑工作的话,前面操作 + 会插入文本 + 会保存退出其实已经完全够用了把vim用成记事本\n缓存,标签页,窗口\nvim会维护一系列打开的文件,然后这些被打开的文件被称为”缓存”. 一个Vim会话包含一系列标签页,每个标签页包含一系列窗口(分隔窗口),窗口只是缓冲区的视图。一个缓存可以在多个窗口打开，甚至在同一个标签页内的多个窗口打开\nVim默认打开一个标签页,这个标签页也包含一个窗口\n命令行\n在正常模式下键入 : 进入命令模式,在键入 :后,光标会跳转到屏幕下方的命令行(当然如果你使用了插件或者Lazyvim可能会有所不同)\n一些常见的vim命令\n\n:q 退出(关闭窗口)(随机字符串生成器)\n:w 写入(保存)\n:wq 保存并退出\n:e{文件名称} 打开要编辑的文件\n:ls 显示打开的缓存\n:help {标题} 打开帮助文档\n\n:help :w 打开 :w命令的帮助文档\n:help w 打开 w 移动的帮助文档\n\n\n\nvim接口\nvim的设计思想表示vim的界面本身就是一个程序语言,键入操作(以及其助记名)本身就是命令.这些命令可以组合使用.这就使得移动和编辑变得更加高效,特别是一旦形成了肌肉记忆\n移动\n多数的时候在我们会在正常模式下,使用移动命令在缓存中进行移动.在Vim中移动也被称为”名称”,因为其指向文本块\n\n基本移动: hjkl (左上下右)\n词: w 下一个词, b 词初, e词尾\n行: 0 行初, ^ 第一个非空格字符, $ 行尾\n屏幕: H 屏幕首行, M 屏幕中间, L 屏幕底部\n翻页: &lt;C-u&gt; 上翻, &lt;C-d&gt; 下翻\n文件: gg 文件头, G文件尾\n行数: :{行数}&lt;CR&gt; 或者 {行数}G\n杂项: %(找到配对,比如找到括号对以及注释对之类的)\n查找: f{字符},t{字符},F{字符},T{字符}\n\n查找/到 → 向前/向后的字符\n,/; 用于导航匹配\n\n\n搜索: /{正则表达式}, n/N 用于导航匹配\n\n选择\n现在我们可以使用键盘代替我们的鼠标,我们可以采用编辑命令与移动命令来组合完成对文本的编辑,vim的编辑命令也被称为”动词”,因为动词可以施动与名词\n\ni 进入编辑模式\n\n对于操作/编辑文本可以使用退格键完成\n\n\nO/o 在 之上/之下 插入\nd{移动命令} 删除{移动命令}的行列\n\n例如 dw 删除词, d$ 删除到行尾 , d0 删除到行头\n\n\nc{移动命令} 改变{移动命令}\n\n等价与d{移动命令}后加i\n例如,cw 等价于 dwi\n\n\nx 删除字符 (等价于 dl)\ns 替换字符 (等价于 xi)\n可视化模式 + 操作\n\n选择文字, d 删除 或 c 改变\n\n\nu 撤销 , &lt;C-r&gt; 回撤\ny 复制\np 粘贴\n还有一些不在此处列出\n\n计数\n我们可以使用一些数字来结合名词或者动词\n\n3w 向后移动三个词\n5j 向下移动5行\n7dw 删除7个词\n\n修饰语\n你可以使用修饰语来改变”名词”的意义,修饰语有 i 表示在内部, a 表示周围\n\nci( 改变当前括号内的内容\nci[ 改变当前方括号的内容\nda&#039; 删除一个单引号字符串,包括周围的单引号\n"},"基础入门/MIT-Missing-Semester/调试以及性能分析":{"slug":"基础入门/MIT-Missing-Semester/调试以及性能分析","filePath":"基础入门/MIT-Missing-Semester/调试以及性能分析.md","title":"调试以及性能分析","links":[],"tags":[],"content":""},"基础入门/一些知识/开源":{"slug":"基础入门/一些知识/开源","filePath":"基础入门/一些知识/开源.md","title":"开源","links":[],"tags":[],"content":"开源是什么\n开源顾名思义就是开放源代码的意思，开源社区以及开源项目已经构成现代互联网非常重要的基石，很多项目都会使用开源项目甚至是以开源项目为基础构建的\n为什么要开源"},"基础入门/复变函数/未命名":{"slug":"基础入门/复变函数/未命名","filePath":"基础入门/复变函数/未命名.md","title":"未命名","links":[],"tags":[],"content":""},"基础入门/数据库系统/SQL/1.SELECT":{"slug":"基础入门/数据库系统/SQL/1.SELECT","filePath":"基础入门/数据库系统/SQL/1.SELECT.md","title":"1.SELECT","links":["基础入门/MIT-Missing-Semester/shell工具与脚本"],"tags":[],"content":"SELECT\nSELECT 是SQL查询中核心的语句,你可以用SELECT来查询表中的元素,例如,我们需要查询 dvdrental 数据库的 actor 表中的语句所有内容,我们可以使用\nSELECT * FROM actor;\n当然如果我们需要找到所有actor的id的话,我们可以用\nSELECT id FROM actor;\n用 WHERE 关键字可以进行条件筛选,如可以\nSELECT name FROM actor WHERE name.id &gt; 10; \n这个语句就会将 id &gt; 10的actor的名字已经列出来\n对于一些更加深入的查询,比如从所有国家的数据中找出含有某一些字符的国家,我们可以使用 LIKE 关键字来进行查询\nSELECT name FROM actor WHERE name LIKE &#039;B%&#039; \n其中,%表示万用字符,可以匹配任意字符一次或多次,类似于shell的通配\n类似的还有_字符,表示匹配一个任意字符\n上面的表示从name中找到以B开头的演员的名称,同时,%也可以出现在任意位置\n\n\n                  \n                  小技巧 \n                  \n                \n\n\n使用 || 可以做到链接字符串的作用,如 LIKE || &#039;%&#039; || name || &#039;%&#039;就表示找到含有name的串\n\n\n\n集合运算 union | intersect | except\n并运算,交运算和差运算,这三个表示了各自的集合运算\n\n聚集元素\n\navg ：求平均数\ncount ：求出现总数\n\n我们可以用 count(distinct ID) distinct 是将相同的数值记为一个\n\n\n\n分组聚集\n我们可以用关键字 GROUP BY 来为具有某一个相同属性的组进行划分\n对于划分的子组，可以使用 HAVING 来筛选分组\n嵌套子查询"},"基础入门/数据库系统/SQL/2.CREATE":{"slug":"基础入门/数据库系统/SQL/2.CREATE","filePath":"基础入门/数据库系统/SQL/2.CREATE.md","title":"2.CREATE","links":[],"tags":[],"content":"在SQL中创建表格"},"基础入门/数据库系统/课上教学/0.数据库入门":{"slug":"基础入门/数据库系统/课上教学/0.数据库入门","filePath":"基础入门/数据库系统/课上教学/0.数据库入门.md","title":"0.数据库入门","links":[],"tags":[],"content":"基本属性\n\n学时：48 学分： 3\n无实验课\n\n\n主要认识内容\n\n数据库语言(SQL)\n数据库设计\n数据库实现和方案\n\n\n一些参考和学习方法\n\n《数据库系统原理与应用 —基于SQL Serve》清华大学出版社\n《数据库系统概论》 (第六版) 高等教育出版社\n\n我们需要什么软件知识？\n\n数据库软件基本都基于SQL语言\n\n\nMySQL\nSQL Server\nOracle Database\nMango\n"},"基础入门/数据库系统/课上教学/1.基础与数据":{"slug":"基础入门/数据库系统/课上教学/1.基础与数据","filePath":"基础入门/数据库系统/课上教学/1.基础与数据.md","title":"1.基础与数据","links":[],"tags":[],"content":"1.1数据\n数据与语义是复合的，语义是解释数据的重要因素\n数据也有其结构：\n逻辑结构表示数据之间的逻辑关系，可以通过下面方式展示\n\n表\n树\n图\n…\n\n在物理层面上数据结构是存储在计算机上的结构，此时我们可以称其为物理结构\n数据库的作用是 将现实世界所发生的事情记录到计算机内\n\n1.2数据库\n\n\n数据库(Datebase,DB) 是 长期 存储在计算机内，有组织的，可共享的大量数据集合\n\n\n数据库的特征\n\n数据按一定的数据模型组织，描述和储存\n可共享\n冗余度较小\n数据独立性高\n易扩展\n\n\n\n数据库管理系统：数据库的大型软件，用于创建，管理，编辑数据库\n\n\n1.3数据库管理系统\n数据管理的两个功能：\n\n数据定义功能\n\n提供数据定义语言(DDL)\n即数据定义\n\n\n数据操纵功能\n\n提供数据操纵语言(DML)\n即增删改查\n\n\n\n同时也提供数据库运行管理和数据库的建立和维护功能\n\n1.4数据库系统\n数据库系统(DBS)是由一个互相关联的数据的集合和一组用于访问这些数据的程序构成，DBS旨在提供一种方便高效的数据库存取信息的途径\n\n1.4.1数据库系统应用\n数据库系统规模庞大广泛运用在各种需要储存数据的场景中\n1.4.2数据库系统的目标\n在数据库系统前，人们主要使用文件处理系统来管理数据，但是文件管路系统没有统一标准，数据访问困难，数据类型不一致，并发访问困难等问题\n1.4.3 数据抽象\n数据库管理系统将数据库分为三个层次\n\n物理层\n\n描述数据实际上是如何存储的\n\n\n逻辑层\n\n描述数据与数据之间的关系\n由DBA使用\n\n\n视图层\n\n描述数据库的某个部分\n\n\n\n1.4.4 实例与模式\n数据库在特定时刻存储的信息的合集被称为数据库的一个 实例，数据库的总体设计被称为数据库的 模式\n1.4.5 数据模型\n\n\n                  \n                  Important\n                  \n                \n\n\n数据模型是一个描述数据，数据联系，数据语义及一致性约束的概念工具的集合\n\n\n\n数据模型的类型\n\n关系模型: 使用表的集合来表示数据和数据之间的关系\n实体-联系模型: 使用实体与实体之间的联系构成的\n基于对象数据模型\n\n面向对象数据模型\n对象-关系数据模型\n\n\n半结构化数据结构: 例子:xml\n\n关系模型中的列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIDstudent_nameageclass001a182002b191\n\n注意在上面的列表中 ID 一行就是数据库的语义\n\n1.4 数据库语言\n数据库系统提供数据定义语言和数据操纵语言来管理数据库中的数据\n\n数据库模式是通过一系列定义来说明的,这些定义由数据库定义语言来表达\n\n例如:\ncreate table instructor(\nID              char(5),\nname            varchar(20),\ndept_name       varchar(20),\nsalary          numeric(8,2),\n)\n存储在数据库中的数值必须满足某些一致性约束\n1.5 数据库设计\n在进行数据库设计的时候,我们会经历如下设计阶段\n\n需求分析\n选择数据模型\n概念设计阶段\n逻辑设计阶段\n物理设计阶段\n\n\n… 讲了一堆正确的废话(本科教学通病了属于是)\n\n实体联系模型: 模型使用一组基本称作实体的基本对象,以及这些对象之间的联系,其实数据库中的实体通过 属性 集合来描述\n规范化:\n\n规范化的目标:生成一个关系模式的集合,存储信息的时候没有不必要的冗余且又可以轻易地检索数据\n设计一种符合适当范式的数据,我们可以时候函数式依赖来查询\n\n\n怎么开始念PPT了\n\n\n先不听了,来讲讲真正有用的\n数据库这是一个概念,实现这些概念的软件例如 MySQL,PostgreSQL 是数据库管理系统,这些系统利用 服务(service) 来运行在服务器后台\n而真正进行操作这些服务的语言 SQL 则可以在数据库管理系统下的命令行客户端下进行编写和运行调试\n当然在我们实际开发过程中我们不会去使用命令行来输入输出数据,我们可以利用编程软件的库来对数据库来进行操作\n"},"基础入门/数据库系统/课上教学/2.关系模型的介绍":{"slug":"基础入门/数据库系统/课上教学/2.关系模型的介绍","filePath":"基础入门/数据库系统/课上教学/2.关系模型的介绍.md","title":"2.关系模型的介绍","links":[],"tags":[],"content":"关系数据库的结构\n对于单一的数据结构,我们称其为关系,显然在现实世界中实体与实体之间的各种联系表示\n数据的逻辑结构,我们可以用二维表来描述\n数据库模式\n\n属性: A_1,A_{2}\\cdots A_n\n关系模型: R = \\{A_1,A_{2}\\cdots A_n\\}\n关系模式表现了型的概念,其表示的表的框架; 关系则表现为值的概念,成为了关系实例\n一个关系模式下可以建立多个关系,例如在学生关系的关系模式下,可以为全校学生都建立关系表\n\n码"},"基础入门/数据结构/课上笔记/0.数据结构介绍与入门":{"slug":"基础入门/数据结构/课上笔记/0.数据结构介绍与入门","filePath":"基础入门/数据结构/课上笔记/0.数据结构介绍与入门.md","title":"0.数据结构介绍与入门","links":[],"tags":[],"content":"课程考核\n对于课程考核,本课程按照下面划分\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方式分数平时表现20%作业20%实验10%期末考试50%\n绪论\n数据结构研究什么?\n\n非数值计算问题的操作对象\n对象之间的关系\n在计算机中的表示和实现\n\n数据结构的用法\n\n通过预先分析问题来确定必须达到的 性能目标\n挑选出恰当的数据结构\n\n基本概念与术语\n数据结构:\n\n定义: 由某一数据结构的集合及该集合所有数据元素之间的关系构成\n\n数据结构的逻辑结构:\n\n数据的逻辑结构从逻辑关系上描述数据,只指向数据之间的逻辑关系\n可以看作是从具体问题中抽象出来的数学模型\n其可以分为: 线性结构,树状结构,图\n\n数据的存储结构\n从底层上而言,其储存结构可以分为顺序存储结构与链式存储结构\n\n\n                  \n                  Note\n                  \n                \n\n\n对于顺序存储结构而言,所有元素存放在一片连续的存储单元(内存),在逻辑上相邻的元素在计算机内存上仍然连续\n对于链式存储结构,元素可以存放在不连续的存储单元中,元素之间使用逻辑链接(指针),元素在内存上不一定是连续的\n\n\n\n抽象数据模型\n数据类型:\n\n定义:一组性质相同的值的集合,以及定义于这个值集合上的一组操作的总称\n例如:C语言中有如下数据类型\n\nchar int float double 等\n\n\n构造数据类型由 不同成员 构成\n基本的数据类型可以看作是计算机中已实现的数据类型\n\n抽象数据类型\n\n是指一个数学模型以及定义在这个数学模型上的一组操作\n特性\n\n抽象: 通过外部接口访问其功能\n封装: 将实现细节与外部特性分离\n\n\n\n一个简单的实例 三元组\ntemplate &lt;typename T1, typename T2, typename T3&gt;\nclass ppair\n{\nprivate:\npublic:\n    T1 _first;\n    T2 _second;\n    T3 _third;\n    ppair(const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)\n    {\n        _first = a;\n        _second = b;\n        _third = c;\n    }\n};\n算法与算法分析\n算法是为了解决某类问题而规定的一个有限长的操作序列,为了度量算法的效率,我们通常使用复杂度来评估\n时间复杂度\n一个算法的时间复杂度只和其问题的规模有关系,在计算时间复杂度的时候我们通常只关心规模最大的子问题,即对于O(F),F是一个多项式,我们只关心幂次最高的项并且忽略常数\n例如:\nO(42n^{2}+ 2\\log n +18079n) \\Longrightarrow O(n^{2})\n空间复杂度\n与时间复杂度类似,空间复杂度也是只关心最大规模子问题所占用的空间规模"},"基础入门/数据结构/课上笔记/1.线性结构":{"slug":"基础入门/数据结构/课上笔记/1.线性结构","filePath":"基础入门/数据结构/课上笔记/1.线性结构.md","title":"1.线性结构","links":[],"tags":[],"content":"1.1线性表\n给出 n 个数据元素的有限序列,记作 {a_1,a_{2}\\cdots a_n},则称:\n\na_1 为线性表中的元素\n\n特点:\n\n除第一个和最后一个元素外所有元素均有一个前驱和一个后继\n\n1.1.2 线性表的顺序表示和实现\n定义: 将线性表中的元素相继存放在一片连续的内存中\n特点: 可以利用一维数组描述存储结构,采用线性表的储存方式\n\n顺序结构的插入和删除操作时间复杂度均为O(n)\n\n1.1.3 线性表的链式表示和实现\n定义: 将线性表中的元素互相使用指针指向\n特点: 插入和删除更迅速\n\n链式结构的插入和删除操作时间复杂度均为O(1)\n"},"基础入门/数据结构/课上笔记/2.栈和队列":{"slug":"基础入门/数据结构/课上笔记/2.栈和队列","filePath":"基础入门/数据结构/课上笔记/2.栈和队列.md","title":"2.栈和队列","links":[],"tags":[],"content":""},"基础入门/概率论与数理统计/0.概率论":{"slug":"基础入门/概率论与数理统计/0.概率论","filePath":"基础入门/概率论与数理统计/0.概率论.md","title":"0.概率论","links":[],"tags":[],"content":"概率论入门\n\n\n                  \n                  Tip\n                  \n                \n\n\n现在给出概率论数学符号约定,我们使用P(A)表示事件A的概率,使用集合运算符号\\cap,\\cup表示事件的关系\n\n\n"},"基础入门/概率论与数理统计/1.随机事件和样本空间-and-频率与概率":{"slug":"基础入门/概率论与数理统计/1.随机事件和样本空间-and-频率与概率","filePath":"基础入门/概率论与数理统计/1.随机事件和样本空间 and 频率与概率.md","title":"1.随机事件和样本空间 and 频率与概率","links":[],"tags":[],"content":"1.1 概念\n我们研究随机事件的方式是 随机试验 ,随机试验应该满足以下三个条件\n\n大量可重复性\n结果不唯一\n不可预知性\n\n我们约定用E表示随机试验,将随机试验所有可能的结果构成构成的集合称为样本空间U,例如抛一次硬币的试验E_{1}的样本空间U = \\{H,T\\} 记为正反\n一些概念解释:\n\n随机事件:即样本空间的子集\n基本事件:单个样本点构成的事件\n事件发生: 事件A发生 \\iff A中有样本点出现\n\n1.2事件的运算\n事件的关系:\n\n包含   : A \\subset B 即事件A发生必然导致事件B发生\n和事件 : A \\cup B = \\{x | x \\in A \\text{ or } x \\in B\\}  即A与B至少有一个发生,也可以记为A + B\n交事件 : A \\cap B = \\{x | x \\in A \\text{ and } x \\in B\\} 即A与B同时发生,也记为AB\n\n当 AB = \\varnothing 时候,我们称A与B为互不相容(互斥)事件\n当 AB = \\varnothing \\text{ and } A+B = U 我们称为A,B互为对立事件,记 B = \\overline{A}\n\n\n差事件 : A - B = \\{x | x \\in A \\text{ but } x \\notin B \\} 有公式A - AB = A\\overline{B}\n\n事件的运算:\n\n交事件与并事件均满足交换律和结合律\n交事件与并事件满足结合率\n对偶率: \\overline{A \\cup B} = \\overline{A} \\cap \\overline{B} , \\overline{A \\cap B} = \\overline{A} \\cup \\overline{B}\n\n1.3 频率与概率\n1.3.1频率\n对一个随机试验E,对事件A,在进行n次试验中事件A出现了n_{A}次,则我们称:\nf_{n}(A) = \\frac{n_{A}}{n}\n为A的频率\n性质:\n\n0 \\leq f_{n}(A) \\leq 1\nf_{n}(U) = 1\n若A_{1},A_{2} \\cdots A_{n} 两两互不相容,则有:f_{n}(A_{1}+A_{2}+ \\cdots A_{n}) = \\frac{n_{a_{1}} + n_{a_{2}} \\cdots + n_{a_{n}}}{n} = f_n(A_{1}) + f_{n}(A_{2})+\\cdots f_{n}(A_{n})\n\n1.3.2概率\n定义:对一个E,U,A ,约定 P(A) \\in \\mathbf{R} 满足:\n\nP(A) \\geq 0  非负\nP(U) = 1  规范\n若 A_{1},A_{2} \\cdots A_{n} 两两互不相容,有 P(A_{1}) + P(A_{2})+\\cdots +P(A_{n}) = P(A_{1}+A_{2} + \\cdots A_{n})\n\n性质:\n\nP(\\varnothing) = 0\n若 A_{1},A_{2} \\cdots A_{n} 两两互不相容,有 P(A_{1}) + P(A_{2})+\\cdots +P(A_{n}) = P(A_{1}+A_{2} + \\cdots A_{n})\n若 A \\subset B 则 P(B-A) = P(B) - P(A)\n\npoof : \\begin{align*}B &amp;= A \\cup (B - A) \\\\ P(B) &amp;= P(A+(B-A)) \\\\ &amp;= P(A) + P(B-A)\\end{align*}\n\n\n\\forall A,B\\quad P(B-A) = P(B - AB) = P(B) - P(AB)\nA \\subset U \\Rightarrow P(A) \\leq P(U) = 1\n\\forall A \\quad P(\\overline{A}) = 1 - P(A)\nP(A + B) = P(A) + P(B) - P(AB) 容斥原理\n"},"基础入门/概率论与数理统计/2.古典概型":{"slug":"基础入门/概率论与数理统计/2.古典概型","filePath":"基础入门/概率论与数理统计/2.古典概型.md","title":"2.古典概型","links":[],"tags":[],"content":"2.1 古典概型\n我们称古典概型 E 满足:\n\nU = \\{e_1,e_{2}\\cdots e_n\\}\nP(e_{1})=P(e_{2}) = \\cdots =  P(e_{n}) 即每个事件发生的概率相等\n\n对于事件 A 满足 A = \\{e_{i1},e_{i2}\\cdots e_{ik}\\} ,则 P(A) = P(e_{i1}) + P(e_{i2)}\\cdots +P(e_{nk}) = \\frac{k}{n}\n2.1.1 一些例子\n\n一个产品中,有a个正品和b个仿品,求连续抽2次抽到正品或者仿品的概率\n\nP(\\text{抽到正品}) = \\frac{C(a,2)}{C(a+b,2)}\r\nP(\\text{抽到仿品}) = \\frac{C(b,2)}{C(a+b,2)}\n\n"},"基础入门/概率论与数理统计/3.条件概率":{"slug":"基础入门/概率论与数理统计/3.条件概率","filePath":"基础入门/概率论与数理统计/3.条件概率.md","title":"3.条件概率","links":[],"tags":[],"content":"3.1条件概率\n\n引例: 在0到9任取一个数\n\n已知取得的数 k &gt; 4 ,求取得奇数的概率\n\n\n我们可以猜出: P(ans) = \\frac{3}{5}\n给出A,B两个事件,P(B) &gt; 0\n\n给出条件概率P(A|B)称为条件概率,其中B是先发生的概率,A是后发生的概率\n\n\n\n                  \n                  Important\n                  \n                \n\n\nP(A|B) = \\frac{P(AB)}{P(A)}\n\n\n\n性质:\n\nP(U|A) = 1\n设A_{1},A_{2}\\cdots A_{n} 两两互不相容,则\n\nP(A_{1}+A_{2}+\\cdots A_{n} | B) = P(A_{1}|B) + P(A_{2}|B) + \\cdots P(A_{n}|B)\n\nP(\\varnothing|B) = 0\nP(\\overline{A} | B) = 1-P(A|B)\nP(A_1+A_{2}|B)= P(A_{1}|B) + P(A_{2}|B) -P(A_{1}A_{2}|B)\n\n\n例: 在一个盒子中有8个红球,5个白球,求在第二次取到红球概率\n\n设A表示取到红球的概率，B表示第二次取到红球的概率，C表示第一次取到白球的概率\n则有\nP(B) =P(AB) + P(BC) =  P(A)P(B|A) + P(C)P(B|C) =\\frac{8}{13}\\cdot \\frac{7}{12} + \\frac{5}{13}\\cdot\\frac{8}{12}\n3.2 乘法定理\n\n设P(B) &gt; 0 有 P(AB) = P(B)P(A|B)\n设P(A) &gt; 0 有 P(AB) = P(A)P(B|A)\n设P(AB) &gt; 0 有 P(ABC) = P(A)P(B|A)P(C|AB)\n\n3.3 全概率公式与贝叶斯公式\n\n\n                  \n                  定义 \n                  \n                \n\n\n对E 与全样本空间U 有 [B_{1}\\cdots B_{n}]事件\n\n若对任意i,j有B_{i}B_{j} = \\varnothing\n\\bigcup_{i = 1}^{n}B_{i}= U\n\n\n\n\n我们称满足上面的所有B为U的 分割\n\n全概率公式\n定义:\n对于E,U 有 B_{1}\\cdots B_{n} 的一个分割 P(B_{i}) &gt; 0, A为任意事件,有\nP(A) = P(B_{1})P(A|B_{1}) + P(B_{2})P(A|B_{2}) + \\cdots + P(B_{n})P(A|B_{n})\n贝叶斯公式\n定义:\n对于E,U 有 B_{1}\\cdots B_{n} 的一个分割 P(B_{i}) &gt; 0, A为任意事件P(A) &gt; 0,有\nP(B_{i}|A) = \\frac{P(AB_{i})}{P(A)} = \\frac{P(B_i)P(A|B_{i})}{\\sum\\limits_{j=1}^{n}P(B_{j})P(A|B_{j})}"},"基础入门/概率论与数理统计/4.事件的独立性":{"slug":"基础入门/概率论与数理统计/4.事件的独立性","filePath":"基础入门/概率论与数理统计/4.事件的独立性.md","title":"4.事件的独立性","links":[],"tags":[],"content":"\n定义:\n若P(AB) = P(A)P(B)则称AB 相互独立\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n若{A,B},{\\overline{A}B},{A\\overline{B}},{\\overline{A}\\ \\overline{B}}中有一组互相独立,则其余三组都互相独立\n若P(A) = 1 \\text{ or } 0 ,则对任意B,AB独立\n若P(A) &gt; 0 \\text{ and }P(B) &gt; 0,则AB互不相容与AB独立不能同时出现\n\n\n\n\n三事件互相独立\n若ABC两两独立且P(ABC) = P(A)P(B)P(C) ,则称ABC相互独立\n性质\n\n若AB独立,则P(A) = P(A|B)\n\n"},"基础入门/概率论与数理统计/5.随机变量":{"slug":"基础入门/概率论与数理统计/5.随机变量","filePath":"基础入门/概率论与数理统计/5.随机变量.md","title":"5.随机变量","links":[],"tags":[],"content":"随机变量的概念\n\n定义1:有一个随机事件 E 与样本空间 U = \\{e\\} 若对 \\forall e \\in U 都有唯一实数x(e)与之对应,称 x(e) 为随机变量,简写为X\n我们规定符号随机变量:X,Y,Z,X_{i}\n\n实数规定为: x,y,z,x_{i}\n\n\n随机变量可以被如下划分\n\n\\text{随机变量}\r\n\\begin{cases}\r\n\\text{离散型} \\\\\r\n\\\\ \\\\\r\n\\text{非离散型}\r\n\\begin{cases}\r\n\\text{连续型} \\\\\r\n\\text{其他}\r\n\\end{cases}\r\n\\end{cases}\n离散型随机变量\n\n若随机变量X的取值是有限个或者无限可列个,则称X为离散型随机变量\n设X的所有可能取值为X = x_{k} \\ (k \\in \\mathbb{Z^+}) 且P\\{X = x_{k}\\} = P_{k} \\tag{1}\n我们称(1)式为X的分布律\n\n我们可以为分布律列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nXx_{1}x_2x_3Pp_1p_2p_2\n性质:\n\nP_{k}\\geq 0\n\\sum\\limits P_{k} = 1\n\n三种常见的离散型随机变量分布\n\nX \\sim (0,1)分布\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX01P1 - pp\n\n伯努利分布(二项分部) X \\sim B(n,p)\n\n伯努利实验: E的结果只有两种情况 A,\\overline{A}\r\nn重伯努利实验: 独立重复的进行 n 次实验,P(A) = p\n伯努利实验概率分布\nP\\{X = k\\} &amp;= C^{k}_{n}p^{k}(1-p)^{n-k} \r\n\\end{align*}$$\r\n\r\n3. 泊松分布 $X \\sim P(\\lambda)$ \r\n\r\n$P\\{X = k\\} = \\frac{\\lambda e^{-\\lambda}}{k!}\\ (\\lambda &gt; 0,k \\in \\mathbb{Z^+})$ \r\n\r\n\r\n### 泊松定理\r\n\r\n设 $X \\sim B(n,p)$,当 $n \\to \\infty,p \\to 0$ 时候,令 $np = \\lambda$,则有\nP{X = k} \\approx \\frac{\\lambda e^{-\\lambda}}{k!}\n"},"基础入门/概率论与数理统计/6.连续型随机变量":{"slug":"基础入门/概率论与数理统计/6.连续型随机变量","filePath":"基础入门/概率论与数理统计/6.连续型随机变量.md","title":"6.连续型随机变量","links":[],"tags":[],"content":"定义与概率密度\n对于随机变量X,若存在非负可积函数 f(x),\\, x\\in \\mathbb{R}\n对于任意a,b \\in \\mathbb{R},(a &lt; b),\\Longrightarrow P(a &lt; X \\leq b) = \\int_{a}^{b}f(x)\\mathrm{d}x\n称X为连续型变量， f(x) 称为X的概率密度函数，求在区间L,R 的概率就是求这个区间的积分\n性质：\n\nf(x) \\geq 0\n\\int^{\\infty}_{\\infty}f(x) = 1\n\n分布函数\n定义2：\n\n随机变量X(离散型，连续型)，x \\in \\mathbb{R}\n称F(x) = P\\{X \\leq x\\}为X的分布函数\n\n性质：\n\n\\forall a,b \\in \\mathbb{R},(a&lt;b) 则 P(a &lt; X \\leq b) = F(b) - F(a)\nF(x)单调不减\n0 \\leq F(x) \\leq 1\n\\underset{x\\to-\\infty}\\lim F(x) = 0,\\underset{x\\to\\infty}\\lim F(x) = 1\n分布函数是右连续的，即 \\underset{x\\to x^{+}}\\lim F(x) = F(x_0)\n\n对于离散型：\nF(x) = \\sum\\limits_{k = 0}^{n}p_{k}\n对于连续型：\nF(x) = \\int_{-\\infty}^{x} f(t)\\mathrm{d}t\n其中f(t)为密度函数\n同时，我们也有F&#039;(x) = f(x) 即分布函数求导可以得到密度函数，在连续性中 P\\{X = a\\} = 0\n均匀分布\n均匀分布X\\sim U(a,b)\n有密度函数f(x)\nf(x) = \r\n\\begin{cases}\r\n\\frac{1}{b-a} \\quad a&lt;x &lt;b \\\\\r\n \\\\\r\n0 \\qquad \\text{other}\r\n\\end{cases}\n分布函数F(x)\nF(x) = \\begin{cases}\r\n0 \\quad \\ \\quad x \\leq a \r\n\\\\\\\\\r\n\\frac{x-a}{b-a} \\quad a &lt; x &lt; b\r\n \\\\\\\\\r\n1 \\qquad\\ x \\geq b\r\n\\end{cases}\n指数分布\nX \\sim E(\\theta)：\n密度表达式\nf(x) = \\begin{cases}\r\n\\frac{1}{\\theta} e^{\\frac{-x}{\\theta}}\\  \\quad x &gt; 0 \\\\\r\n \\\\\r\n0 \\qquad \\quad x \\leq 0\r\n\\end{cases}\n分布函数\nF(x) = \\begin{cases}\r\n 1 - e^{\\frac{-x}{\\theta}}\\ \\quad x&gt; 0 \\\\\r\n \\\\\r\n0 \\qquad \\qquad x \\leq 0\r\n\\end{cases}\n\n会常在无记忆性的 “电子元器件使用” 中出现\n\n正态分布\nX \\sim N(\\mu,\\sigma^{2})\nf(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x - \\mu)^{2}}{2\\sigma}} \\quad x\\in \\mathbb{R}\n特别的，当X \\sim N(0,1)时候我们说概率分布服从标准正态分布"},"基础入门/概率论与数理统计/7.二维随机变量":{"slug":"基础入门/概率论与数理统计/7.二维随机变量","filePath":"基础入门/概率论与数理统计/7.二维随机变量.md","title":"7.二维随机变量","links":[],"tags":[],"content":"二维随机变量\n对一个随机事件 E,U = \\{e\\}\\quad \\forall e \\in U,X(e),Y(e) \\in \\mathbb{R}\n\n[!二维随机变量的分布函数]\r\n(X,Y)\\quad \\forall x,y \\in \\mathbb{R}\n有\nF(x,y) = P\\{(X \\leq x) \\cap (Y \\leq y)\\}\n\n我们不难看出，这个函数是在点(x,y)左下角的面积区域\n性质\n\n固定某一个变量时候，F(x,y)是单调不减的\n0 \\leq F(x,y) \\leq 1\n\\lim_{x,y\\to+\\infty}F(x,y) = 1\nF(-\\infty,-\\infty) = F(-\\infty,y) = F(x,-\\infty) = 0 \n\n二维离散型\n定义: 若(X,Y)的所有可能的取值是有限对或无限可列\n则称(X,Y)为二维离散型随机变量\n(X,Y) 的随机取值为 (x_{i},y_{j})\\quad (i,j) \\in S\\{\\mathbb{Z},\\mathbb{Z}\\}\n则我们称P\\{X=x_{i},Y = y_{j}\\} = p_{ij}"},"基础入门/计算机组成原理/指令系统":{"slug":"基础入门/计算机组成原理/指令系统","filePath":"基础入门/计算机组成原理/指令系统.md","title":"指令系统","links":[],"tags":[],"content":""},"基础入门/计算机组成原理/课上笔记/0.前言":{"slug":"基础入门/计算机组成原理/课上笔记/0.前言","filePath":"基础入门/计算机组成原理/课上笔记/0.前言.md","title":"0.前言","links":[],"tags":[],"content":"课程基本内容\n计算机主要原理主要是学习计算机各个内容之间的组织结构,功能,以及其互联的计算机系统\n成绩组成:\n\n10%平时作业 + 10%大作业\n10%实验\n10%学习表现\n60%期末考试\n3.5学分\n"},"基础入门/计算机组成原理/课上笔记/1.计算机系统概括":{"slug":"基础入门/计算机组成原理/课上笔记/1.计算机系统概括","filePath":"基础入门/计算机组成原理/课上笔记/1.计算机系统概括.md","title":"1.计算机系统概括","links":[],"tags":[],"content":"1.1 计算机软硬件概念\n计算机由软件和硬件构成\n\n硬件:计算机的实体\n软件:系统软件和应用软件\n\n1.2 计算机的”解题”过程\n计算机执行指令一般按照如下程序进行:\n\n高级语言编写\n编译器的编译\n机器码的转化\n计算机”解题”\n\n1.2.1 计算机系统的层次结构\n从汇编语言 到 机器语言过程中,汇编会在一个虚拟机器M_{2}中被机器识别转化为2进制的机器码,此时机器码(机器语言)会指示实际机器M_{1}进一步操作.从这种角度上看,汇编语言其实是一种助记语言,其直接对应机器语言\n在效率上,汇编的效率会比普通的程序更加底层从而能让程序员做出更效率的程序语句,在实际项目中如FFmpeg就使用了汇编加速了视频编码\n在机器语言之下还存在一个微指令系统m_{0},这个系统会读取机器码并且生成微指令进而让CPU进行\n1.3 计算机的基本组成\n1.3.1 冯诺依曼结构的特点\n\n计算机由五大部件构成\n指令和数据以同等地位存于存储器,按照地址寻址\n指令和数据用二进制表示\n指令由操作码和地址码组成\n存储程序\n以运算器为核心 目前向存储器倾斜\n\n冯式结构的组成\n\nIO(输入输出)\n控制器 CU(Conturol Unit)\n存储器\n运算器 ALU(Arithmetic Logic Unit)\n\n\nALU + CU 在现代被合称为CPU(Central Processing Unit)\n\n对于存储器而言,其可以分为主存和辅存,在现代CPU中我们将其称为内存和硬盘\n\n存储器的基本组成:\n\n\n存储体 : 表示存储单元,是基本存储的地方\nMAR    : 存储器地址寄存器\n\n反应存储单元的个数\n\n\nMDR    : 存储器数据寄存器\n\n反应存储字长\n\n\n\n\n控制器的基本组成\n\n\\text{完成一条指令}\r\n\\begin{cases}\r\n \\text{取指令} \\qquad \\quad PC \\\\\r\n\\text{分析指令} \\qquad IR     \\\\\r\n\\text{执行指令}\\qquad CU\r\n\\end{cases}\n\nProgramming Counter(PC) 程序计数器\n\n存放当前欲执行指令的地址,具有计数功能 (PC + 1) \\to PC\n\n\nInstruction Register(IR) 指令寄存器\n\n存放当前欲执行的指令\n\n\nCounter Unit(CU) 控制单元\n\n\nCPU进行一次一次取数指令进行的操作\n\n\n1.4 计算机的工作步骤\n1.4.1 上机前的准备\n在上机经常运算之前,我们一般都会进行如下工作\n\n确定数学原理\n选取数学方法\n编写程序\n\n\n好困,这种课真的有人能够坚持下去吗\n\n1.5 计算机硬件的主要技术指标\n\n机器字长: CPU 一次能够处理的位数\n运行速度\n\n主频\n吉普森法\nMIPS:每秒执行百万条指令\nCPI:执行一条指令所需要的时钟周期\nFLOPS:每秒浮点运算次数\n\n\n存储容量\n\n主存容量 RAM → 内存\n辅存容量 ROM → 硬盘\n\n\n"},"基础入门/计算机组成原理/课上笔记/2.计算机的发展及应用":{"slug":"基础入门/计算机组成原理/课上笔记/2.计算机的发展及应用","filePath":"基础入门/计算机组成原理/课上笔记/2.计算机的发展及应用.md","title":"2.计算机的发展及应用","links":[],"tags":[],"content":"\n这一节的内容不是很重要,我们选择跳过\n"},"基础入门/计算机组成原理/课上笔记/3.系统总线":{"slug":"基础入门/计算机组成原理/课上笔记/3.系统总线","filePath":"基础入门/计算机组成原理/课上笔记/3.系统总线.md","title":"3.系统总线","links":[],"tags":[],"content":"3.1总线的基本概念\n3.1.1什么是总线\n总线是链接各个部件的连接线,是各个介质共享的连接线\n3.1.2 总线的分类\n\n片内总线\n\n指芯片内部的总线\n\n系统总线\n\n系统总线是计算机各个部件之间的信息传输线\n\n数据总线: 双向 与机器字长,存储字长有关系\n地址总线: 单向 与储存地址,I/O地址有关\n控制总线: 有出有入\n\n\n通信总线\n\n用于 计算机系统之间 或 计算机系统与其他系统之间的通信\n\\text{传输方式}\r\n\\begin{cases}\r\n\\text{串行通信总线} \\\\\r\n\\text{并行通信总线}\r\n\\end{cases}\n1.3.3"},"基础入门/计算机组成原理/课上笔记/4.数据的表示":{"slug":"基础入门/计算机组成原理/课上笔记/4.数据的表示","filePath":"基础入门/计算机组成原理/课上笔记/4.数据的表示.md","title":"4.数据的表示","links":[],"tags":[],"content":""},"归档/大一下暑期计划/forACM":{"slug":"归档/大一下暑期计划/forACM","filePath":"归档/大一下暑期计划/forACM.md","title":"forACM","links":[],"tags":[],"content":"\n其实突然发现，对ACM竞赛式的学习内容其实是不成规律且离散的，但是可能就是这样的学习才是扩宽视野的一种方式吧\n训练计划\n牛客暑期多校联赛\n\n其实这玩意好像不是很重要(难度过大了)，但是毕竟都交钱了，还是得去打的\n\n\nAtcoder\n\n听lzy说Atc的题对比cf更注重算法实现与基础，而不是和cf一样都是猜猜题\n\n\ncodeforces\n\n打比赛还是要打的，主要是练习手感和写代码的感觉\n\n\n"},"归档/大一下暑期计划/forCS":{"slug":"归档/大一下暑期计划/forCS","filePath":"归档/大一下暑期计划/forCS.md","title":"forCS","links":["TODO/CS61系列/CS61A-计算机程序结构与解释"],"tags":[],"content":"课程学习\n\n MIT-Missing-Semester\n这是一个学习计算机工具与一些开发工具的课程，属于非系统性质的学习，尽可能需要一些Linux或shell命令行操作的储备知识\n\n建议用一段集中时间学习，大概安排15-18小时进行学习\n安排在第一周[7.16 - 7.20]\n课程安排\n\n 课程概览与 shell\n Shell 工具和脚本\n 编辑器 (Vim)\n 数据整理\n 命令行环境\n 版本控制(Git)\n 调试及性能分析\n 元编程\n 安全和密码学(可能会跳过这节内容)\n 大杂烩\n\n\n\n\n\n\n7.23记：这课花费时间比我预想的多一倍啊，真不知道是我效率低下还是课程内容太多了QAQ\n\n\n S61A: Structure and Interpretation of Computer Programs\n\n原本按照计划应该是学习MIT6100L,但是看了先导课后我认为其主要是为0基础人群设立的入门课程，一些东西也略显重复\n所以目前的计划是开始学习CS61系列课程，这个课程分为ABC三大门，属于长期课程，按照目前的效率可能学习CS61A需要花费1个月甚至两个月的时间\n所以我将CS61系统课程放入单独文件夹中，动态调整暑假学习的内容CS61A 计算机程序结构与解释\n\n\n"},"归档/大一下暑期计划/前言":{"slug":"归档/大一下暑期计划/前言","filePath":"归档/大一下暑期计划/前言.md","title":"前言","links":[],"tags":[],"content":"\n在期末考试绩点炸裂之后，对保研这一路径感觉顿时失去的前途的光芒，所以之后的课程学习都会更注重工程与实际而非理论学习\n其实有的时候会有纠结绩点与实际上我们需要学习的内容的冲突性，比如日语这在未来工作就业中几乎如同远牙一样几乎没有优势区间，除非留学，但是留学与在国外打工对经济实力的压力还是很大的。但就是一个在国内几乎无用的小语种学科有4.0的学分，\n国内的本科教育属于 教学任务驱动式 ,学生在完成60的及格分数，老师在完成自己的 教学指标 。而讽刺的事情是，保研或考研 是一个学生走向更好工作的门槛，但是这种门槛却设置在国内崩溃式的本科教育与其量化指标GPA上。而学习工业的，公司需要的，技术有时候却是脱离量化考核的\n"},"归档/大一下暑期计划/杂项":{"slug":"归档/大一下暑期计划/杂项","filePath":"归档/大一下暑期计划/杂项.md","title":"杂项","links":[],"tags":[],"content":"\n试着去github找到一个好看的框架然后搭建一个个人博客\n"},"归档/大一下期末/大学物理/动量定理与能量定理":{"slug":"归档/大一下期末/大学物理/动量定理与能量定理","filePath":"归档/大一下期末/大学物理/动量定理与能量定理.md","title":"动量定理与能量定理","links":[],"tags":[],"content":"冲量与力\n冲量是力在时间上的累计\n\\vec{I} = \\int F(t)\\,dt\n典型题目:\n\n已知F(t)求k秒内的冲量大小\n\nI = \\int_{0}^{k}F(t)\\,dt \n动量定理与动能定理\n动量定理:\n在合外力为0的情况下:\n有:\np = \\sum\\limits_{i=1}^{n}m_{i}v_{i} = k\n其中k为常矢量\n更一般的形式:\n\\begin{align*}\nm_{0}v_{0} &amp;= m_{0}v_{0}&#039; + m_{1}v_{1} \\tag{1}\\\\\nm_{0}v_{0} &amp;= (m_{0}+ m_{1})v_{\\text{共}}\\tag{2}\\\\\n\\end{align*}\n其中 (1) 表示弹性碰撞的情况 (2) 表示完全非弹性碰撞的情况\n\n有一个速度为v,质量为m的钢球,射向质量为m&#039;的靶,靶的中心有一个小孔,孔中有一个弹簧\n"},"归档/大一下期末/大学物理/运动学与动力学":{"slug":"归档/大一下期末/大学物理/运动学与动力学","filePath":"归档/大一下期末/大学物理/运动学与动力学.md","title":"运动学与动力学","links":[],"tags":[],"content":"直线运动\n给出位移-时间方程求速度方程与加速度方程\n\\begin{align*}\r\nx(t)&#039; &amp;=  v(t)\\\\\r\nv(t)&#039; &amp;= a(t)\r\n\\end{align*}\n给出运动方程，求轨迹方程\n\\begin{align*}\r\nr(\\vec{i},\\vec{j}) &amp;= P(t)\\vec{i} \\ + Q(t)\\vec{j}\\\\\r\n&amp;\\begin{cases}\r\nx &amp;= P(t)\\\\\r\ny &amp;= Q(t)\\\\\r\n\\end{cases}\r\n\\end{align*}\n将t代换为x(y) 即可联立解出轨迹方程\n给出加速度求运动方程\n给出a(t) 求 x(t)\n\\begin{align*}\r\na &amp;= \\frac{dv}{dt} = a(t)\\\\\r\ndv &amp;= a(t) \\, dt\\\\\r\nv &amp;= \\int a(t) \\, dt\\\\\r\n\\\\\r\nv &amp;= \\frac{dr}{dt} =v(t)\\\\\r\ndr &amp;= v(t) \\, dt\\\\\r\nr &amp;= \\int v(t) \\, dt \r\n\\end{align*}\n圆周运动\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n切向加速度a_t法向加速度a_nv : 线速度\\omega : 角速度s : 线量\\theta : 角量a_t=\\dfrac{\\mathbf{d}v}{\\mathbf{d}t}a_n=\\dfrac{v^{2}}{r}同时,对角量和线量可以通过v = \\omega r来联系同时有总加速度 a = \\sqrt{a_{n}^{2}+a_{t}^{2}}\n动力学\n牛顿定理:\r\n牛二书写注意\n\\begin{align*}\r\n\\vec{F} &amp;=  \\frac{d\\vec{P}}{dt}\\\\\r\n\\vec{F} &amp;= \\frac{m(d\\vec{v})}{dt}\\\\\r\n\\vec{F} &amp;= m\\vec{a}\r\n\\end{align*}\n运动学容易与动力学一起考\r\n如:\n\n给你一个力与时间的函数F(t)求x(t)\n\n\\begin{align*}\r\nF(t) &amp;= ma(t)\\\\\r\na(t) &amp;= \\frac{F(t)}{m}\\\\\r\na(t) &amp;= \\frac{dv}{dt} \\\\\r\nv(t) &amp;= \\int a(t)\\, dt \\\\\r\nv(t) &amp;= \\frac{dx}{dt}\\\\\r\nx(t) &amp;= \\int v(t)\\, dt\\\\\r\n\\end{align*}\n\n给定F(t)和v_0求t_{1} \\to t_{2}移动距离\n\n\\begin{align*}\r\n同上题求出 : \\quad &amp; v(t)\\\\\r\nx &amp;= \\int_{t_{1}}^{t_{2}} v(t)\\, dt\r\n\\end{align*}"},"归档/大一下期末/大学物理/默写公式":{"slug":"归档/大一下期末/大学物理/默写公式","filePath":"归档/大一下期末/大学物理/默写公式.md","title":"默写公式","links":[],"tags":[],"content":"\n波动方程的形式\n\n\n基本形式\n\ny(x,t) = A\\cos\\left[\\omega\\left(t \\mp + \\frac{x}{u} \\right)+ \\phi\\right]\n\n扩展为\n\ny(x,t) = A\\cos\\left[\\omega\\left(t \\ \\mp \\frac{x \\pm x_0}{u} \\right)+ \\phi\\right]\n\n一般形式\n\ny(x,t) = A\\cos (kx \\, \\mp \\omega t \\, + \\phi )\n其中:\n\n\\omega = \\frac{2\\pi}{T} 为角频率\nk = \\frac{2\\pi}{\\lambda} 为波数\n\n\n\n静电场的基本公式\n\n\n电势\n\n\\begin{align*}\n\\varphi &amp;=  k \\frac{Q}{r} \\\\\n\\\\\n\\text{其中:} k &amp;= \\frac{1}{4\\pi \\epsilon} \n\\end{align*}\n\n电势差\n\nU = \\varphi_{1} - \\varphi_{0}\n如果知道电场:\nU = \\int_{a}^{b} E \\ dl\n如果知道电场力做功\nU = \\frac{W}{q}\ntips:我们可以依据这些写出电场力做功的表现形式:\nW = \\int_{A}^{B} qE \\ \\mathbf{d}l\n\n电场强度E\n\nE = \\frac{F}{q_{0}}= \\frac{1}{4\\pi \\epsilon_{0}}\\ \\frac{Q}{r^{2}} \n或者更常见的\nE = \\frac{Q}{4\\pi r^{2} \\epsilon_{0}}\n\n\n高斯定理\n这里我们只讨论几种特殊的对称高斯面\n\n\n球面\n选取半径为 r 的球面作为高斯面有\n\n\\oint_{S}E\\ \\mathbf{d}S = \\frac{Q}{\\epsilon_{0}} \n环路积分可以化简为:\n4\\pi r^{2}E = \\frac{Q}{\\epsilon_{0}}\n\n圆柱面\n选取底面半径为 r 的圆柱面作为高斯面有\n\n\\oint_{S}E\\ \\mathbf{d}S = E \\ (2\\pi rL) \n其中 L 为长度,通常会与 q = \\lambda L 抵消(\\lambda为单位长度电荷)\n即:\n\\oint_{S}E\\ \\mathbf{d}S = 2\\pi rLE = \\frac{\\lambda L}{\\epsilon_{0}}\n\n平面对称电荷分布\n例如无限大均匀带电平面、均匀带电无限厚平板。此时选择圆柱形或长方体高斯面（高斯箱），使其穿过平面。\n\n\\oint_{S}E \\ \\mathbf{d}S = E \\ (2A)\nA 为高斯箱底面面积\n\n证明一个物体在做简谐运动:\n\n回复力与位移成正比且相反\n加速度与位移成正比且相反\n\n\n旋转矢量法\n\n\\omega \\Delta t = \\theta\n默认\\omega逆时针旋转\n沿着转动方向看x变换是正向还是负向\n旋转矢量要看单个质元的情况\n\n\n电容器并联:\nC = C_{1}+ C_2\n电容器串联:\n\\frac{1}{C} = \\frac{1}{C_{1}} + \\frac{1}{C_{2}}\n电容器电容量计算:\nC = \\frac{Q}{U} \n\n在一个封闭系统中,电荷量保持不变,则可以有\n\nU_{PQ} = \\frac{C_{整体}}{C_{PQ}} Q \n\n圆柱形电容器内部的电场强度 E 随着半径 r 的变化而变化，其表达式为：\nE(r) = \\frac{Q}{2\\pi \\epsilon \\epsilon_{0}R_{1}R_{2}} \\cdot  \\frac{R_{1}R_{2}}{r} = \\frac{V}{r\\ln{\\frac{R_{2}}{R_{1}}}}\n\nQ是电容器上储存的电荷量\n\\epsilon_0是真空介电常数 (8.85×10^{−12}{F}/{m})\n\\epsilon是电介质的相对介电常数\nV是电容器两端的电压\nR_1是内导体半径\nR_2是外导体半径\n当 r = R_1时候有V = V_{max}\n\n对于平行板电容器\nE = \\frac{V}{d}\n\nV是两端电压\nd是两端距离\n\n球形电容器\nE(r) = \\frac{Q}{4\\pi \\epsilon \\epsilon_{0}r^{2}} = \\frac{V}{r^{2}} \\cdot \\frac{R_{1}R_{2}}{R_{2}-R_{1}}\n\n当 r = R_1时候有V = V_{max}\n\n"},"归档/大一下期末/离散复习":{"slug":"归档/大一下期末/离散复习","filePath":"归档/大一下期末/离散复习.md","title":"离散复习","links":["归档/大一下期末/离散数学/集合","归档/大一下期末/离散数学/关系","归档/大一下期末/离散数学/映射","归档/大一下期末/离散数学/谓词逻辑与命题推理","归档/大一下期末/离散数学/近世代数","归档/大一下期末/离散数学/布尔逻辑与格","归档/大一下期末/离散数学/图论与树","归档/大一下期末/离散数学/数理逻辑"],"tags":[],"content":"Transclude of 集合\n\nTransclude of 关系\n\nTransclude of 映射\n\nTransclude of 谓词逻辑与命题推理\nTransclude of 近世代数\nTransclude of 布尔逻辑与格\n\nTransclude of 图论与树\n\nTransclude of 数理逻辑"},"归档/大一下期末/离散数学/关系":{"slug":"归档/大一下期末/离散数学/关系","filePath":"归档/大一下期末/离散数学/关系.md","title":"关系","links":[],"tags":[],"content":"\n\n                  \n                  写法习惯注意 \n                  \n                \n\n\n本文以下内容表示x,y的一个二元关系R的写法表现为(x,y) \\in R\r\n也有如同 xRy 表示二元关系的\n\n\n\n五种关系\n由集合S上的元素构成二元关系R\n\n自反\n\n定义：对于 \\forall x \\in S 都有 (x,x) \\in R\n证明思路：\n\n设x \\in S\n根据基于R的具体定义构造x与x的关系并且满足于R\n因此(x,x) \\in R\n\n\n\n\n对称\n\n定义：\\forall x,y \\in S,如果 (x,y) \\in R,那么(y,x) \\in R\n证明思路：\n\n设x，y \\in S且(x,y) \\in R\n根据(x,y) \\in R 与R的具体定义，推导出y与x也满足关系 R\n因此(y,x) \\in R\n\n\n\n\n传递\n\n定义：\\forall x,y,z \\in S,如果(x,y) \\in R且(y,z) \\in R 那么 (x,z) \\in R\n证明思路：\n\n设 x,y,z \\in S 且 (x,y) \\in R \\quad \\text{and}\\quad (y,z) \\in R\n根据R推导出x与z也满足关系\n因此(x,z) \\in R\n\n\n\n\n反对称\n\n定义：\\forall x,y \\in A 如果(x,y)\\in R且(y,x)\\in R 那么x = y\n证明思路：\n\n设x,y \\in S 且 (x,y) \\in R 且 (y,x) \\in R\n根据R推导出如果假设成立则必须有x = y\n因此 x = y,故R是反对称的\n\n\n\n\n\n等价类\n等价类代表某一特性在这个等价关系中是 等价的\r\n如在x \\equiv y \\ (\\mod 3)关系下有三个等价类：\r\n[0] = \\{x \\ | x \\mod 3 = 0,x \\in I\\}\r\n[1] = \\{x \\ | x \\mod 3 = 1,x \\in I\\}\r\n[2] = \\{x \\ | x \\mod 3 = 2,x \\in I\\}\n等价关系与偏序关系\n若一个二元关系R满足自反 对称 传递 则这个二元关系为等价关系\r\n若一个二元关系R满足自反 反对称 传递 则这个二元关系为偏序关系\n关系的运算\n关系的复合运算一般使用矩阵形式展开\nA_{ij} = \\begin{cases}\r\n1 &amp; (i,j) \\in R \\\\\r\n0 &amp; (i,j) \\notin R\r\n\\end{cases}\n\n复合关系 R \\circ S 则使用R矩阵与S矩阵进行矩阵乘法\n逆关系矩阵为原矩阵的转置\n"},"归档/大一下期末/离散数学/图论与树":{"slug":"归档/大一下期末/离散数学/图论与树","filePath":"归档/大一下期末/离散数学/图论与树.md","title":"图论与树","links":[],"tags":[],"content":"\n\n                  \n                  Tips\n                  \n                \n\n\n考虑历年题目，按重要程度书写\n\n\n\n最小生成树问题\n\n通常以一个带权无向图的形式出现（图可能代表城市、村庄、矿井采集点等）\n问题直接明了：“求总成本最低的补给线路”、“设计总造价最小的修路方案”、“计算最小成本”等。\n要求：不仅要算出最小的总权值，通常还需要画出或列出构成最小生成树的边集。\n\n算法：\n\n克鲁斯卡尔算法：按权值从小到大选择边，只要不形成回路就加入，直到链接完所有定点为止\nPrim算法：从一个顶点开始，每次选择连接已选顶点集和未选顶点集的权值最小的边\n一般而言选择第一种算法，更加直观清晰\n\n主要模型建模\n\n哈密顿回路/路径：\n\n场景：“圆桌会议”,“旅行商问题”\n问题：“能否安排座位使得相邻的人都能交谈？”,“能否找到一条路径访问所有点一次？”\n方法：将人/地点视为 顶点，将可以交流/连接的关系视为 边，问题转化为寻找一条经过所有顶点的回路。\n判断是否存在哈密顿回路方法：\n\n这是一个完全NP问题，我们可以依据下面一些条件初步判断\n\n若顶点数大于3：\n\nDirac定理：若每个顶点的度数 deg(v) \\geq \\frac{n}{2}则为哈密顿图\nOrc定理 ：若对两个不相邻的顶点u,v 有deg(v) + deg(u) \\geq n则是哈密顿图\n\n\n这是一个充分条件，有时候不满足上述两条也可能构成哈密顿图，需要自己再看看\n\n\n\n\n\n\n图的着色 (Graph Coloring)\n\n场景：“考试时间安排”、“会议安排”、“地图着色”。\n问题：“最少需要多少时间段才能考完所有课程？”\n方法：将课程/事件/国家视为顶点，如果两个课程有学生同时选修（即存在冲突），则在对应顶点间连一条边。问题转化为求该图的色数（最少需要多少种颜色给顶点着色，使得相邻顶点颜色不同）。\n\n这是一个著名的NP完全问题，在考试情景下不可能过分困难\n勇敢尝试\n\n\n\n\n匹配 (Matching)\n\n场景：“配对问题”、“任务分配”\n问题：“能否选出4组不同的配对，用完所有8种颜料？\n建模方法：将颜料/人员视为顶点，能互相搭配的关系视为边。问题转化为寻找图中的 完美匹配（一个覆盖所有顶点的边子集，且边与边之间不共享顶点）。\n\n完美匹配存在的性质\n\n当一个图的顶点数量|V|为偶数时候才有可能存在完美匹配\n最大匹配是指图中边数最多的匹配\n如果一个最大匹配包含了图中的所有顶点，那么它就是一个完美匹配\n如果一个图有偶数个顶点且存在哈密顿回路，那么这个图一定存在完美匹配\n\n\n\n\n\n\n\n理论证明：平面图与欧拉公式\n主要考虑\n\n欧拉公式：v - e + f = 2 \n其中，v:顶点数,e:边数, f:面数(不用忘记外部面)\n\n推论1： 对于v ≥ 3的简单连通平面图e ≤ 3v - 6\n推论2： 如果简单连通平面图中没有长度为3的回路（即没有三角形），e ≤ 2v - 4\n面度数推论 ：根据握手定理我们可以得出\\sum\\limits_{i=1}^{f}deg(F_{i}) = 2e\n即所有面的度数之和等于2倍的边数\n\n\n"},"归档/大一下期末/离散数学/布尔逻辑与格":{"slug":"归档/大一下期末/离散数学/布尔逻辑与格","filePath":"归档/大一下期末/离散数学/布尔逻辑与格.md","title":"布尔逻辑与格","links":[],"tags":[],"content":"本篇依旧是在代数系统(A,*)上进行讨论\n\n偏序集\n\n也就是判断给定(A,*)是不是偏序关系\n\n证明自反，反对称，传递\n\n\n\n\n格\n\n对任意两个元素a,b \\in A都存在最小上界(a \\lor b)和最大下界(a \\land b)\n\n\n有界格\n\n在格的基础上存在最大元素(记作1)和最小元素(记作0)\n\n\n有补格\n\n在有界格(A,*,0,1)基础上，对\\forall \\ a \\in A 有 \\exists \\ a&#039; \\in A \\Rightarrow a \\land a&#039; = 0 \\quad and \\quad a \\lor a&#039; = 1\n补元不一定是唯一的\n\n\n分配格\n\n满足以下两个等价的分配律中的任意一个\n\n\\forall a,b,c \\in A \\Longrightarrow a\\lor(b\\land c)=(a\\lor b)\\land(a\\lor c)\n\\forall a,b,c \\in A \\Longrightarrow a\\land(b\\lor c)=(a\\land b)\\lor(a\\land c)\n\n\n\n\n布尔代数\n\n(B,\\land,\\lor,&#039;,0,1)是一个布尔代数，如果它是一个有补分配格\n\n\n"},"归档/大一下期末/离散数学/数理逻辑":{"slug":"归档/大一下期末/离散数学/数理逻辑","filePath":"归档/大一下期末/离散数学/数理逻辑.md","title":"数理逻辑","links":[],"tags":[],"content":"\n数理逻辑只需要记住三个公式(会不会自求多福吧因为我也不会)\n一\n\nP \\to Q \\iff \\neg \\ P\\ \\lor\\ Q\n\n二\n\n\\begin{align*}\r\n\\neg(\\exists \\ x)P(x) \\iff&amp; (\\forall\\  x)\\neg P(x)\r\n\\\\\r\n\\neg (\\forall \\ x)P(x) \\iff&amp; (\\exists \\ x)\\neg P(x) \r\n\\end{align*}\n\n三 ：量词分配：\\forall只能对\\land分配 \\exists只能对\\lor分配\n\n\\begin{align*}\r\n\\forall x (P(x) \\land Q(x)) \\iff \\forall x P(x) \\land \\forall x Q(x) \\\\\r\n\\exists x (P(x) \\lor Q(x)) \\iff \\exists x P(x) \\lor \\exists x Q(x)\r\n\\end{align*}"},"归档/大一下期末/离散数学/映射":{"slug":"归档/大一下期末/离散数学/映射","filePath":"归档/大一下期末/离散数学/映射.md","title":"映射","links":[],"tags":[],"content":"单射与满射\n映射最重要的两个概念：单射，满射\r\n有一个映射 f 满足 X \\to Y\n\n对单射证明：\n\n\\forall x_1,x_{2}\\in A 如果 x_{1} \\ne x_{2} \\Longrightarrow f(x_{1}) \\ne f(x_{2}) 则f为单射\n\n\n对满射的证明：\n\n\\forall y \\in Y \\quad \\text{if} \\  \\exists x \\in X \\Longrightarrow f(x) = y 则 f 为满射\n\n\n对双射的证明：\n\n如果映射 f 同时满足单射和满射，则 f 为双射\n\n\n\n映射的复合\n我们可以将集合的复合看为函数的复合\n\n求映射的复合\n\n将两个映射看为函数复合\n\n\n\n\n事实上，我们可以完全等价 (f \\circ g)(x) \\iff f(g(x))\r\n在我们解决一些问题上也会应用这个概念\n\n\n已知 f : X\\to Y \\ , \\ g : Y\\to Z 且 g \\circ f 为满射，证明g为满射\n\n思路：\n\n\\forall z \\in Z 有 \\exists x \\in X使得 (g \\circ f)(x) = z\n(g \\circ f)(x) \\iff g(f(x))\n因为x \\in X且f : X\\to Y 则f(x) \\in y\n令f(x) = y_{0} 且g: Y \\to Z,则有g(y_{0}) \\in Z\n即证\n\n\n\n\n\n映射的逆\n映射存在逆的充要条件是映射是双射\n\n如何求逆？\n\n令f(x) = y 则 f^{-1}(y)就是将f(x) = y中x，y互换\n\n\n"},"归档/大一下期末/离散数学/谓词逻辑与命题推理":{"slug":"归档/大一下期末/离散数学/谓词逻辑与命题推理","filePath":"归档/大一下期末/离散数学/谓词逻辑与命题推理.md","title":"谓词逻辑与命题推理","links":[],"tags":[],"content":"谓词符号化\n一般而言这类题目不难，思路是设出R(x):x为xxx,S(x):x为xxx\r\n然后注意对\\forall,\\exists的使用\n\n谓词符号化：所有的人都是要死的，苏格拉底是人，所以苏格拉底是要死的。\n\n设M(x):x是人\n设R(x):x会死\n设s:s是苏格拉底\n有：因为(\\forall x)(M(x) \\to R(x)) \\land M(s)故R(s)\n\n\n谓词符号化:所有的大学生都会说英语，有一些大学生会说法语\n\n设E(x):x会说英语\n设F(x):x会说法语\n设S(x):x是大学生\n有1.(\\forall x)(S(x) \\to E(x)) 2.(\\exists x)(S(x) \\land F(x))\n注意，在使用\\exists时候，我们需要使用合取来表示含义而不是蕴含\n同时两个陈述并列的时候应该不要使用\\lor链接\n\n\n\n命题推理\n以题目形式表现\n\n证明下列推理形式的有效性:今天或者是晴天,或者会下雨。如果是晴天,我就会去打球;如果我去打球,那么我就不读书。所以如果我在读书,那么天就在下雨。\n\n命题符号化\n\n设p为今天是晴天\n设q为今天是雨天\n设b表示我去打球\n设r表示我在读书\n\n\n符号化有:\n\n\n\n\\begin{align*}\r\n&amp; p \\lor q \\, ,\\quad p \\to b \\, , \\quad b \\to \\neg r &amp;\\Rightarrow \\qquad r \\to q \\\\\r\n\\\\\r\n&amp; (1) \\quad r &amp;P(附加) \\\\\r\n&amp; (2) \\quad b \\to \\neg r &amp;P\\\\\r\n&amp; (3) \\quad \\neg b &amp;T(1)(2)I\\\\\r\n&amp; (4) \\quad p \\to b &amp;P\\\\\r\n&amp; (5) \\quad \\neg p &amp;T(3)(4)I\\\\\r\n&amp; (6) \\quad p \\lor q &amp;P\\\\\r\n&amp; (7) \\quad q &amp;T(5)(6)I\\\\\r\n&amp; (8) \\quad r \\to q &amp;CP\r\n\\end{align*}\n\n\n主要逻辑规则\n\n如果有p \\to q和p,则可以推出q\n如果有p \\to q和\\neg q,则可以推出\\neg p\n如果有p \\lor q和\\neg q 则可以推出p,反之亦然\n如果有p和q,则可以推出p \\land q ,反之亦然\n如果有p \\to q和q\\to r，则可以推出p \\to q\n如果有(p \\to q) \\land (r \\to s)和p \\lor r，则可以推出q \\land s\n\n\n\n反证法例子\n\n一个具体的例子:证明 p \\to q \\Rightarrow \\neg q \\to \\neg p\n\n\n\n\\begin{align*} \r\n&amp; (1) \\quad p \\to q &amp; P \\\\ &amp; (2) \\quad \\neg (\\neg q \\to \\neg p) &amp; P \\quad (\\text{反证假设}) \\\\ &amp; (3) \\quad \\neg q \\land \\neg (\\neg p) &amp; T(2) \\quad (\\text{由 } \\neg (A \\to B) \\equiv A \\land \\neg B \\text{}) \\\\ &amp; (4) \\quad \\neg q \\land p &amp; T(3) \\quad (\\text{由双重否定 } \\neg(\\neg p) \\equiv p \\text{}) \\\\ &amp; (5) \\quad p &amp; T(4) \\quad (\\text{由合取消除}) \\\\ &amp; (6) \\quad \\neg q &amp; T(4) \\quad (\\text{由合取消除}) \\\\ &amp; (7) \\quad q &amp; T(1)(5) \\quad (\\text{由 } p \\to q \\text{ 和 } p \\text{，通过肯定前件}) \\\\ &amp; (8) \\quad q \\land \\neg q &amp; T(6)(7) \\quad (\\text{由 } q \\text{ 和 } \\neg q \\text{，得到矛盾}) \\\\ &amp; (9) \\quad \\neg \\neg (\\neg q \\to \\neg p) &amp; IP(2-8) \\quad (\\text{由矛盾，推导出假设的否定}) \\\\ &amp; (10) \\quad \\neg q \\to \\neg p &amp; DN(9) \\quad (\\text{由双重否定，得到原结论}) \\end{align*} $$\r\n- 显然反证法没有CP好用"},"归档/大一下期末/离散数学/近世代数":{"slug":"归档/大一下期末/离散数学/近世代数","filePath":"归档/大一下期末/离散数学/近世代数.md","title":"近世代数","links":[],"tags":[],"content":"群\n一个代数系统通常包括一个集合A和一个关系* 记作(A,*)\n群\r\n\\begin{cases}\r\n半群\r\n\\begin{cases}\r\n封闭性 \\\\ 结合律\r\n\\end{cases}\r\n\\\\ \\\\ \\downarrow\\\\ \\\\\r\n幺半群 : \\exists \\ 单位元\r\n\\\\ \\\\ \\downarrow \\\\ \\\\\r\n对每个元素有逆元\r\n\\end{cases}\n当然还有阿贝尔群(群的基础上添加交换律)和循环群(有生成元)\n现在我们主要讲讲如何考虑单位元和逆元，封闭性和结合律的证明都是通过任取元算(\\forall x,y,z \\in A),通过*证明满足x*y \\in A和x*(y*z) = (x*y)*z即可\n\n单位元\n\n定义：\\exists e \\in A,使得\\forall a \\in A都有a*e = a且 e*a = a\n证明思路：\n\n猜测或找到一个候选的单位元e\n证明这个e确实在集合G中\n对\\forall a \\in A：\n\n证明 a*e = a\n证明 e*a = a\n\n\ntips: 如果运算是交换的，证明上述一个即可\n\n\n\n\n逆元\n\n定义：\\forall a \\in A 都 \\exists\\ a^{-1} \\in A使得 a*a^{-1} = e \\quad and \\quad a^{-1}*a = e\n证明思路\n\n任取a\\in A (\\forall a \\in A)\n找到或猜测a的候选逆元a^{-1}，这通常是基于运算的定义和单位元\n证明a^{-1} \\in G\n证明a*a^{-1} = e\n证明a^{-1}*a = e\n\n\n\n\n"},"归档/大一下期末/离散数学/集合":{"slug":"归档/大一下期末/离散数学/集合","filePath":"归档/大一下期末/离散数学/集合.md","title":"集合","links":[],"tags":[],"content":"\n给定两个集合A,B和全集S求：\n\n交集A \\cup B\n\nA与B的所有元素\n\n\n并集\n\nA与B中都有的元素\n\n\n差集A - B\n\n将A中元素减去B中存在的\n\n\n对称差A \\bigtriangleup B\n\nA \\bigtriangleup B = (A - B) \\cup (B-A)\n\n\nA的余集\n\n全集中非A的部分,即 S - A\n\n\n笛卡尔积A \\times B\n\nA \\times B = \\{(a,b)|a \\in A \\, , \\, b \\in B\\}\n最后形式上应该如\\{(a_{1},b_{1}),  (a_{1},b_{2}),(a_{1},b_{3}),(a_{2},b_{1}) \\cdots (a_{3},b_{3}) \\}\n笛卡尔积对交并差有结合律\n\n\n2^A 即A所有子集构成的集合 注意不要忘记\\varnothing和本身\n\n\n证明两个集合相等\n\n互为子集法\n例：集合A为偶数集合，集合B\\{x|x \\mod 2 = 0,x \\in Z \\}\n具体步骤\n\n任取元素 ： 设 x \\in A\n性质处理 ： 则 x 为偶数，即 \\exists k \\ , \\ x = 2k\n证明子集 ： 2k \\mod 2 = 0即x \\in B ,故A \\subseteq B\n反向证明 ： 设 y \\in B 有 y \\mod 2 = 0,即 y 为偶数，故 B \\subseteq A\n证明相等 ： 因为 A \\subseteq B 且 B \\subseteq A,故 A = B\n\n\n\n\n证明对称差满足结合率\n\n即证明 ： A \\bigtriangleup (B \\bigtriangleup C) = (A \\bigtriangleup B) \\bigtriangleup C\n证明思路：\n\nA \\bigtriangleup B = (A - B) \\cup (B - A)\n将上式左右打开即可证明\n\n\n\n\n容斥原理\n\n\\left|\\sum\\limits_{i=1}^{n}A_{i}\\right| = \\sum\\limits_{i=1}^{n}|A_{i}| - \\sum\\limits_{i=1}^{\\frac{n}{2}}|A_{2i+1}A_{2(i+1)}| + \\cdots (-1)^{n-1}\\left| \\bigcup_{i = 1}^{n}A_{i} \\right| \n\n\n"},"归档/大一下期末/高数复习":{"slug":"归档/大一下期末/高数复习","filePath":"归档/大一下期末/高数复习.md","title":"高数复习","links":["归档/大一下期末/高等数学/空间几何与解析几何","归档/大一下期末/高等数学/多元函数微分","归档/大一下期末/高等数学/重积分","归档/大一下期末/高等数学/曲线积分","归档/大一下期末/高等数学/无穷级数","归档/大一下期末/高等数学/微分方程"],"tags":[],"content":"Transclude of 空间几何与解析几何\n\nTransclude of 多元函数微分\n\nTransclude of 重积分\n\nTransclude of 曲线积分\n\nTransclude of 无穷级数\n\nTransclude of 微分方程"},"归档/大一下期末/高等数学/多元函数微分":{"slug":"归档/大一下期末/高等数学/多元函数微分","filePath":"归档/大一下期末/高等数学/多元函数微分.md","title":"多元函数微分","links":[],"tags":[],"content":"偏导数与全微分\n\n基本求偏导数\n\n \\frac{\\partial F(x,y)}{\\partial x} = \\mathrm{d}F_{x}\n即:将y看作常数对F中的x求导\n同理,对y求偏导就是将x看为常数\n\n\n复合函数求导\n\n链式法则\n可以画出z(u,v),u(x,y),v(x,y)中\\frac{\\partial z}{\\partial x},\\frac{\\partial z}{\\partial y}的变量依赖关系的关系图\n也可以直接写出\\frac{\\partial{z}}{\\partial{x}} = \\frac{\\partial{z}}{\\partial{u}} \\frac{\\partial{u}}{\\partial{x}} + \\frac{\\partial{z}}{\\partial{v}} \\frac{\\partial{v}}{\\partial{x}} 对\\frac{\\partial{z}}{\\partial{y}}也是一样的\n\n\n隐函数求导\n\n对隐函数F(x,y,z)有\n\\frac{\\partial{z}}{\\partial{x}} = - \\frac{F_{x}}{F_{z}}\n\\frac{\\partial{z}}{\\partial{y}} = -\\frac{F_{y}}{F_{z}}\n也可以两边同时对x或y求偏导\n\n\n全微分\n\n\\mathrm{d}z = \\left(\\frac{\\partial{z}}{\\partial{x}}\\mathrm{d}x \\  + \\frac{\\partial{z}}{\\partial{y}}\\mathrm{d}y \\right)\n\n\n\n方向导数与梯度\n\n梯度\n\n梯度向量是就是求所有变量对原函数的偏导然后放入到向量中\n对\\nabla f而言f(x,y,z), \\nabla f = \\left(\\frac{\\partial{f}}{\\partial{x}},\\frac{\\partial{f}}{\\partial{y}},\\frac{\\partial{f}}{\\partial{z}}\\right)\n\\nabla f(P_{0}) = \\left(\\frac{\\partial{f}}{\\partial{x}}(P_{0}),\\frac{\\partial{f}}{\\partial{y}}(P_{0}),\\frac{\\partial{f}}{\\partial{z}}(P_{0})\\right)\n\n\n方向导数\n\n\\frac{\\partial{f}}{\\partial{l}} = \\nabla f(P_{0}) \\cdot \\frac{\\vec{u}}{|u|}\n方向导数最大(变化率最大)时候\n\n方向为：\\nabla f(P_{0})\n最大值：|\\nabla f(P_{0})|\n\n\n方向导数最小(变化率最小)时候\n\n方向为：-\\nabla f(P_{0})\n最小值：-|\\nabla f(P_{0})|\n\n\n变化为0时候\n\n方向为：任意与-\\nabla f(P_{0})垂直的向量\n\n\n\n\n\n极值与最值\n\n无条件极值f(x,y)\n\n解方程组 \\begin{cases} \\frac{\\partial{f}}{\\partial{x}} = 0 \\\\ \\frac{\\partial{f}}{\\partial{y}} = 0 \\end{cases}\n一般而言上面方程组会解出一个(或多个)点A(x_{0},y_{0}) 称为驻点\n接下来需要我们求所有二阶偏导数\n\nf_{xx} = \\frac{\\partial^{2}{f}}{\\partial{x^{2}}} \\quad f_{yy}= \\frac{\\partial^{2}{f}}{\\partial{y^{2}}}  \\quad f_{xy} = \\frac{\\partial^{2}{f}}{\\partial{x}\\partial{y}}\n接下来计算黑塞矩阵的行列式D = \\begin{pmatrix}f_{xx}(x,y)  &amp; f_{xy}(x,y) \\\\ f_{xy}(x,y)  &amp;  f_{yy}(x,y) \\end{pmatrix}\n\n\n将每个驻点带入D有D|_{xy}\n\n如果D|_{xy} &gt; 0 且 f_{xx}(x_{0},y_{0}) &gt; 0 则函数有局部最小值\n如果D|_{xy} &gt; 0 且 f_{xx}(x_{0},y_{0}) &lt; 0 则函数有局部最大值\n如果D|_{xy} \\leq 0 则没有局部最值\n\n\n\n\n有条件的极值\n\n已知f(x,y,z)在约束条件\\omega(x,y,z) = a的极值\n构造拉格朗日方程 F(x,y,z,\\lambda) = f(x,y,z) + \\lambda(\\ \\omega(x,y,z) - a\\ )\n求解方程组\\begin{cases} \\frac{\\partial{f}}{\\partial{x}} = 0 \\\\ \\frac{\\partial{f}}{\\partial{y}} = 0 \\\\ \\frac{\\partial{f}}{\\partial{z}}= 0 \\\\ \\frac{\\partial{f}}{\\partial{\\lambda}} = 0 \\end{cases} \n解出方程组中 x,y,z 就可以得到极值点\n\n\n"},"归档/大一下期末/高等数学/微分方程":{"slug":"归档/大一下期末/高等数学/微分方程","filePath":"归档/大一下期末/高等数学/微分方程.md","title":"微分方程","links":[],"tags":[],"content":"一阶微分方程\n\n可分离变量的一阶微分方程\n\n可以直接分离变量，将x,y移动到等式左右两侧对两侧积分就行\n\n例：y&#039; = \\frac{y}{x}\n有\\frac{1}{y}dy = \\frac{1}{x}dx\n\n\n\n\n可降阶的微分方程\n\ny^{(n)} = f(x)\n直接逐项积分就可以\n\n\n一阶齐次线性微分方程\n\n一般形式y&#039; = f\\left(\\frac{x}{y}\\right)\n思路：换元u = \\frac{x}{y}\n则有y = ux \\Longrightarrow y&#039; = u + u&#039;x\n将y和y&#039;带入原方程u + u&#039;x = f(u)\n\n按分离变量法求出u的表达式\n代回y = ux即可\n\n\n\n\n一阶非齐次线性方程\n\n一般形式：y&#039;+ P(x)y = Q(x)\n\n求积分因子\\mu(x) = e^{\\int P(x) dx}\n通项公式：y = \\frac{1}{\\mu(x)}\\left(\\int\\mu(x)Q(x) dx + C\\right)\n\n\n\n\n\n全微分方程\n\n全微分方程一般形式\nP(x,y)dx + Q(x,y)dy = 0\n当\\frac{\\partial{Q}}{\\partial{x}} = \\frac{\\partial{P}}{\\partial{x}}时候满足一个存在一个U(x，y)为解\n求解思路\n\n先对P(x,y)关于x积分有：U(x,y) = \\int P(x,y)\\ dx + h(y) \\qquad (1)\n对U(x,y)求关于y的偏导\\frac{\\partial{U}}{\\partial{y}} =\\frac{\\partial}{\\partial{y}}\\left(\\int P(x,y)dx\\right)+ h&#039;(y)\n因为对U求对y偏导后必须等于Q(x,y),z则我们可以比较出h&#039;(y)的表达式\n对h’(y)积分得出h(y)\n代回(1)式就可以得出方程\n\n\n\n高阶微分方程\n\n高阶齐次方程\n\na_{n}y^{(n)} + a_{n-1}y^{(n-1)} + \\cdots + a_{1}y^{(1)} + a_{0} = 0\n\n求解思路\n写出特征方程：a_{n}r^{n} + a_{n-1}r^{n-1} + \\cdots a_{0}r^{0} = 0\n求出所有r\n根据r的结构写出通解\nr都不相同时候y = C_1e^{r_{1}x}+ C_{2}e^{r_{2}x} + \\cdots C_{n}e^{r_{n}x}\n存在k重根r_p，对这个k重根有C_{1}e^{r_{p}x} + C_2xe^{r_{p}x} + \\cdots C_{k}x^{k-1}e^{r_{p}x}\n存在复数根，对这个复数根a+bi 有e^{ax}(C_{1}\\cos(bx) + C_{2}\\sin(bx))\n\n\n\n\n高阶常系数非齐次线性方程\n\n一般形式(考纲)：a_{n}y^{(n)} + a_{n-1}y^{(n-1)} + \\cdots + a_{1}y^{(1)} + a_{0} = f(x)且f(x) = e^{\\lambda x}P_m(x)\n解题思路\n\n通解形式为y = y_{p} + y_{h}其中y_{p}是其齐次方程的通解，y_{h}为一个特解\n我们主要考虑y_{h}\n我们推测y_{h}(x) = e^{\\lambda x}Q_m(x)\n\n注意如果\\lambda为特征方程的根，则需要修正y_{h}(x) = x^{k}e^{\\lambda x}Q_m(x)\n\n\n其中Q_{m}(x)是形如Ax^{n} + Bx^{n-1} + \\cdots + Nx^{0}的多项式\n对y_{h}(x)求导一直求到n阶导\n将y_{h}^{(n)} \\cdots y代入原式子与P_{m}(x)比较解出A \\cdots N的值\n代入y_{h}即可\n\n\n\n\n"},"归档/大一下期末/高等数学/无穷级数":{"slug":"归档/大一下期末/高等数学/无穷级数","filePath":"归档/大一下期末/高等数学/无穷级数.md","title":"无穷级数","links":[],"tags":[],"content":"\n无穷级数判别\n\n正项级数 \\sum\\limits a_{n},\\sum\\limits b_{n}\n\n比值判别法\n设L = \\lim_{x\\to\\infty} \\frac{a_{n+1}}{a_{n}}\n\n若0 &lt; L &lt; 1则级数收敛\n若L &gt; 1则发散\n若L = 1则失效\n\n\n比较判断法\n\n设L = \\lim_{x\\to\\infty} \\frac{a_{n}}{b_{n}}\n\n如果L为有限正数则\\sum\\limits a_{n}与\\sum\\limits b_n敛散性质相同\n如果L \\to \\infty 且\\sum\\limits b_{n}发散则\\sum\\limits a_{n}发散\n如果L = 0且\\sum\\limits b_n收敛，则\\sum\\limits a_n收敛\n\n\n\n\n\n\n交错级数\n\n一般形式\\sum\\limits (-1)^{n} a_{n}\n莱布尼茨判别法\n\n\\lim_{x \\to \\infty} a_{n} = 0\na_{n-1} &lt; a_{n}\n\n\n满足上面两个则级数为收敛的\n\n\n绝对收敛\n\n当\\sum\\limits |a_{n}|收敛，则级数绝对收敛\n\n\n\n\n幂级数收敛域\n\n用比值判别法\n\nR = \\lim_{n \\to \\infty}\\left|\\frac{a_{n}}{a_{n + 1}}\\right|\nR即为收敛半径(-R,R)\n将两个端点代入看能否取值\n\n\n根值判别法\n\nR = \\lim_{n \\to \\infty} \\sqrt[n]{|a_n|}\nr = \\frac{1}{R}即为收敛半径(-r,r)\n将两个端点代入看能否取值\n\n\n\n\n展开为幂级数\n\n利用五个已知的常用展开式\ne^{x}= \\sum\\limits_{n = 0}^{\\infty} \\frac{x^{n}}{n!}\n\\frac{1}{1 - x} = \\sum\\limits_{n = 1}^{\\infty} x^{n}\\qquad ,x \\in (-1,1)\n\\frac{1}{1 + x} = \\sum\\limits_{n = 1}^{\\infty} (-1)^{n}x^{n}\\qquad ,x \\in (-1,1)\n\\ln(1 + x) = \\sum\\limits_{n = 1}^{\\infty} (-1)^{n - 1}\\frac{x^{n}}{n}\n\n\n傅立叶级数展开\n\n有一个f(x)以2\\pi为周期\n和函数S(x_{0}),其中有间断点x_{k}\n\n当x_{0} \\ne x_{k} 时 S(x_{0}) = f(x)\n当x_{0}= x_{k} 时 S(x_{0}) = \\frac{f(x_{0^{+}}) + f(x_{0^{-}})}{2}\n\n\n展开式a_{0} = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)dx\n\n\n"},"归档/大一下期末/高等数学/曲线积分":{"slug":"归档/大一下期末/高等数学/曲线积分","filePath":"归档/大一下期末/高等数学/曲线积分.md","title":"曲线积分","links":[],"tags":[],"content":"\n第一类曲线积分(对弧长的积分)\n\n一般形式\\int_{L}f(x,y) \\ ds\n第一步：参数化曲线L\n\n在直角坐标系下\n\n对平面曲线f(x,y)通常可以表示为x(t),y(t)，t \\in [t_{1},t_{2}]\n\n\n在极坐标系下\n\n我们可以先使用极坐标转换将L转换为极坐标下的方程R(\\rho,\\theta)，然后表示为\\rho = \\rho(\\theta)的形式\n\n\n参数化主要是将x,y都用t来表示，比如y = x^{2} + e^{x} 就可以令x = t,则y(t) = t^{2} + e^{t} \\ ,\\ x(t) = t\n\n\n微分元素ds\n\n在直角坐标系下ds = \\sqrt{(x&#039;(t))^2 + (y&#039;(t))^{2}} \\, dt\n在极坐标系下ds = \\sqrt{\\rho^{2}(\\theta) + (\\rho&#039;(\\theta))^{2}}\n\n\n被积函数变化\n\n将f(x,y) \\to f(x(t)\\ ,\\ y(t))\n极坐标系 f(x,y) \\to f(\\rho(\\theta)\\cos\\theta\\ ,\\ \\rho(\\theta)\\sin\\theta)\n\n\n总公式\n\n直角坐标系下\\int_{L}f(x,y) \\ ds = \\int_{t_{1}}^{t_{2}} f(\\, x(t)\\ ,\\ y(t)\\, )\\sqrt{(x&#039;(t))^{2} + (y&#039;(t))^{2}}\\ dt\n极坐标系下\\int_{L}f(x,y)\\ ds = \\int_{\\theta_{1}}^{\\theta_{2}} f(\\rho(\\theta)\\cos\\theta,\\rho(\\theta)\\sin\\theta)\\sqrt{\\rho^{2}{(\\theta)} + (\\rho&#039;(\\theta))^{2}}\\ d\\theta\n\n\n\n\n第二类曲线积分(对坐标的积分)\n\n一般形式 \\int_{L}P(x,y)\\ dx + Q(x,y)\\ dy\n\n参数化\n\n对平面曲线f(x,y)通常可以表示为x(t),y(t)，t \\in [t_{1},t_{2}]\n\n\n微元dx,dy\n\ndx = x&#039;(t)dt\\ ,\\ dy = y&#039;(t)dt\n\n\n\n\n总公式\n\n\\int_{L}P(x,y)\\ dx + Q(x,y)\\ dy = \\int_{t_{1}}^{t_{2}} \\left[P(x(t),y(t))x&#039;(t) + Q(x(t),y(t))y&#039;(t)\\right] \\ dt\n\n\n\n\n格林公式\n\n如果曲线正向(逆时针)则可以使用格林公式\n\\int_{L}P(x,y)dx + Q(x,y)dy = \\iint_{D}(\\frac{\\partial{Q}}{\\partial{x}} - \\frac{\\partial{P}}{\\partial{y}})dxdy\n如果不是闭合曲线，我们可以“造”一个曲线使其闭合\n\n例：正向曲线L = \\sin x , \\ x\\in [0,\\pi]\n我们可以添加一条与L曲线方向相同的曲线y = 0,\\ x\\in [0,\\pi]\n此时有\\int_{L_{0}}P(x,y)dx + Q(x,y)dy = \\int_{L}P(x,y)dx + Q(x,y)dy + \\int_{l}P(x,0) dx\n而第一个式子我们可以就用格林公式了\n\n\n格林公式有”洞”的情况\n\n我们对外部的线积分I_{0}使用正常的格林公式积分\n对内部的线积分I_{1}我们必须保证其与外线方向相反的方向来保证使用格林公式的方向性\n此时我们计算的积分I = I_{0} + I_{1}但由于I_{1}是顺时针的，所以用格林公式时候会改变符号\n即I = I_{1}-I_{0}\n\n\n\n\n路径无关条件\n\n若一个曲线积分\\int_{L}P(x,y)dx + Q(x,y)dy与路径无关则有\n\\frac{\\partial{Q}}{\\partial{x}} = \\frac{\\partial{P}}{\\partial{y}}\n\n\n"},"归档/大一下期末/高等数学/空间几何与解析几何":{"slug":"归档/大一下期末/高等数学/空间几何与解析几何","filePath":"归档/大一下期末/高等数学/空间几何与解析几何.md","title":"空间几何与解析几何","links":["/"],"tags":[],"content":"向量运算\n\n点乘\n\n\\vec{a} \\cdot \\vec{b} = |a||b|cos&lt;\\vec{a},\\vec{b}&gt;\n若表示为坐标形式可以有:a_{1}\\cdot b_{1} + a_{2} \\cdot b_{2} + a_{3} \\cdot b_{3}\n如果两个 非零向量 点乘为0,说明这两个向量垂直\n点乘求出的是一个数\n\n\n叉乘(向量积)\n\n有 \\mathrm{a} \\times \\mathrm{b} = \\begin{pmatrix}i &amp;j &amp;k \\\\ a_{1}&amp;a_{2}&amp;a_{3} \\\\ b_{1} &amp; b_{2} &amp;b_{3} \\end{pmatrix}\n按第一行展开即可得出结果向量 (n_{i},n_{j},n_{k})\n或者使用高中叉乘法直接求出 (n_{i},n_{j},n_{k}) 数值\n\n\n求投影\n\n标量投影\n\n\\text{comp}_{\\mathrm{b}}\\rm{a} = \\frac{a \\cdot b}{|b|}\n有时候也写成 \\text{prj}_{\\vec{b}}\\vec{a}\n\n\n向量投影\n\n\\text{proj}_{\\vec{b}}\\vec{a} = \\left(\\frac{a\\cdot b}{|b|^{2}}\\right)\\,b\n\\text{proj}_{\\vec{b}}\\vec{a} = \\left(\\frac{a\\cdot b}{|b|}\\right)\\, \\frac{b}{|b|}\n\n\n\n\n\n\n平面与直线方程\n\n求平面方程(点法式)\n\n平面方程一般形式\n\n点法式 ： A(x - x_{0}) + B(y - y_{0)}+ C(z - z_{0})\n\n(A,B,C)为平面法向量\n(x_{0},y_{0},z_{0})是平面上一个点\n\n\n\n\n求过三点的平面P_{1},P_{2},P_{3}\n\n构造不共线的两个向量：P_{1}P_{2} = (x_{2}-x_{1},y_{2}-y_{1},z_{2}-z_{1}) P_{2}P_{3} = (x_{3}-x_{2},y_{3}-y_{2},z_{3}-z_{2})\n计算法向量 \\vec{n} = P_{1}P_{2} \\cdot P_{2}P_{3}\n带入点法式\n\n\n求过某一点且垂直于某直线的平面\n\n垂直与直线 → 法向量与直线方向向量平行 → 法向量就是方向向量\n带入点法式\n\n\n求过一点且垂直于两平面的平面\n\n垂直两平面，可以找到两平面的法向量n_{1},n_{2}\n所求平面法向量就是 n = n_{1}\\times n_{2}\n带入点法式\n\n\n\n\n求直线方程\n\n直线方程一般形式\n\n对称式 \\frac{x-x_{0}}{A} = \\frac{y-y_{0}}{B} = \\frac{z - z_{0}}{C}\n\n(A,B,C)为直线方向向量\n(x_{0},y_{0},z_{0})为直线所过的一个点\n\n\n参数式：\\begin{cases} x = At + x_{0} \\\\ y=Bt+y_{0} \\\\ z=Ct+z_{0} \\end{cases}\n可以理解为\\frac{x-x_{0}}{A} = \\frac{y-y_{0}}{B} = \\frac{z - z_{0}}{C} = t 后拆开的三个式子,那互相转换也显而易见了\n\n\n过点两点的直线\n\nA = (x_{1},y_{1},z_{1})\\, , \\, B = (x_{2},y_{2},z_{2})\n求两直线方向向量 \\vec{n} = \\overrightarrow{AB}\n带入某一个点使用对称式\n\n\n求已知两平面的交线\n\n可以找到两平面的法向量n_{1},n_{2}\n直线方向向量 \\vec{n} = n_{1} \\times n_{2}\n联立两个平面\n令x = 0(或y = 0等手段)找出y，z\n则这个直线过(0,y,z)\n带入对称式\n\n\n\n\n求曲线的切线与法平面 ^2c491e\n\n已知曲面\\Omega(x,y,z) =  x(t),y(t),z(t),求在(x_{0},y_{0},z_{0})处的切线方程(法平面)\n\n令x(t) = x_{0}求出t_{0}\n求x&#039;(t_{0}),y&#039;(t_{0}),z&#039;(t_{0}),即切线方向向量(法向量)\n代回(x_{0},y_{0},z_{0})用对称式得出结果\n或用点法式求出法平面\n\n\n\n\n"},"归档/大一下期末/高等数学/重积分":{"slug":"归档/大一下期末/高等数学/重积分","filePath":"归档/大一下期末/高等数学/重积分.md","title":"重积分","links":[],"tags":[],"content":"二重积分\n\n直角坐标\n\n其重点在于将积分区域表示出来\n例：计算二重积分\\iint_D xy \\, dx\\,dy，其中D由直线y = 2,x = 2,y = 2x围成的有界闭区域。\n对积分区域D有\n此时我们可以将其看为x型(先y后x)的积分\n\\iint_Dxy\\,\\mathrm{d}x\\mathrm{d}y = \\int_{1}^{2}\\mathrm{d}x\\int_{2}^{2x}xy\\mathrm{d}y\n在积后一个积分的时候就将x看为常量对y积分即可\n\n\n极坐标\n\n利用极坐标变换：\\begin{cases} x = \\rho\\cos\\theta \\\\ y = \\rho\\sin\\theta \\end{cases}\n当被积函数中含有 x^{2} + y^{2} 这类式子时候或者积分区域是圆类时候可以使用极坐标变换\n极坐标变换注意\\mathrm{d}x\\mathrm{d}y要变为\\rho\\ \\mathrm{d}\\rho\\mathrm{d}\\theta\n设区域D: x^2 + y^2 \\leq 1，则积分\\iint_D (xy + 3)^2 \\, d\\sigma =\n\n利用极坐标变换有\n\\iint_{D}(\\rho^{2}\\cos\\theta\\sin\\theta + 3)^{2}\\rho\\ \\mathrm{d}\\rho\\mathrm{d}\\theta\n在圆中 \\theta \\in [0,2\\pi]\\quad \\rho \\in [0,r] r是圆半径\n有\\int_{0}^{1} d\\rho\\int_{0}^{2\\pi}(\\rho^{2}\\cos\\theta\\sin\\theta + 3)^{2}\\rho\\ \\mathrm{d}\\theta\nBYD好难算放弃了\n\n\n\n\n二重积分中值定理\n\n存在(x_{0},y_{0})\\in D有\\iint_Df(x,y)dxdy = f(x_{0},y_{0})\\cdot S\n其中S为D的面积\n\n\n对称性\n\n二重积分区域D如果关于某一个变量轴对称，若其被积函数关于另一个变量为奇函数，则二重积分为0\n\n例：积分关于x轴对称，且f(x,-y) = -f(x,y)则该积分为0\n\n\n如果为偶函数，则只需要计算一半的区域然后乘2,即2\\iint_{D^*}f(x,y)dxdy\n\n\n\n三重积分\n\n三重积分方法\n\n直角坐标计算法：先一后二与先二后一\n\n先一后二：即先计算一重积分，再计算二重积分\n常见形式 ：z = x^{2} + y^ {2} 与 z = a围的空间封闭区域\n\n将\\iiint_{\\Omega}f(x,y,z)\\ dxdydz 化为\\iint_{D}\\ dxdy\\int_{x^{2}+ y^{2}}^{a}f(x,y,z)\\ dz\nD为空间体在xOy平面上的投影\n\n\n先二后一：即先计算二重积分，再计算一重积分\n\n常见形式：当被积函数只有一个变量的时候，可以考虑后积这个变量。这样就可以化为：\n\\int_{z_{0}}^{z_{1}}f(z)\\ dz\\iint_{D}\\ dxdy =\\int_{z_{0}}^{z_{1}}f(z)\\cdot A \\ dz\n其中A一般是一个可以用z表示的沿着z变化的面积\n如上例：若f(x,y,z) = z ，则我们可以化为：\\int_{0}^{a} z \\cdot (\\pi z)\\ dz\n\n\n\n\n球面坐标法\n\n球面坐标转换：\n\\begin{cases} x = \\rho\\sin\\phi\\cos\\theta \\\\ y = \\rho\\sin\\phi\\sin\\theta \\\\ z = \\rho\\cos\\phi \\end{cases}\n微元变化：\\mathrm{d}V = \\rho^{2}\\sin\\phi\\ \\mathrm{d}\\phi\\mathrm{d}\\rho\\mathrm{d}\\theta\n\\rho的范围:从原点出发的射线穿过区域的起点和终点对应的\\rho值\n\n对于球体，通常是0到半径R;对于球壳，是内半径到外半径\n\n\n\\phi的范围:从正z轴开始，向下扫描区域所需的角度范围\n\\theta的范围:在xOy平面上投影区域所覆盖的水平角度范围\n\n\n三重积分对称性\n\n三重积分区域D如果关于某两个变量平面对称(如xOy)，若其被积函数关于另一个变量为奇函数(f(x,y,-z) = -f(x,y,z))，则三重积分为0\n\n\n\n\n"},"归档/大二上期末/复变函数/复变函数复习路线":{"slug":"归档/大二上期末/复变函数/复变函数复习路线","filePath":"归档/大二上期末/复变函数/复变函数复习路线.md","title":"复变函数复习路线","links":[],"tags":[],"content":"复变函数期末冲刺指南 (基于近三年真题分析)\n一、 试卷结构透视\n通过分析近三年的试卷，可以发现试卷结构极度稳定。如果你能熟练掌握以下7类计算题的解法，及格甚至高分都轻而易举。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n题号题型分值考察内容 (高频)稳定性一选择题20分映射性质(w=1/z)、奇点类型、收敛性判断、积分值为零的条件⭐⭐⭐⭐二填空题15-20分辐角主值、复数运算、收敛半径、留数计算、调和函数系数⭐⭐⭐⭐11计算题8-9分解析性与可导性判定 (C-R方程)⭐⭐⭐⭐⭐ (必考)12计算题8-9分非闭合路径积分 (参数方程法 或 牛顿-莱布尼茨公式)⭐⭐⭐⭐⭐ (必考)13计算题8-9分泰勒级数展开⭐⭐⭐⭐⭐ (必考)14计算题8-9分洛朗级数展开 + 奇点判别⭐⭐⭐⭐⭐ (必考)15计算题8-9分利用留数定理计算闭合回路积分⭐⭐⭐⭐⭐ (必考)16计算题8-9分傅里叶变换 (含 \\delta 函数)⭐⭐⭐⭐⭐ (必考)17计算题8-9分拉普拉斯变换解微分方程⭐⭐⭐⭐⭐ (必考)四证明题4-7分调和函数性质、柯西不等式/积分公式相关证明⭐⭐⭐\n二、 核心考点与复习路线\n第一阶段：必拿分的“七大计算题” (占卷面约60%分数)\n这部分是复习的重中之重，建议直接背诵解题步骤模板。\n1. 解析性与可导性 (对应第11题)\n\n考点：给定 f(z) = u(x,y) + iv(x,y)，判断哪里可导，哪里解析。\n核心公式：柯西-黎曼方程 (C-R方程)\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y}, \\quad \\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x}\n解题步骤：\n\n求偏导 u_x, u_y, v_x, v_y。\n令其满足 C-R 方程，解出 x, y 的关系。\n结论：在满足方程的点可导；如果这些点构成了区域（不仅仅是孤立点或线），则在区域内解析。通常题目结果往往是“仅在某些点可导，处处不解析”或“处处解析\n\n\n\n2. 路径积分计算 (对应第12题)\n\n考点：计算 \\int_C f(z) dz，注意 C 通常不是闭合的。\n解法判断：\n\n方法A (原函数法)：如果 f(z) 在包含 C 的单连通区域内解析，直接用 F(终点) - F(起点)。例如 \\int e^z dz。\n方法B (参数法)：如果 f(z) 含 \\bar{z}, \\text{Re}(z) 等不解析项，必须设 z(t) = x(t) + iy(t)，代入转化为 t 的定积分。\n\n\n\n3. 泰勒级数展开 (对应第13题)\n\n考点：在 z_0 处展开 f(z)。\n技巧：\n\n换元法：令 t = z - z_0，将 f(z) 变形为关于 t 的函数。\n常用公式：熟记 \\frac{1}{1-t} = \\sum t^n, e^t, \\sin t, \\cos t 的展开式。\n注意：一定要写出收敛半径或收敛域。\n\n\n\n4. 洛朗级数与奇点 (对应第14题)\n\n考点：在指定圆环域（如 0 &lt; |z| &lt; \\infty）展开，并判断 z=0 是什么奇点。\n核心逻辑：\n\n利用级数展开公式（如 \\sin \\frac{1}{z} = \\frac{1}{z} - \\frac{1}{3\\!z^3} + \\dots）。\n奇点判别：\n\n无负幂项 \\rightarrow 可去奇点。\n有限个负幂项 (最高为 1/z^m) \\rightarrow m 级极点。\n无穷多个负幂项 \\rightarrow 本性奇点。\n\n\n\n\n\n5. 留数定理求积分 (对应第15题)\n\n考点：\\oint_C f(z) dz，其中 C 内部包含若干奇点。\n步骤：\n\n找出 C 内部的所有奇点 z_k。\n计算每个奇点的留数 \\text{Res}[f(z), z_k]。\n\n一级极点：\\lim_{z\\to z_0} (z-z_0)f(z)。\n高阶极点：用导数公式。\n\n\n结果 = 2\\pi i \\sum \\text{Res}。\n\n\n\n6. 傅里叶变换 (对应第16题)\n\n考点：求 F(\\omega)，题目通常涉及 \\delta(t)。\n核心记忆：\n\n\\mathscr{F}[\\delta(t)] = 1 (或根据定义不同可能有常数差异，需看教材定义)。\n\\mathscr{F}[1] = 2\\pi\\delta(\\omega)。\n位移性质：\\delta(t-t_0) \\leftrightarrow e^{-i\\omega t_0}。\n线性性质。\n\n\n\n7. 拉普拉斯变换解ODE (对应第17题)\n\n考点：解 y&#039;&#039; + ay&#039; + by = f(t)，给定初值。\n步骤：\n\n两边取拉氏变换，利用 \\mathscr{L}[y&#039;] = sY - y(0), \\mathscr{L}[y&#039;&#039;] = s^2Y - sy(0) - y&#039;(0)。\n代入初值，解出 Y(s)。\n对 Y(s) 进行部分分式分解。\n取逆变换 \\mathscr{L}^{-1} 得到 y(t)。\n\n\n\n第二阶段：概念巩固 (选择填空)\n\n辐角主值：\\text{Arg}(z) 范围是 (-\\pi, \\pi]。注意象限，例如 z = 1+\\sqrt{3}i 在第一象限，角度 \\pi/3；z=-1-i 在第三象限，角度 -3\\pi/4。\n收敛半径 R：\n\n比值法 \\lim |c_n/c_{n+1}|。\n距离法：收敛半径 = 展开中心到最近奇点的距离（非常管用！）。\n\n\n映射 w=1/z：\n\n圆过原点 \\rightarrow 变为直线。\n圆不过原点 \\rightarrow 变为圆。\n直线过原点 \\rightarrow 变为直线。\n\n\n调和函数：已知 u 求 v。利用 dv = v_x dx + v_y dy = -u_y dx + u_x dy，然后积分。\n\n三、 考前预测与模拟建议\n2025年期末考题预测\n根据近三年趋势，今年的试卷极大概率依然是：\n\n选择/填空：会考一个 i 的高次幂或复数开方；会考一个收敛半径计算；会考一个简单的留数计算。\n大题11：给一个 x, y 的多项式函数，问哪里可导。\n大题12：考一条直线段或圆弧上的积分，函数可能是多项式或指数函数。\n大题13：泰勒展开，分母可能是 (z-a)(z-b) 形式，需要拆项。\n大题14：洛朗展开，重点复习 e^{1/z}, \\sin(1/z), \\cos(1/z) 这种类型，判断奇点。\n大题15：分母有高次幂的积分，例如 \\frac{1}{(z-1)^2(z-2)}，注意只计算圆内的奇点留数。\n大题16：含 \\delta 函数的傅里叶变换。\n大题17：二阶常系数微分方程，右边是 e^{at} 或 \\sin/ \\cos。\n\n学习建议\n\n刷真题：把这份文档里的三年真题的大题部分，盖住答案完完整整做一遍。这是最高效的。\n背公式：\n\nC-R方程。\n高阶极点留数公式：\\frac{1}{(m-1)\\!} \\lim_{z\\to z_0} \\frac{d^{m-1}}{dz^{m-1}} [(z-z_0)^m f(z)]。\n拉普拉斯变换的导数性质。\n\n\n注意书写规范：复变函数很多题目计算量不大，但逻辑要求严密（如“在…区域内解析”），步骤分很重要。\n"},"归档/大二上期末/复变函数/期末题归档":{"slug":"归档/大二上期末/复变函数/期末题归档","filePath":"归档/大二上期末/复变函数/期末题归档.md","title":"期末题归档","links":[],"tags":[],"content":"24-25\n一、选择题（本大题共5小题，每小题4分，总计20分）\n\n\n若z^2 = (\\bar{z})^2，则必有（ ）\r\nA. z=0\r\nB. \\text{Re}(z)=0\r\nC. \\text{Im}(z)=0\r\nD. \\text{Re}(z) \\cdot \\text{Im}(z)=0\n\n\n函数w=\\frac{1}{z}将z平面上的直线y=x变成w平面上的曲线（ ）\r\nA. u=-v\r\nB. u^4 + v^4 = 2\r\nC. u^2 + v^2 = 1\r\nD. u=v\n\n\n下列积分中，值不为零的是（ ）\r\nA. \\oint_{|z|=2} \\frac{1}{z-3} dz\r\nB. \\oint_{|z|=2} \\frac{1}{z^3} dz\r\nC. \\oint_{|z|=1} \\frac{1}{z^2 - 5z + 6} dz\r\nD. \\oint_{|z|=1} \\frac{\\sin z}{z^2} dz\n\n\nz=1是函数f(z)=\\frac{\\sin(\\pi z)}{(1-z)^2}的（ ）\r\nA. 可去奇点\r\nB. 一级极点\r\nC. 二级极点\r\nD. 三级极点\n\n\n级数\\sum_{n=1}^{\\infty} \\left[ \\frac{(-1)^n}{n} + \\frac{i}{n} \\right]的敛散性为（ ）\r\nA. 绝对收敛\r\nB. 条件收敛\r\nC. 发散\r\nD. 以上都不对\n\n\n二、填空题（本大题共5小题，每小题4分，总计20分）\n\n\n复数z=i^{50}+i^{49}，则其辐角主值为。\n\n\n设e^z = 1-i，则\\text{Im}(z)=。\n\n\n幂级数\\sum_{n=0}^{\\infty} 2^n z^{2n}的收敛半径R=。\n\n\nz=0是z-\\sin z的k级零点，则k=。\n\n\n\\text{Res}\\left[\\frac{e^z}{z^3}, 0\\right]=。\n\n\n三、计算与解答题（共7小题，每小题8分，总计56分）\n\n\n函数f(z)=2z+\\bar{z}在何处可导，何处解析？\n\n\n计算\\int_C (z-1) dz，其中C为|z|=1的上半部分逆时针方向。\n\n\n将函数f(z)=\\frac{1}{2+z}在z_0=3处展开成泰勒级数。\n\n\n将函数f(z)=\\frac{1-\\cos z}{z^5}在0&lt;|z|&lt;+\\infty内展开成洛朗级数，并判断f(z)在z=0处的奇点类型，若是极点，指出是几级极点。\n\n\n计算积分\\oint_C \\frac{z^6}{(z-1)^3(z-2)^4} dz（曲线C: |z|=3为正向圆周）。\n\n\n求函数F(w)=\\delta(w-1)的傅里叶逆变换。\n\n\n用拉普拉斯变换解微分方程的初值问题：\n\n\ny&#039;&#039; - y = e^{4t}, \\quad y(0) = y&#039;(0) = 0.\n四、证明题（本大题共1小题，计4分）\n证明：v是u的共轭调和函数时，uv也是调和函数。\n23-24\n一、选择题（本大题共5小题，每小题4分，总计20分）\n\n\n函数w=\\frac{2}{z}将z平面上的圆周x^2+y^2=2变成w平面上的曲线（ ）\r\nA. u=2\r\nB. u^2+v^2=2\r\nC. u^2+v^2=\\frac{1}{2}\r\nD. u=\\frac{1}{2}\n\n\n积分\\oint_{|z|=2} \\frac{1}{(z-1)(z-3)} dz的值为（圆周取正向）（ ）\r\nA. 0\r\nB. -\\pi i\r\nC. \\pi i\r\nD. 以上都不对\n\n\nz=0是函数f(z)=\\frac{1-\\cos z}{z^3}的（ ）\r\nA. 可去奇点\r\nB. 一级极点\r\nC. 二级极点\r\nD. 三级极点\n\n\n下列命题中，正确的是（ ）\r\nA. 设x, y为实数，则|\\cos(x+iy)| \\leq 1\r\nB. 若z_0是函数f(z)的奇点，则f(z)在点z_0不可导\r\nC. 若u, v在区域D内满足柯西-黎曼方程，则f(z)=u+iv在D内解析\r\nD. 若f(z)在区域D内解析，则\\overline{f(z)}在D内也解析\n\n\n级数\\sum_{n=0}^{\\infty} \\left[ \\frac{(-1)^n}{n} + \\frac{i}{n^2} \\right]的敛散性为（ ）\r\nA. 绝对收敛\r\nB. 条件收敛\r\nC. 发散\r\nD. 以上都不对\n\n\n二、填空题（本大题共5小题，每小题4分，总计20分）\n\n\n复数z=1+\\sqrt{3}i的辐角主值为__________。\n\n\n(-1)^i=__________。\n\n\n幂级数\\sum_{n=0}^{\\infty} c_n z^n在z=2处条件收敛，则其收敛半径R=__________。\n\n\n设函数f(z)=u+iv解析，4du = kxy^2 - x^3，则k=__________。\n\n\n\\text{Res}\\left[\\frac{1}{z^2(z-1)}, 0\\right]=__________。\n\n\n三、计算与解答题（共7小题，每小题8分，总计56分）\n\n\n函数f(z)=x^2+iy^2在何处可导，何处解析？\n\n\n计算\\int_C e^z dz，其中C为从原点到1+i的直线段。\n\n\n将函数f(z)=\\frac{1}{5-z}在z_0=3处展开成泰勒级数。\n\n\n将函数f(z)=z^2 \\sin \\frac{1}{z}在0&lt;|z|&lt;+\\infty内展开成Laurent级数，并判断f(z)在z=0处的奇点类型，若是极点，指出几级。\n\n\n计算积分\\oint_C \\frac{1}{(z-1)^3(z-2)^2(z-4)} dz（曲线C: |z|=3为正向圆周）。\n\n\n求函数f(t)=\\delta(t)+e^{it}的傅里叶变换。\n\n\n用拉普拉斯变换解微分方程的初值问题：\n\n\ny&#039;&#039;&#039; + 3y&#039;&#039; + 3y&#039; + y = 6e^{-t}, \\quad y(0) = y&#039;(0) = y&#039;&#039;(0) = 0\n四、证明题（本大题共1小题，计4分）\n\n设f(z)在|z|\\leq 1上解析，且在|z|=1上有|f(z)|\\leq 1，证明：|f&#039;&#039;(0)|\\leq 1。\n\n21-22\n\n\n函数 w = \\frac{1}{z} 将 z 平面上的圆周 x^2 + y^2 = 2 变成 w 平面上的曲线 （ ）\nA. u^2 + v^2 + 1 = 0\nB. u^2 + v^2 = 2\nC. u^2 + v^2 = \\frac{1}{2}\nD. u^2 + v^2 + v = 0\n\n\n积分 \\int_{|z|=5} \\frac{e^z}{z^{10}} dz 的值为 （ ）\nA. 0\nB. \\frac{2\\pi i}{9!}\nC. \\frac{2\\pi i}{10!}\nD. 以上都不对\n\n\nz=0 是函数 f(z) = \\frac{\\sin z}{z} 的 （ ）\nA. 可去奇点\nB. 一级极点\nC. 二级极点\nD. 三级极点\n\n\n级数 \\sum_{n=0}^{\\infty} c_n (z-i)^n 在 z=-2i 处收敛，则该级数在 z=2+3i 点 （ ）\nA. 条件收敛\nB. 发散\nC. 绝对收敛\nD. 不能确定\n\n\n设函数 f(z) = \\frac{e^z}{z^2 + 1}，则 \\text{Re } s[\\frac{e^z}{z^2 + 1}, i] = （ ）\nA. -\\frac{ie}{2}\nB. -\\frac{e}{2}\nC. \\frac{i}{2e}\nD. -\\frac{i}{2e}\n\n\n二、填空题（本大题共5小题，每小题3分，总计15分）\n\n\n复数 z = 5i 的辐角主值为 ____________。\n\n\n\\ln(-2) 的值为 ____________。\n\n\n计算积分 \\oint_{|z|=2} \\frac{1}{z^2} dz = ____________，其中曲线 |z|=2 为正向圆周。\n\n\n设函数 f(z) = u + iv 解析，且 u = x^2 - ky^2，则 k = ____________。\n\n\n设函数 f(z) = \\frac{z}{(z+1)(z+2)} 在 z_0 = 2 点展开成泰勒级数，则其收敛半径 R = ____________。\n\n\n三、计算与解答题（共7小题，每小题9分，总计63分）\n\n\n函数 f(z) = x^2 + iy 在何处可导，何处解析？\n\n\n计算 \\int_C z dz，其中 C 为从原点到 2+i 的直线段。\n\n\n将函数 f(z) = \\frac{1}{2-z} 在 z_0 = 1 处展开成泰勒级数，并指出收敛半径。\n\n\n将函数 f(z) = z^2 e^{\\frac{1}{z}} 在 0 &lt; |z| &lt; +\\infty 内展开成 Laurent 级数，并判断 f(z) 在 z=0 处的奇点类型，若是极点，指出几级。\n\n\n计算积分 \\oint_C \\frac{1}{(z-2i)^8 (z-1)^5 (z-4)} dz （曲线 C: |z|=3 为正向圆周）。\n\n\n求函数 f(t) = 3 + 2\\pi \\delta(t) 的傅里叶变换。\n\n\n用拉普拉斯变换解微分方程的初值问题：\ny&#039;&#039; - y = e^{3t}, \\quad y(0) = y&#039;(0) = 0.\n\n\n四、证明题（本大题共1小题，计7分）\n\n如果函数 f(z) 在区域 D 内解析，C 为 D 内的任一条正向简单闭曲线，C 的内部全含于 D，证明：对于 D 内但不在 C 上的任一点 z_0，下列等式成立\n\\oint_C \\frac{f&#039;(z)}{z - z_0} dz = \\oint_C \\frac{f(z)}{(z - z_0)^2} dz.\n\n"},"归档/大二上期末/数据结构/复习思路":{"slug":"归档/大二上期末/数据结构/复习思路","filePath":"归档/大二上期末/数据结构/复习思路.md","title":"复习思路","links":[],"tags":[],"content":""},"归档/大二上期末/数据结构/期末题归档":{"slug":"归档/大二上期末/数据结构/期末题归档","filePath":"归档/大二上期末/数据结构/期末题归档.md","title":"期末题归档","links":[],"tags":[],"content":"24 - 25\n一、选择题（在每个小题四个备选答案中选出一个正确答案）（本大题共10小题，每小题2分，总计20分）\n\n\n下面关于广义表的叙述中，不正确的是________。\r\nA) 广义表可以是一个多层次的结构\r\nB) 广义表至少有一个元素\r\nC) 广义表可以被其他广义表所共享\r\nD) 广义表可以是一个递归表\n\n\n以下数据结构中哪一个是线性结构？\r\nA) 有向图\r\nB) 栈\r\nC) 二叉树\r\nD) B树\n\n\n字符 A、B、C、D 依次进入一个栈，按出栈的先后顺序组成不同的字符串，至多可以组成________个不同的字符串。\r\nA) 15\r\nB) 16\r\nC) 14\r\nD) 21\n\n\n对线性表，在下列哪种情况下应当采用链表表示？\r\nA) 经常需要随机地存取元素\r\nB) 经常需要进行插入和删除操作\r\nC) 表中元素需要占据一片连续的存储空间\r\nD) 表中元素的个数不变\n\n\n为解决计算机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是________。\r\nA) 栈\r\nB) 队列\r\nC) 树\r\nD) 图\n\n\n栈和队列的共同点是________。\r\nA) 都是先进先出\r\nB) 都是先进后出\r\nC) 只允许在端点处插入和删除元素\r\nD) 没有共同点\n\n\n设有一个二维数组A[m][n]，假设A[0][0]存放位置在600₍₁₀₎，A[3][3]存放位置在678₍₁₀₎，每个元素占一个空间，问A[2][3]₍₁₀₎存放在什么位置？（脚注₍₁₀₎表示用10进制表示，m&gt;3）\r\nA) 658\r\nB) 648\r\nC) 633\r\nD) 653\n\n\n下列关于数据结构的叙述中，哪一个是正确的？\r\nA) 数组是不同类型值的集合\r\nB) 线性表的链式存储结构优于线性存储结构\r\nC) 树是一种线性结构\r\nD) 用一维数组存储一棵完全二叉树是有效的存储方法\n\n\n已知串 S=‘aaab’，其 Next 数组值为________。\r\nA) 0123\r\nB) 1123\r\nC) 1231\r\nD) 1211\n\n\n下面关于串的叙述中，哪一个是不正确的？\r\nA) 串是字符的有限序列\r\nB) 空串是由空格构成的串\r\nC) 模式匹配是串的一种重要运算\r\nD) 串既可以采用顺序存储，也可以采用链式存储\n\n\n\n二、填空题（本大题共10小题，每小题2分，总计20分）\n\n\n数据结构被形式地定义为 (D, S)，其中 D 是数据元素的有限集合，S 是 D 上________的有限集合。\n\n\n邻接矩阵的存储空间大小与图的________有关。\n\n\n________是被限定为只能在表的一端进行插入操作，在表的另一端进行删除操作的线性表。\n\n\n设有一稀疏图 G，则 G 采用________存储方式较省空间。\n\n\n如果 n 个顶点的图是一个环，则它有________棵生成树。\n\n\n若串 S=‘computer’，其子串的数目是________。\n\n\n对于 n 个记录的集合进行冒泡排序，在最坏的情况下的时间复杂度是________。\n\n\n已知广义表 L=((x, y, z), a, (u, t, w))，则 L 的深度为________。\n\n\n一棵深度为 6 的满二叉树有________个分支结点。\n\n\n一棵具有 257 个结点的完全二叉树，它的深度为________。\n\n\n\n三、算法应用（本大题共4小题，第1~3小题每小题8分，第4小题16分，总计40分）\n\n1. 有向带权图问题（ACM式Input格式）\n有向带权图如下：\n6 8\r\n0 2 10\r\n0 5 100\r\n0 4 30\r\n1 2 5\r\n2 3 50\r\n3 5 10\r\n4 3 20\r\n4 5 60\n\n题目描述：\n(1) 以顶点0为出发点，分别写出一条深度优先遍历序列和一条广度优先遍历序列；\n(2) 填表格展示应用迪杰斯特拉算法求从顶点0到其余各点的最短路径的过程。\n\n2. 哈希表问题\n将关键字序列 {7, 8, 11, 18, 9, 14, 30} 散列存储到哈希表中，其存储空间是一个大小为10、下标从0开始的一维数组，哈希函数为：\nh(key) = (key * 3) % 10，\n处理冲突采用线性探测再散列法。（注：% 是求余运算）\n(1) 请画出所构造的哈希表；\n(2) 并计算查找成功的平均查找长度。\n\n3. 排序算法问题\n给定关键字序列 {24, 19, 32, 43, 38, 6, 13, 22}，\n(1) 请写出快速排序第一趟的结果；\n(2) 请画出堆排序时所建的初始堆（大顶堆）。\n\n4. 树结构问题\n设有序列：w = {23, 24, 27, 80, 28}，\n(1) 试画出二叉排序树；\n(2) 试画出平衡二叉树；\n(3) 试画出哈夫曼树；\n(4) 请给出对于增量 d = 2 按降序执行一趟希尔排序的结果。\n\n四、算法设计（本大题共2小题，每小题10分，总计20分）\n1. 单链表插入算法设计\n请设计算法 ListInsert_L，用以实现：在带头结点的单链表 L 中第 i 个位置之前插入元素 e。结点结构如下：\ntypedef struct LNode {\n    ElemType        data;\n    struct LNode   *next;\n} LNode, *LinkList;\nStatus ListInsert_L(LinkList &amp;L, int i, ElemType e) { ... }\n// 在带头结点的单链表 L 中第 i 个位置之前插入元素 e。\n2. 二叉树中序遍历非递归算法设计\n以二叉链表作存储结构，请设计中序遍历非递归算法 InOrderTraverse，对每个数据元素调用函数 Visit。二叉树的二叉链表存储表示如下：\ntypedef struct BiTNode {\n    TElemType       data;\n    struct BiTNode  *lchild, *rchild; // 左右孩子指针\n} BiTNode, *BiTree;\nStatus InOrderTraverse(BiTree T, Status(* Visit)(TElemType e)) { ... }\n// 采用二叉链表存储结构，Visit 是对数据元素操作的应用函数。\n// 中序遍历二叉树 T 的非递归算法，对每个数据元素调用函数 Visit。\n23 - 24\n一、填空题（本大题每空 3 分，共 30 分）\n\n\n对于给定的 n 个元素，可以构造出的逻辑结构有集合、线性结构、、 四种。\n\n\n数据结构中评价算法的两个重要指标是 ________ 和空间复杂度。\n\n\n下面程序段的时间复杂度为 ________。（n&gt;1）\nfor (j = 1; j &lt;= n; ++j)\n    for (k = 1; k &lt;= n; ++k)\n        {++x; s += x;}\n\n\n已知数组 A[0..9, 0..9] 的每个元素占 5 个存储单元，将其按列优先次序存储在起始地址为 1000 的连续的内存单元中，则元素 A[5, 4] 的地址为 ________。\n\n\n设广义表 A = (x, a, b, c, d)，则 \\text{Head}(\\text{Tail}(A)) = ________。\n\n\n模式串 P = \\text{`abaaabac`} 的 next 函数值序列为 ________。\n\n\n设有一个空栈，现有输入序列为 1, 2, 3, 4, 5，经过 \\text{PUSH}, \\text{PUSH}, \\text{POP}, \\text{PUSH}, \\text{POP}, \\text{PUSH}, \\text{POP} 之后，输出序列是 ________。\n\n\n设一棵树的二元组形式表示为 T = (D, R)，其中 D = \\{A, B, C, D, E, F, G\\}，R = \\{(\\Lambda, B), (A, C), (A, D), (B, E), (C, F)\\}，则该树的深度为 ________，叶子结点的个数为 ________。\n\n\n二、简答题（本大题共 2 小题，每小题 10 分，共 20 分）\n\n\n线性表有两种存储结构：一是顺序表，二是链表。试问：\n（1）如果有 n 个线性表同时并存，并且在处理过程中各表的长度会动态变化，线性表的总数也会自动地改变。在此情况下，应选用哪种存储结构？为什么？\n（2）若线性表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取线性表中的元素，那么应采用哪种存储结构？为什么？\n\n\n已知一棵二叉树的先序序列ABDGJEHCFIKL;中序序列DJGBEHACKILF,画出二叉树的形态。\n\n\n算法设计\n1. 哈夫曼编码问题\n假设用于通信的电文仅由 8 个字母 (a, b, c, d, e, f, g, h) 组成。字母在电文中出现的频率分别为 0.07, 0.17, 0.19, 0.06, 0.28, 0.03, 0.11, 0.09。\n要求：\n\n构造哈夫曼树\n计算带权路径长度\n为这 8 个字母设计哈夫曼编码\n评分标准：构造过程 2 分，树 3 分，编码 3 分，长度计算过程 1 分，结果 1 分\n\n\n2. Kruskal 算法问题\n题目：试写出用克鲁斯卡尔（Kruskal）算法构造下图的一棵最小生成树的过程。（需给出中间步骤）\n图结构描述（节点 1-7，边权重如下）：\n//ACM式input(u,v,w)\n1 7 6\n1 6 4\n1 2 18\n1 5 23\n7 6 7\n6 4 3\n6 5 25\n5 4 15\n4 3 10\n3 2 5\n5 2 12\n2 4 8\n3. 已知一图如下所示：\n(u,v,weight，标记)\n1 2 3 A\n1 3 2 B\n2 4 2 C\n2 5 3 D\n3 4 4 E\n3 6 3 F\n4 6 2 G\n5 6 1 H\n要求：\n\n写出该图的邻接矩阵\n以 1 为源点、6 为终点，给出所有事件允许发生的最早时间和最晚时间\n求出关键路径（列出各活动的最早发生时间和最迟发生时间）并指明完成该工程所需的最短时间\n\n4.哈希表构造问题\n已知条件：\n\n关键字集合：{19, 14, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}（注：01 即 1）\n散列函数：H(Key) = Key MOD 13\n冲突处理：线性探测再散列\n地址空间：A[0..15]\r\n要求：\n构造哈希表\n计算 ASL（平均查找长度）\n评分标准：构造过程 4 分，哈希表 4 分，ASL 2 分\n\n5. 快速排序问题\n已知条件：\n\n\n记录关键字集：{50, 10, 50, 40, 20, 45, 85, 80}\r\n要求：\n\n\n用快速排序方法进行排序\n\n\n说明其稳定性\n\n\n给出每一轮快速排序的结果\n\n\n22-23\n填空题（本大题每空 3 分，共 30 分）\n\n对于给定的 n 个元素，可以构造出的逻辑结构有集合、线性结构、、 四种。\n数据结构中评价算法的两个重要指标是时间复杂度和 __________。\n下面程序段的时间复杂度为 __________。（n &gt; 1）\nsum = 1;\nfor (i = 0; sum &lt; n; i++) sum += 1;\n\n设有一个空栈，现有输入序列为 1, 2, 3, 4，经过 PUSH, PUSH, POP, PUSH, POP, PUSH, POP, PUSH, POP 操作之后，输出序列是 __________。\n设广义表 A = (x, a, b, c, d)，则 \\text{Head}(\\text{Tail}(A)) = __________。\n模式串 P = \\text{`abaaabac`} 的 next 函数值序列为 __________。\n已知数组 A[0..9, 0..9] 的每个元素占 5 个存储单元，将其按行优先次序存储在起始地址为 1000 的连续内存单元中，则元素 A[6,7] 的地址为 __________。\n一棵深度为 k 的满二叉树的结点总数为 __________；一棵深度为 k 的完全二叉树的结点总数最少有 __________ 个。\n\n\n简答题（本大题共 2 小题，每小题 10 分，共 20 分）\n\n\n线性表有两种存储结构：一是顺序表，二是链表。试问：\n(1) 如果有 n 个线性表同时并存，并且在处理过程中各表的长度会动态地改变，线性表的总数也会自动地改变。在此情况下，应选用哪种存储结构？为什么？\n(2) 若线性表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取线性表中的元素，那么应采用哪种存储结构？为什么？\n\n\n给出下图中二叉树的先序遍历序列、中序遍历序列和后序遍历序列。\nACM 常用输入格式（树结构描述）：\n(A(B(D(,G)),C(E,F)))\n\n树结构图：\n      A\r\n    /   \\\r\n   B     C\r\n  /     / \\\r\n D     E   F\r\n  \\\r\n   G\n\n\n\n三、算法应用（本大题共 5 小题，每小题 10 分，共 50 分）\n\n\n假设用于通信的电文仅由 8 个字母（a, b, c, d, e, f, g, h）组成，字母在电文中出现的频率分别为 0.07, 0.19, 0.02, 0.06, 0.32, 0.03, 0.21, 0.10。试构造哈夫曼树，计算带权路径长度，并为这 8 个字母设计哈夫曼编码。（要给出构造哈夫曼树的过程）\n\n\n试写出用克鲁斯卡尔（Kruskal）算法构造下图的一棵最小生成树的过程。（要给出中间步骤）\nACM 常用输入格式（无向图边列表）：\n7 12\r\n1 2 18\r\n1 5 23\r\n1 6 4\r\n1 7 6\r\n2 3 5\r\n2 4 8\r\n2 5 12\r\n3 4 10\r\n4 5 15\r\n4 6 20\r\n5 6 25\r\n6 7 7\n\n\n\n已知一图如下图所示：\n4) 写出该图的邻接矩阵；\n5) 以 1 为源点，以 6 为终点，给出所有事件允许发生的最早时间和最晚时间；\n6) 求出关键路径（列出各活动的最早发生时间和最迟发生时间）并指明完成该工程所需的最短时间。\nACM 常用输入格式（有向图边列表，AOE 网）：\n6 8\r\n1 2 3\r\n1 3 2\r\n2 4 2\r\n2 5 3\r\n3 4 4\r\n3 6 3\r\n4 6 2\r\n5 6 1\n\n\n\n已知一组关键字为 {25, 51, 8, 22, 26, 67, 11, 16, 54, 41} 按哈希函数 H(\\text{Key}) = \\text{Key} \\mod 13 和线性探测再散列处理冲突的方法在地址空间 A[0..12] 中构造哈希表，并求 ASL。\n\n\n已知某文件的记录关键字集为 {50, 10, 50, 40, 20, 45, 85, 80}，请用快速排序方法对其进行排序，且说明其稳定性。（要给出每一趟快速排序的结果）\n\n"},"归档/大二上期末/概率论/期末题归档":{"slug":"归档/大二上期末/概率论/期末题归档","filePath":"归档/大二上期末/概率论/期末题归档.md","title":"期末题归档","links":[],"tags":[],"content":"2023 - 2024\n一、选择题（本大题共5小题，每小题4分，总计20分）\n\n\n设A,B为随机事件，若P(A)=1，则以下选项正确的是（ ）\n(A) A为必然事件；\n(B) A\\supset B；\n(C) AB=\\phi；\n(D) A与B相互独立。\n\n\nX与Y相互独立，分布均为N(1,\\sigma^2)，则P\\{\\min(X,Y)&gt;1\\}的值为（ ）\n(A) \\frac{1}{2}；\n(B) \\frac{1}{3}；\n(C) \\frac{1}{4}；\n(D) \\frac{1}{5}。\n\n\n若变量X和Y满足Cov(X+Y,X-Y)=0，则下列选项正确的是（ ）\n(A) X与Y独立；\n(B) X与Y不相关；\n(C) E(X)=E(Y)；\n(D) D(X)=D(Y)。\n\n\n设X与Y均为标准正态分布的变量，则以下结论正确的是（ ）\n(A) X+Y服从正态分布；\n(B) X^2+Y^2服从\\chi^2分布；\n(C) X^2和Y^2都服从\\chi^2分布；\n(D) X^2/Y^2服从F分布。\n\n\nX_1,X_2,\\cdots,X_n为取自泊松总体P(\\lambda)的样本，\\lambda未知，下列不是统计量的是（ ）\n(A) \\sum_{i=1}^{n}X_i；\n(B) \\frac{1}{n}\\sum_{i=1}^{n}(X_i-1)^2；\n(C) \\sum_{i=1}^{n}X_i^2；\n(D) \\frac{1}{n}\\sum_{i=1}^{n}(X_i-\\lambda)^2。\n\n\n二、填空题（本大题共5小题，每小题4分，总计20分）\n\n\n设A,B互不相容，且P(A)=0.4，P(A\\cup B)=0.8，则P(B)=。\n\n\n袋子中有9个球，其中3个红球，每次取一球，取出后不放回，则直到第三次才取到红球的概率为。\n\n\n设随机变量X\\sim b(n,\\frac{1}{2})，且P\\{X=1\\}=P\\{X=2\\}，则n=。\n\n\n设X\\sim U(0,2)，用切比雪夫不等式估计得P\\{|X-1|\\geq 2\\}\\leq。\n\n\n设一组容量为n=5的样本观察值为8,6,9,5,7，则样本方差S^2=。\n\n\n三、解答题（本大题共7小题，每小题8分，总计56分）\n\n\n物流中心有甲、乙、丙三种快递分拣机器人，甲、乙、丙的数量分别为25台、35台、40台，且分拣错误率分别为5%、4%、2%。现随机抽检一个快递，求：\n(1) 该快递分拣错误的概率；\n(2) 若该快递分拣错误，则其为甲种机器人分拣的概率。\n\n\n随机变量X的概率密度函数为f(x)=\\begin{cases}A(2x+1), &amp; 0&lt;x&lt;2 \\\\ 0, &amp; \\text{其他}\\end{cases}。求：\n(1) 未知参数A的值；\n(2) 概率P\\{-2&lt;X&lt;1\\}的值。\n\n\n随机变量X的分布律如右表所示。求：\n(1) X的分布函数F(x)；\n(2) P\\{\\frac{3}{2}&lt;X\\leq\\frac{5}{2}\\}的值。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX123p_k\\frac{1}{5}\\frac{3}{10}\\frac{1}{2}\n\n\n二维随机变量(X,Y)的联合概率密度函数为\nf(x,y)=\\begin{cases}2e^{-2x-y}, &amp; x&gt;0,y&gt;0 \\\\ 0, &amp; \\text{其他}\\end{cases}\n求：\n(1) X的边缘概率密度函数f_X(x)；\n(2) 概率P\\{X\\leq Y\\leq 2X\\}的值。\n\n\nX与Y为随机变量，E(X)=1，E(Y)=2，D(X)=4，D(Y)=9，\\rho_{XY}=0.5，求：\n(1) D(X+Y)的值；\n(2) E(XY)的值。\n\n\n随机变量X的概率密度函数为\nf_X(x)=\\begin{cases}\\frac{1}{9}x^2, &amp; 0&lt;x&lt;3 \\\\ 0, &amp; \\text{其他}\\end{cases}\n令Y=2X-1，求Y的概率密度函数f_Y(y)。\n\n\n总体X的密度函数为\nf(x)=\\begin{cases}2\\theta x^{2\\theta-1}, &amp; 0&lt;x&lt;1,\\ \\theta&gt;0 \\\\ 0, &amp; \\text{其他}\\end{cases}\nX_1,X_2,\\cdots,X_n为取自该总体的一组样本，求未知参数\\theta的矩估计量和极大似然估计量。\n\n\n四、证明题（本大题共1小题，每小题4分，总计4分）\n\n设总体X的均值为\\mu，方差为\\sigma^2，X_1,X_2,\\cdots,X_n为取自总体X的样本，令\n\\hat{\\mu}_k=\\frac{1}{k}\\sum_{i=1}^{k}X_i,\\ k=1,2,\\cdots,n.\n证明：\\hat{\\mu}_{n-1}，\\hat{\\mu}_n均为\\mu的无偏估计且\\hat{\\mu}_n比\\hat{\\mu}_{n-1}更有效。\n\n2022 - 2023\n\n\n设A,B为随机事件，则以下选项正确的是（ ）\n(A) P(A)=P(AB)+P(A\\overline{B})；\n(B) P(A-B)=P(A)-P(B)；\n(C) P(A\\cup B)=P(A)+P(B)；\n(D) P(AB)=P(A)P(B)。\n\n\n若随机变量X与Y相互独立，且P\\{X\\leq 1\\}=P\\{Y\\leq 1\\}=\\frac{1}{5}，则P\\{\\min(X,Y)\\leq 1\\}=（ ）\n(A) \\frac{2}{5}；\n(B) \\frac{4}{5}；\n(C) \\frac{1}{25}；\n(D) \\frac{9}{25}。\n\n\n若随机变量X和Y满足D(X+Y)=D(X)+D(Y)，则下列选项正确的是（ ）\n(A) X与Y独立；\n(B) X与Y不相关；\n(C) X与Y不独立；\n(D) D(XY)=D(X)D(Y)。\n\n\n设X\\sim N(0,1)，Y\\sim N(0,1)，且X与Y相互独立，则（ ）\n(A) X+Y服从正态分布；\n(B) X^2+Y^2服从\\chi^2分布；\n(C) X^2和Y^2都服从\\chi^2分布；\n(D) X^2/Y^2服从F分布。\n\n\n设X_1,X_2,\\cdots,X_n为来自总体N(\\mu,1)的一组样本，\\mu未知，则下列选项中不是统计量的是（ ）\n(A) \\sum_{i=1}^{n}X_i；\n(B) \\sum_{i=1}^{n}X_i^2；\n(C) \\frac{1}{n}\\sum_{i=1}^{n}(X_i-\\overline{X})^2；\n(D) \\frac{1}{n}\\sum_{i=1}^{n}(X_i-\\mu)^2。\n\n\n二、填空题（本大题共5小题，每小题4分，总计20分）\n\n\n设A,B独立，且P(A)=0.4，P(A\\cup B)=0.8，则P(B)=。\n\n\n设随机变量X服从正态分布N(2023,100)，则满足P\\{X&gt;C\\}=P\\{X\\leq C\\}的常数C=。\n\n\n设随机变量X\\sim U(0,\\theta)，且D(X)=12，则\\theta=。\n\n\n设D(X)=9，D(Y)=25，\\rho_{XY}=-0.4，则D(X+2Y)=。\n\n\n设X_1,X_2,\\cdots,X_n为来自总体N(1,\\sigma^2)的一组简单随机样本，\\overline{X}=\\frac{1}{n}\\sum_{i=1}^{n}X_i为其样本均值，则\\overline{X}依概率收敛于。\n\n\n三、解答题（本大题共7小题，每小题8分，总计56分）\n\n\n播种的小麦种子中混含有2%的二等种子，1.5%的三等种子，1%的四等种子，其余为一等种子。用一等、二等、三等、四等种子长出的穗含50颗以上麦粒的概率分别为0.5, 0.15, 0.1, 0.05，现从这批种子中任取一颗，求这颗种子所结的穗含有50颗以上麦粒的概率。\n\n\n设随机变量X的密度函数为\nf(x)=\\begin{cases}A\\cos x, &amp; |x|\\leq\\frac{\\pi}{2} \\\\ 0, &amp; \\text{其他}\\end{cases}\n求：\n(1) A的值；\n(2) 计算概率P\\{0&lt;X&lt;\\frac{\\pi}{4}\\}的值。\n\n\n设随机变量X的分布律如右表所示：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX012p_k\\frac{1}{4}k\\frac{1}{2}\n求：\n(1) 常数k的值；\n(2) X的分布函数F(x)。\n\n\n设二维随机变量的联合概率密度为\nf(x,y)=\\begin{cases}6(1-y), &amp; 0&lt;x&lt;y&lt;1 \\\\ 0, &amp; \\text{其他}\\end{cases}\n(1) 计算P(X&gt;0.5,Y&gt;0.5)；\n(2) 计算P\\{X+Y&lt;1\\}。\n\n\n随机变量U服从(-2,2)上的均匀分布，定义X和Y如下：\nX=\\begin{cases}0, &amp; U&lt;-1 \\\\ 1, &amp; U\\geq -1\\end{cases}, \\quad Y=\\begin{cases}0, &amp; U&lt;1 \\\\ 1, &amp; U\\geq 1\\end{cases}\n求X与Y的协方差Cov(X,Y)。\n\n\n设X的概率密度函数为\nf_X(x)=\\begin{cases}\\frac{1}{9}x^2, &amp; 0&lt;x&lt;3 \\\\ 0, &amp; \\text{其他}\\end{cases}\n令Y=e^X，求Y的概率密度函数f_Y(y)。\n\n\n设X_1,X_2,\\cdots,X_n为来自总体X的一组样本，总体X的密度函数为\nf(x)=\\begin{cases}\\theta x^{\\theta-1}, &amp; 0&lt;x&lt;1 \\\\ 0, &amp; \\text{其他}\\end{cases}\n其中未知参数\\theta&gt;0，求\\theta的矩估计量和极大似然估计量。\n\n\n四、证明题（本大题共1小题，每小题4分，总计4分）\n\n设总体的均值为\\mu，方差为\\sigma^2，X_1,X_2,X_3为取自总体的样本，利用样本构造均值\\mu的估计\\hat{\\mu}_1=\\frac{1}{4}X_1+\\frac{1}{2}X_2+\\frac{1}{4}X_3，\\hat{\\mu}_2=\\frac{1}{5}X_1+\\frac{2}{5}X_2+\\frac{2}{5}X_3。证明：\\hat{\\mu}_1、\\hat{\\mu}_2均为无偏估计且\\hat{\\mu}_2比\\hat{\\mu}_1更有效。\n\n2021-2022\n一、选择题（本大题共5小题，每小题4分，总计20分）\n\n\n设A,B为随机事件，则以下选项正确的是（ ）\n(A)\\ P(\\overline{A})+P(A)=1;\n(B)\\ P(A-B)=P(A)-P(B);\n(C)\\ P(A\\cup B)=P(A)+P(B);\n(D)\\ P(AB)=P(A)P(B).\n\n\n若随机变量X与Y相互独立，且P\\{X\\leq1\\}=P\\{Y\\leq1\\}=\\frac{2}{5}，则P\\{\\max(X,Y)\\leq1\\}=（ ）\n(A)\\ \\frac{2}{5};\n(B)\\ \\frac{4}{5};\n(C)\\ \\frac{4}{25};\n(D)\\ \\frac{6}{25}.\n\n\n若随机变量X和Y满足Cov(X,Y)=0，则下列选项正确的是（ ）\n(A)\\ X与Y独立；\n(B)\\ X与Y不相关；\n(C)\\ X与Y不独立；\n(D)\\ D(XY)=D(X)D(Y).\n\n\n设X\\sim N(-3,2)，Y\\sim N(2,1)，且X与Y相互独立，则Z=X-Y所服从的分布为（ ）\n(A)\\ N(-5,1);\n(B)\\ N(-1,1);\n(C)\\ N(-5,3);\n(D)\\ N(-1,3).\n\n\n设X_1,X_2,\\cdots,X_n为来自总体U(0,\\theta)的一组样本，\\theta未知，则下列选项中不是统计量的是（ ）\n(A)\\ \\sum_{i=1}^{n}X_i;\n(B)\\ \\sum_{i=1}^{n}X_i^2;\n(C)\\ \\frac{1}{n}\\sum_{i=1}^{n}(X_i-\\overline{X})^2;\n(D)\\ \\frac{1}{n}\\sum_{i=1}^{n}(X_i-\\theta)^2.\n\n\n二、填空题（本大题共5小题，每小题4分，总计20分）\n\n\n设A,B互不相容，且P(A)=0.4，P(A\\cup B)=0.7，则P(B)=________.\n\n\n袋子中有4只白球,3只黑球，从中随机地取出3只球，则其中恰有2只白球的概率为________.\n\n\n设随机变量X\\sim B(n,\\frac{1}{2})，且P\\{X=0\\}=\\frac{1}{8}，则n=________.\n\n\n设D(X)=9,D(Y)=25,Cov(X,Y)=8，则D(X+Y)=________.\n\n\n设X_1,X_2,\\cdots,X_n为来自总体N(\\mu,\\sigma^2)的一组简单随机样本，\\overline{X}=\\frac{1}{n}\\sum_{i=1}^{n}X_i为其样本均值，则D(\\overline{X})=________.\n\n\n三、解答题（本大题共7小题，每小题8分，总计56分）\n\n\n一箱产品中，由A，B两厂生产的分别各占70%，30%，两厂的次品率分别为3%，5%。现在从中任取一件产品，求：（1）取到次品的概率；（2）若取到次品，则该产品是B厂生产的概率。\n\n\n设随机变量X的密度函数为f(x)=Ae^{-|x|}，-\\infty&lt;x&lt;+\\infty，求（1）A的值；（2）计算概率P\\{-1\\leq X\\leq1\\}的值。\n\n\n设随机变量X的分布律为下表所示：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX123p_k\\frac{1}{5}k\\frac{1}{2}\n求：（1）常数k的值；（2）X的分布函数F(x)。\n\n\n设二维随机变量的联合概率密度为\r\nf(x,y)=\\begin{cases}2e^{-2x-y}, &amp; x&gt;0,y&gt;0 \\\\ 0, &amp; \\text{其他}.\\end{cases}\r\n（1）计算(X,Y)落在区域D:\\{0\\leq x\\leq1,0\\leq y\\leq1\\}内的概率；\r\n（2）计算P\\{Y\\leq X\\}。\n\n\n设X与Y相互独立，各自分布律如下表所示：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX13p_k0.50.5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nY24p_k0.40.6\n求：（1）D(X)的值；（2）E(XY)的值。\n\n\n设X的概率密度函数为f_X(x)=\\begin{cases}\\frac{1}{8}x, &amp; 0&lt;x&lt;4 \\\\ 0, &amp; \\text{其他}\\end{cases}，令Y=2X+1，求Y的概率密度f_Y(y)。\n\n\n设X_1,X_2,\\cdots,X_n为来自总体X的一组样本，总体X的密度函数为\r\nf(x)=\\begin{cases}(\\theta+1)x^\\theta, &amp; 0&lt;x&lt;1 \\\\ 0, &amp; \\text{其他}\\end{cases}\r\n其中未知参数\\theta&gt;-1，求\\theta的矩估计量和极大似然估计量。\n\n\n四、证明题（本大题共1小题，每小题4分，总计4分）\n\n设总体的均值为\\mu，方差为\\sigma^2，X_1,X_2,X_3为取自总体的样本，利用样本构造均值\\mu的估计\\hat{\\mu}_1=\\frac{1}{2}X_1+\\frac{1}{3}X_2+\\frac{1}{6}X_3，\\hat{\\mu}_2=\\frac{1}{3}X_1+\\frac{1}{3}X_2+\\frac{1}{3}X_3。证明：\\hat{\\mu}_1、\\hat{\\mu}_2均为无偏估计且\\hat{\\mu}_2比\\hat{\\mu}_1更有效。\n"},"归档/大二上期末/概率论/概率论宝宝巴士":{"slug":"归档/大二上期末/概率论/概率论宝宝巴士","filePath":"归档/大二上期末/概率论/概率论宝宝巴士.md","title":"概率论宝宝巴士","links":[],"tags":[],"content":"概率论期末冲刺指南 (基于近三年真题分析)\n试卷结构基本固定为：选择题（20分）、填空题（20分）、解答题（56分）和证明题（4分）。\n这份指南将带你梳理必考知识点，明确复习的优先级。\n一、 冲刺复习路线 (知识点梳理)\n建议按照以下模块顺序进行复习，重点关注标记为 【极高频】 和 【高频】 的考点。\n模块一：随机事件与概率 (第1章)\n这是基础，主要出现在选择和填空题，以及第一道大题。\n\n事件的关系与运算：\n\n考点：理解互不相容（互斥）、相互独立的概念。\n题型：选择题（如 2023 题1, 2022 题1, 2021 题1）、填空题（如 2023 题6, 2021 题6）。\n\n\n概率基本性质：\n\n考点：P(A \\cup B) = P(A) + P(B) - P(AB)（若独立，则 P(AB) = P(A)P(B)；若互斥，则 P(AB) = 0）。\n题型：填空题（如 2022 题6）。\n\n\n古典概型与几何概型：\n\n考点：基本的排列组合计算概率。\n题型：填空题（如 2023 题7, 2021 题7）。\n\n\n全概率公式与贝叶斯公式：【极高频】\n\n考点：这是每年必考的第一道大题。通常是“分层抽样”问题（如工厂次品率、机器人错误率）。\n题型：解答题（如 2023 题11, 2022 题11, 2021 题11）。\n\n(1) 用全概率公式求总概率（如“求分拣错误的概率”）。\n(2) 用贝叶斯公式求后验概率（如“若分拣错误，则为甲机器人分拣的概率”）。\n\n\n\n\n\n模块二：一维随机变量及其分布 (第2、3章)\n这是概率论的核心基础，贯穿所有题型。\n\n离散型随机变量：\n\n考点：根据分布律求常数（\\sum p_k = 1），求分布函数 F(x)，计算概率。\n题型：解答题（如 2023 题13, 2022 题13, 2021 题13）。\n\n\n连续型随机变量：【极高频】\n\n考点：\n\n\n\n利用 \\int_{-\\infty}^{+\\infty} f(x) dx = 1 求密度函数 f(x) 中的未知常数 A。\n\n\n\n\n利用 f(x) 计算概率 P(a &lt; X &lt; b) = \\int_{a}^{b} f(x) dx。\n\n\n\n\n题型：解答题（如 2023 题12, 2022 题12, 2021 题12）。\n\n\n常见分布：\n\n考点：熟记二项分布 B(n,p)、泊松分布 P(\\lambda)、均匀分布 U(a,b)、正态分布 N(\\mu, \\sigma^2) 的性质（特别是期望和方差）。\n题型：选择题（如 2023 题5, 2022 题8）、填空题（如 2023 题8, 2022 题7, 2021 题8）。\n\n\n随机变量的函数：【高频】\n\n考点：已知 X 的密度函数 f_X(x)，求 Y = g(X) 的密度函数 f_Y(y)。\n标准方法（必会）：\n\n求 Y 的分布函数 F_Y(y) = P(Y \\le y) = P(g(X) \\le y)。\n解出不等式，转换为关于 X 的概率 P(X \\le h(y))。\n利用 f_X(x) 积分得到 F_Y(y)。\n求导：f_Y(y) = F_Y&#039;(y)，注意 y 的取值范围。\n\n\n题型：解答题（如 2023 题16 Y=2X-1, 2022 题16 Y=e^X, 2021 题16 Y=2X+1）。\n\n\n\n模块三：多维随机变量及其分布 (第4章)\n这是考试的重点和难点，每年必考。\n\n二维联合分布：\n\n考点：给定联合密度 f(x,y)，在指定区域 D 上进行二重积分求概率 P((X,Y) \\in D)。\n题型：解答题（如 2023 题14 (2), 2022 题14, 2021 题14）。\n\n\n边缘分布：【高频】\n\n考点：通过 f(x,y) 求边缘密度 f_X(x) = \\int_{-\\infty}^{+\\infty} f(x,y) dy。\n题型：解答题（如 2023 题14 (1)）。\n\n\n随机变量的独立性：\n\n考点：X, Y 独立的性质，如 P(\\min(X,Y) \\&gt; a) = P(X\\&gt;a, Y\\&gt;a) = P(X\\&gt;a)P(Y\\&gt;a)。\n题型：选择题（如 2023 题2, 2022 题2, 2021 题2）。\n\n\n\n模块四：随机变量的数字特征 (第5章)\n这是每年必考的计算大题，分值高，必须掌握。\n\n期望 (E)、方差 (D)、协方差 (Cov)、相关系数 (\\rho)：\n\n考点：熟练运用 E, D, Cov 的性质。\n核心公式：\n\nD(X) = E(X^2) - [E(X)]^2\nCov(X,Y) = E(XY) - E(X)E(Y)\nD(X \\pm Y) = D(X) + D(Y) \\pm 2Cov(X,Y)（若独立，则 Cov=0）\n\\rho_{XY} = \\frac{Cov(X,Y)}{\\sqrt{D(X)D(Y)}}\nE(aX+bY) = aE(X) + bE(Y)\nD(aX+b) = a^2 D(X)\n\n\n题型：\n\n解答题：【极高频】 每年必考。通常是告知 E(X), E(Y), D(X), D(Y), \\rho_{XY}，求 E(XY) 和 D(aX \\pm bY)。（如 2023 题15, 2021 题15）。\n选择/填空：考查性质（如 2023 题3, 2022 题3, 9, 2021 题3, 9）。注意：独立 \\Rightarrow 不相关 (Cov=0)，但反之不成立。\n\n\n\n\n\n模块五：大数定律与中心极限定理 (第6章)\n主要出现在填空题。\n\n切比雪夫不等式：\n\n考点：P\\{|X - \\mu| \\ge \\epsilon\\} \\le \\frac{\\sigma^2}{\\epsilon^2}。\n题型：填空题（如 2023 题9）。\n\n\n依概率收敛：\n\n考点：样本均值 \\overline{X} 依概率收敛于总体期望 \\mu。\n题型：填空题（如 2022 题10）。\n\n\n\n模块六：数理统计 (第7、8章)\n这是后半部分的重点，每年必考两道大题（一道估计，一道证明）。\n\n基本概念：\n\n考点：统计量的定义（不含未知参数）。\n题型：选择题（如 2023 题5, 2022 题5, 2021 题5）。\n\n\n抽样分布：\n\n考点：正态总体的 \\chi^2 分布、 F 分布的构造。\n题型：选择题（如 2023 题4, 2022 题4）。\n\n\n参数估计：【极高频】\n\n考点：矩估计法 (MOM) 和 极大似然估计法 (MLE)。\nMOM：解方程 E(X) = \\overline{X} （或 E(X^k) = \\frac{1}{n}\\sum X_i^k）。\nMLE：\n\n写出似然函数 L(\\theta) = \\prod_{i=1}^{n} f(x_i, \\theta)。\n取对数 \\ln L(\\theta)。\n求导 \\frac{d \\ln L(\\theta)}{d\\theta} = 0，解出 \\hat{\\theta}。\n\n\n题型：每年必考一道解答题（如 2023 题17, 2022 题17, 2021 题17）。\n\n\n估计量的评选标准：【高频】\n\n考点：无偏性 (E(\\hat{\\theta}) = \\theta) 和 有效性 (比较方差 D(\\hat{\\theta})，方差越小越有效)。\n题型：每年必考的最后一道证明题（如 2023 题18, 2022 题18, 2021 题18）。\n\n\n\n证明无偏性：求 E(\\hat{\\mu})，利用 E(X_i) = \\mu。\n\n\n\n\n比较有效性：求 D(\\hat{\\mu})，利用 D(X_i) = \\sigma^2 和样本独立性。\n\n\n\n\n\n\n\n二、 考点重要性分析 (必看)\n根据近三年的规律，考点的重要性排序如下：\n\nT0：必考大题 (56分中的 \\approx 40 分)\n\n参数估计 (MOM &amp; MLE)：(2023, 2022, 2021 均考)\n数字特征 (E, D, Cov)：(2023, 2022, 2021 均考)\n一维/二维 RV (求常数, 求概率, 求边缘)：(2023, 2022, 2021 均考)\n全概率 &amp; 贝叶斯：(2023, 2022, 2021 均考)\nRV 的函数 (求Y的密度)：(2023, 2022, 2021 均考)\n估计量评判 (无偏 &amp; 有效)：(2023, 2022, 2021 均考)\n\n\nT1：必考选择/填空 (40分中的 \\approx 20 分)\n\n统计量定义：(2023, 2022, 2021 均考)\n事件独立/互斥：(2023, 2022, 2021 均考)\n常见分布性质 (E, D)：(2023, 2022, 2021 均考)\n数字特征性质 (E, D, Cov)：(2023, 2022, 2021 均考)\n\n\nT2：轮换考点 (40分中的 \\approx 20 分)\n\n切比雪夫不等式：(2023 考)\n大数定律 (依概率收敛)：(2022 考)\n抽样分布 (\\chi^2, F)：(2023, 2022 考)\n古典概型 (抽球)：(2023, 2021 考)\n\n\n\n三、 考前题型预测\n基于高度稳定的出题规律，下次考试极有可能出现以下题目：\n\n选择题：\n\n一道判断“统计量”的题。\n一道考“独立性”的题（如 P(\\max(X,Y) \\le 1) 或 P(\\min(X,Y) \\&gt; 1)）。\n一道考“数字特征性质”的题（如 Cov(X,Y)=0 时 D(X+Y) 等于多少）。\n一道考“抽样分布”的题（如 X, Y 独立同 N(0,1)，问 X^2+Y^2 或 X/Y）。\n\n\n填空题：\n\n一道考“古典概型”或“事件概率”的题。\n一道考“常见分布”的题（如 X \\sim B(n,p) 或 X \\sim U(a,b)，知 E(X) 或 D(X) 求参数）。\n一道考“大数定律”或“切比雪夫”的题。\n\n\n解答题 (7道)：\n\n题11：全概率 + 贝叶斯（换个背景，如三种机器、三个地区…）。\n题12：一维连续型 f(x)，求常数 A，求 P(a &lt; X &lt; b)。\n题13：一维离散型分布律，求常数 k，求分布函数 F(x)。\n题14：二维连续型 f(x,y)，求边缘密度 f_Y(y)，求 P(X+Y \\le 1) 或 P(X &lt; Y)。\n题15：数字特征计算，给定 E, D, \\rho，求 Cov(X, X-Y) 或 D(2X-Y)。\n题16：RV 的函数，给定 f_X(x)，求 Y=X^2 或 Y=-\\ln X 的 f_Y(y)。\n题17：参数估计，给定 f(x, \\theta)，求 \\theta 的矩估计和极大似然估计。\n\n\n证明题 (1道)：\n\n题18：给定两个估计量 \\hat{\\mu}_1, \\hat{\\mu}_2，证明无偏性，比较有效性。\n\n\n\n冲刺建议：不要 花时间钻研偏题怪题。把近三年的真题（你已有的）每一道解答题 重新做一遍，确保MOM &amp; MLE、数字特征、RV函数 这三大块的计算步骤完全熟练。把选择和填空错题涉及的概念（如统计量、独立性、抽样分布）背熟。\n祝你期末顺利！"},"归档/大二上期末/概率论/随机事件与概率":{"slug":"归档/大二上期末/概率论/随机事件与概率","filePath":"归档/大二上期末/概率论/随机事件与概率.md","title":"随机事件与概率","links":[],"tags":[],"content":"事件的关系与运算(T1)\n\n很多基础知识的考点，下面列出一些常见的考点\n\n当P(A) = 1时候，其可能不为必然事件(在数轴上选一点其不为0的概率)\n\n\n\ngantt\r\n    dateFormat  X\r\n    axisFormat %s\r\n    title U 的取值对 X, Y 及 XY 的影响\r\n\r\n    section U 的数轴区域\r\n    区域 1 (-2 到 -1) : -2, -1\r\n    区域 2 (-1 到 1)  : -1, 1\r\n    区域 3 (1 到 2)   : 1, 2\r\n\r\n    section X 的值\r\n    X = 0 (条件 U &lt; -1) : crit, -2, -1\r\n    X = 1 (条件 U ≥ -1) : active, -1, 2\r\n\r\n    section Y 的值\r\n    Y = 0 (条件 U &lt; 1)  : crit, -2, 1\r\n    Y = 1 (条件 U ≥ 1)  : active, 1, 2\r\n\r\n    section XY 的乘积值\r\n    XY = 0 (X或Y为0)    : crit, -2, 1\r\n    XY = 1 (X和Y都为1)  : active, 1, 2\n"},"归档/概率论与数理统计/0.概率论":{"slug":"归档/概率论与数理统计/0.概率论","filePath":"归档/概率论与数理统计/0.概率论.md","title":"0.概率论","links":[],"tags":[],"content":"概率论入门\n\n\n                  \n                  Tip\n                  \n                \n\n\n现在给出概率论数学符号约定,我们使用P(A)表示事件A的概率,使用集合运算符号\\cap,\\cup表示事件的关系\n\n\n"},"归档/概率论与数理统计/1.随机事件和样本空间-and-频率与概率":{"slug":"归档/概率论与数理统计/1.随机事件和样本空间-and-频率与概率","filePath":"归档/概率论与数理统计/1.随机事件和样本空间 and 频率与概率.md","title":"1.随机事件和样本空间 and 频率与概率","links":[],"tags":[],"content":"1.1 概念\n我们研究随机事件的方式是 随机试验 ,随机试验应该满足以下三个条件\n\n大量可重复性\n结果不唯一\n不可预知性\n\n我们约定用E表示随机试验,将随机试验所有可能的结果构成构成的集合称为样本空间U,例如抛一次硬币的试验E_{1}的样本空间U = \\{H,T\\} 记为正反\n一些概念解释:\n\n随机事件:即样本空间的子集\n基本事件:单个样本点构成的事件\n事件发生: 事件A发生 \\iff A中有样本点出现\n\n1.2事件的运算\n事件的关系:\n\n包含   : A \\subset B 即事件A发生必然导致事件B发生\n和事件 : A \\cup B = \\{x | x \\in A \\text{ or } x \\in B\\}  即A与B至少有一个发生,也可以记为A + B\n交事件 : A \\cap B = \\{x | x \\in A \\text{ and } x \\in B\\} 即A与B同时发生,也记为AB\n\n当 AB = \\varnothing 时候,我们称A与B为互不相容(互斥)事件\n当 AB = \\varnothing \\text{ and } A+B = U 我们称为A,B互为对立事件,记 B = \\overline{A}\n\n\n差事件 : A - B = \\{x | x \\in A \\text{ but } x \\notin B \\} 有公式A - AB = A\\overline{B}\n\n事件的运算:\n\n交事件与并事件均满足交换律和结合律\n交事件与并事件满足结合率\n对偶率: \\overline{A \\cup B} = \\overline{A} \\cap \\overline{B} , \\overline{A \\cap B} = \\overline{A} \\cup \\overline{B}\n\n1.3 频率与概率\n1.3.1频率\n对一个随机试验E,对事件A,在进行n次试验中事件A出现了n_{A}次,则我们称:\nf_{n}(A) = \\frac{n_{A}}{n}\n为A的频率\n性质:\n\n0 \\leq f_{n}(A) \\leq 1\nf_{n}(U) = 1\n若A_{1},A_{2} \\cdots A_{n} 两两互不相容,则有:f_{n}(A_{1}+A_{2}+ \\cdots A_{n}) = \\frac{n_{a_{1}} + n_{a_{2}} \\cdots + n_{a_{n}}}{n} = f_n(A_{1}) + f_{n}(A_{2})+\\cdots f_{n}(A_{n})\n\n1.3.2概率\n定义:对一个E,U,A ,约定 P(A) \\in \\mathbf{R} 满足:\n\nP(A) \\geq 0  非负\nP(U) = 1  规范\n若 A_{1},A_{2} \\cdots A_{n} 两两互不相容,有 P(A_{1}) + P(A_{2})+\\cdots +P(A_{n}) = P(A_{1}+A_{2} + \\cdots A_{n})\n\n性质:\n\nP(\\varnothing) = 0\n若 A_{1},A_{2} \\cdots A_{n} 两两互不相容,有 P(A_{1}) + P(A_{2})+\\cdots +P(A_{n}) = P(A_{1}+A_{2} + \\cdots A_{n})\n若 A \\subset B 则 P(B-A) = P(B) - P(A)\n\npoof : \\begin{align*}B &amp;= A \\cup (B - A) \\\\ P(B) &amp;= P(A+(B-A)) \\\\ &amp;= P(A) + P(B-A)\\end{align*}\n\n\n\\forall A,B\\quad P(B-A) = P(B - AB) = P(B) - P(AB)\nA \\subset U \\Rightarrow P(A) \\leq P(U) = 1\n\\forall A \\quad P(\\overline{A}) = 1 - P(A)\nP(A + B) = P(A) + P(B) - P(AB) 容斥原理\n"},"归档/概率论与数理统计/2.古典概型":{"slug":"归档/概率论与数理统计/2.古典概型","filePath":"归档/概率论与数理统计/2.古典概型.md","title":"2.古典概型","links":[],"tags":[],"content":"2.1 古典概型\n我们称古典概型 E 满足:\n\nU = \\{e_1,e_{2}\\cdots e_n\\}\nP(e_{1})=P(e_{2}) = \\cdots =  P(e_{n}) 即每个事件发生的概率相等\n\n对于事件 A 满足 A = \\{e_{i1},e_{i2}\\cdots e_{ik}\\} ,则 P(A) = P(e_{i1}) + P(e_{i2)}\\cdots +P(e_{nk}) = \\frac{k}{n}\n2.1.1 一些例子\n\n一个产品中,有a个正品和b个仿品,求连续抽2次抽到正品或者仿品的概率\n\nP(\\text{抽到正品}) = \\frac{C(a,2)}{C(a+b,2)}\r\nP(\\text{抽到仿品}) = \\frac{C(b,2)}{C(a+b,2)}\n\n"},"归档/概率论与数理统计/3.条件概率":{"slug":"归档/概率论与数理统计/3.条件概率","filePath":"归档/概率论与数理统计/3.条件概率.md","title":"3.条件概率","links":[],"tags":[],"content":"3.1条件概率\n\n引例: 在0到9任取一个数\n\n已知取得的数 k &gt; 4 ,求取得奇数的概率\n\n\n我们可以猜出: P(ans) = \\frac{3}{5}\n给出A,B两个事件,P(B) &gt; 0\n\n给出条件概率P(A|B)称为条件概率,其中B是先发生的概率,A是后发生的概率\n\n\n\n                  \n                  Important\n                  \n                \n\n\nP(A|B) = \\frac{P(AB)}{P(A)}\n\n\n\n性质:\n\nP(U|A) = 1\n设A_{1},A_{2}\\cdots A_{n} 两两互不相容,则\n\nP(A_{1}+A_{2}+\\cdots A_{n} | B) = P(A_{1}|B) + P(A_{2}|B) + \\cdots P(A_{n}|B)\n\nP(\\varnothing|B) = 0\nP(\\overline{A} | B) = 1-P(A|B)\nP(A_1+A_{2}|B)= P(A_{1}|B) + P(A_{2}|B) -P(A_{1}A_{2}|B)\n\n\n例: 在一个盒子中有8个红球,5个白球,求在第二次取到红球概率\n\n设A表示取到红球的概率，B表示第二次取到红球的概率，C表示第一次取到白球的概率\n则有\nP(B) =P(AB) + P(BC) =  P(A)P(B|A) + P(C)P(B|C) =\\frac{8}{13}\\cdot \\frac{7}{12} + \\frac{5}{13}\\cdot\\frac{8}{12}\n3.2 乘法定理\n\n设P(B) &gt; 0 有 P(AB) = P(B)P(A|B)\n设P(A) &gt; 0 有 P(AB) = P(A)P(B|A)\n设P(AB) &gt; 0 有 P(ABC) = P(A)P(B|A)P(C|AB)\n\n3.3 全概率公式与贝叶斯公式\n\n\n                  \n                  定义 \n                  \n                \n\n\n对E 与全样本空间U 有 [B_{1}\\cdots B_{n}]事件\n\n若对任意i,j有B_{i}B_{j} = \\varnothing\n\\bigcup_{i = 1}^{n}B_{i}= U\n\n\n\n\n我们称满足上面的所有B为U的 分割\n\n全概率公式\n定义:\n对于E,U 有 B_{1}\\cdots B_{n} 的一个分割 P(B_{i}) &gt; 0, A为任意事件,有\nP(A) = P(B_{1})P(A|B_{1}) + P(B_{2})P(A|B_{2}) + \\cdots + P(B_{n})P(A|B_{n})\n贝叶斯公式\n定义:\n对于E,U 有 B_{1}\\cdots B_{n} 的一个分割 P(B_{i}) &gt; 0, A为任意事件P(A) &gt; 0,有\nP(B_{i}|A) = \\frac{P(AB_{i})}{P(A)} = \\frac{P(B_i)P(A|B_{i})}{\\sum\\limits_{j=1}^{n}P(B_{j})P(A|B_{j})}"},"归档/概率论与数理统计/4.事件的独立性":{"slug":"归档/概率论与数理统计/4.事件的独立性","filePath":"归档/概率论与数理统计/4.事件的独立性.md","title":"4.事件的独立性","links":[],"tags":[],"content":"\n定义:\n若P(AB) = P(A)P(B)则称AB 相互独立\n\n\n\n                  \n                  Tip\n                  \n                \n\n\n\n若{A,B},{\\overline{A}B},{A\\overline{B}},{\\overline{A}\\ \\overline{B}}中有一组互相独立,则其余三组都互相独立\n若P(A) = 1 \\text{ or } 0 ,则对任意B,AB独立\n若P(A) &gt; 0 \\text{ and }P(B) &gt; 0,则AB互不相容与AB独立不能同时出现\n\n\n\n\n三事件互相独立\n若ABC两两独立且P(ABC) = P(A)P(B)P(C) ,则称ABC相互独立\n性质\n\n若AB独立,则P(A) = P(A|B)\n\n"},"归档/概率论与数理统计/5.随机变量":{"slug":"归档/概率论与数理统计/5.随机变量","filePath":"归档/概率论与数理统计/5.随机变量.md","title":"5.随机变量","links":[],"tags":[],"content":"随机变量的概念\n\n定义1:有一个随机事件 E 与样本空间 U = \\{e\\} 若对 \\forall e \\in U 都有唯一实数x(e)与之对应,称 x(e) 为随机变量,简写为X\n我们规定符号随机变量:X,Y,Z,X_{i}\n\n实数规定为: x,y,z,x_{i}\n\n\n随机变量可以被如下划分\n\n\\text{随机变量}\r\n\\begin{cases}\r\n\\text{离散型} \\\\\r\n\\\\ \\\\\r\n\\text{非离散型}\r\n\\begin{cases}\r\n\\text{连续型} \\\\\r\n\\text{其他}\r\n\\end{cases}\r\n\\end{cases}\n离散型随机变量\n\n若随机变量X的取值是有限个或者无限可列个,则称X为离散型随机变量\n设X的所有可能取值为X = x_{k} \\ (k \\in \\mathbb{Z^+}) 且P\\{X = x_{k}\\} = P_{k} \\tag{1}\n我们称(1)式为X的分布律\n\n我们可以为分布律列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nXx_{1}x_2x_3Pp_1p_2p_2\n性质:\n\nP_{k}\\geq 0\n\\sum\\limits P_{k} = 1\n\n三种常见的离散型随机变量分布\n\nX \\sim (0,1)分布\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX01P1 - pp\n\n伯努利分布(二项分部) X \\sim B(n,p)\n\n伯努利实验: E的结果只有两种情况 A,\\overline{A}\r\nn重伯努利实验: 独立重复的进行 n 次实验,P(A) = p\n伯努利实验概率分布\nP\\{X = k\\} &amp;= C^{k}_{n}p^{k}(1-p)^{n-k} \r\n\\end{align*}$$\r\n\r\n3. 泊松分布 $X \\sim P(\\lambda)$ \r\n\r\n$P\\{X = k\\} = \\frac{\\lambda e^{-\\lambda}}{k!}\\ (\\lambda &gt; 0,k \\in \\mathbb{Z^+})$ \r\n\r\n\r\n### 泊松定理\r\n\r\n设 $X \\sim B(n,p)$,当 $n \\to \\infty,p \\to 0$ 时候,令 $np = \\lambda$,则有\nP{X = k} \\approx \\frac{\\lambda e^{-\\lambda}}{k!}\n"},"归档/概率论与数理统计/6.连续型随机变量":{"slug":"归档/概率论与数理统计/6.连续型随机变量","filePath":"归档/概率论与数理统计/6.连续型随机变量.md","title":"6.连续型随机变量","links":[],"tags":[],"content":"定义与概率密度\n对于随机变量X,若存在非负可积函数 f(x),\\, x\\in \\mathbb{R}\n对于任意a,b \\in \\mathbb{R},(a &lt; b),\\Longrightarrow P(a &lt; X \\leq b) = \\int_{a}^{b}f(x)\\mathrm{d}x\n称X为连续型变量， f(x) 称为X的概率密度函数，求在区间L,R 的概率就是求这个区间的积分\n性质：\n\nf(x) \\geq 0\n\\int^{\\infty}_{\\infty}f(x) = 1\n\n分布函数\n定义2：\n\n随机变量X(离散型，连续型)，x \\in \\mathbb{R}\n称F(x) = P\\{X \\leq x\\}为X的分布函数\n\n性质：\n\n\\forall a,b \\in \\mathbb{R},(a&lt;b) 则 P(a &lt; X \\leq b) = F(b) - F(a)\nF(x)单调不减\n0 \\leq F(x) \\leq 1\n\\underset{x\\to-\\infty}\\lim F(x) = 0,\\underset{x\\to\\infty}\\lim F(x) = 1\n分布函数是右连续的，即 \\underset{x\\to x^{+}}\\lim F(x) = F(x_0)\n\n对于离散型：\nF(x) = \\sum\\limits_{k = 0}^{n}p_{k}\n对于连续型：\nF(x) = \\int_{-\\infty}^{x} f(t)\\mathrm{d}t\n其中f(t)为密度函数\n同时，我们也有F&#039;(x) = f(x) 即分布函数求导可以得到密度函数，在连续性中 P\\{X = a\\} = 0\n均匀分布\n均匀分布X\\sim U(a,b)\n有密度函数f(x)\nf(x) = \r\n\\begin{cases}\r\n\\frac{1}{b-a} \\quad a&lt;x &lt;b \\\\\r\n \\\\\r\n0 \\qquad \\text{other}\r\n\\end{cases}\n分布函数F(x)\nF(x) = \\begin{cases}\r\n0 \\quad \\ \\quad x \\leq a \r\n\\\\\\\\\r\n\\frac{x-a}{b-a} \\quad a &lt; x &lt; b\r\n \\\\\\\\\r\n1 \\qquad\\ x \\geq b\r\n\\end{cases}\n指数分布\nX \\sim E(\\theta)：\n密度表达式\nf(x) = \\begin{cases}\r\n\\frac{1}{\\theta} e^{\\frac{-x}{\\theta}}\\  \\quad x &gt; 0 \\\\\r\n \\\\\r\n0 \\qquad \\quad x \\leq 0\r\n\\end{cases}\n分布函数\nF(x) = \\begin{cases}\r\n 1 - e^{\\frac{-x}{\\theta}}\\ \\quad x&gt; 0 \\\\\r\n \\\\\r\n0 \\qquad \\qquad x \\leq 0\r\n\\end{cases}\n\n会常在无记忆性的 “电子元器件使用” 中出现\n\n正态分布\nX \\sim N(\\mu,\\sigma^{2})\nf(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x - \\mu)^{2}}{2\\sigma}} \\quad x\\in \\mathbb{R}\n特别的，当X \\sim N(0,1)时候我们说概率分布服从标准正态分布"},"归档/概率论与数理统计/7.二维随机变量":{"slug":"归档/概率论与数理统计/7.二维随机变量","filePath":"归档/概率论与数理统计/7.二维随机变量.md","title":"7.二维随机变量","links":[],"tags":[],"content":"二维随机变量\n对一个随机事件 E,U = \\{e\\}\\quad \\forall e \\in U,X(e),Y(e) \\in \\mathbb{R}\n\n[!二维随机变量的分布函数]\r\n(X,Y)\\quad \\forall x,y \\in \\mathbb{R}\n有\nF(x,y) = P\\{(X \\leq x) \\cap (Y \\leq y)\\}\n\n我们不难看出，这个函数是在点(x,y)左下角的面积区域\n性质\n\n固定某一个变量时候，F(x,y)是单调不减的\n0 \\leq F(x,y) \\leq 1\n\\lim_{x,y\\to+\\infty}F(x,y) = 1\nF(-\\infty,-\\infty) = F(-\\infty,y) = F(x,-\\infty) = 0 \n\n二维离散型\n定义: 若(X,Y)的所有可能的取值是有限对或无限可列\n则称(X,Y)为二维离散型随机变量\n(X,Y) 的随机取值为 (x_{i},y_{j})\\quad (i,j) \\in S\\{\\mathbb{Z},\\mathbb{Z}\\}\n则我们称P\\{X=x_{i},Y = y_{j}\\} = p_{ij}"},"归档/计算机组成原理/指令系统":{"slug":"归档/计算机组成原理/指令系统","filePath":"归档/计算机组成原理/指令系统.md","title":"指令系统","links":[],"tags":[],"content":""},"归档/计算机组成原理/课上笔记/0.前言":{"slug":"归档/计算机组成原理/课上笔记/0.前言","filePath":"归档/计算机组成原理/课上笔记/0.前言.md","title":"0.前言","links":[],"tags":[],"content":"课程基本内容\n计算机主要原理主要是学习计算机各个内容之间的组织结构,功能,以及其互联的计算机系统\n成绩组成:\n\n10%平时作业 + 10%大作业\n10%实验\n10%学习表现\n60%期末考试\n3.5学分\n"},"归档/计算机组成原理/课上笔记/1.计算机系统概括":{"slug":"归档/计算机组成原理/课上笔记/1.计算机系统概括","filePath":"归档/计算机组成原理/课上笔记/1.计算机系统概括.md","title":"1.计算机系统概括","links":[],"tags":[],"content":"1.1 计算机软硬件概念\n计算机由软件和硬件构成\n\n硬件:计算机的实体\n软件:系统软件和应用软件\n\n1.2 计算机的”解题”过程\n计算机执行指令一般按照如下程序进行:\n\n高级语言编写\n编译器的编译\n机器码的转化\n计算机”解题”\n\n1.2.1 计算机系统的层次结构\n从汇编语言 到 机器语言过程中,汇编会在一个虚拟机器M_{2}中被机器识别转化为2进制的机器码,此时机器码(机器语言)会指示实际机器M_{1}进一步操作.从这种角度上看,汇编语言其实是一种助记语言,其直接对应机器语言\n在效率上,汇编的效率会比普通的程序更加底层从而能让程序员做出更效率的程序语句,在实际项目中如FFmpeg就使用了汇编加速了视频编码\n在机器语言之下还存在一个微指令系统m_{0},这个系统会读取机器码并且生成微指令进而让CPU进行\n1.3 计算机的基本组成\n1.3.1 冯诺依曼结构的特点\n\n计算机由五大部件构成\n指令和数据以同等地位存于存储器,按照地址寻址\n指令和数据用二进制表示\n指令由操作码和地址码组成\n存储程序\n以运算器为核心 目前向存储器倾斜\n\n冯式结构的组成\n\nIO(输入输出)\n控制器 CU(Conturol Unit)\n存储器\n运算器 ALU(Arithmetic Logic Unit)\n\n\nALU + CU 在现代被合称为CPU(Central Processing Unit)\n\n对于存储器而言,其可以分为主存和辅存,在现代CPU中我们将其称为内存和硬盘\n\n存储器的基本组成:\n\n\n存储体 : 表示存储单元,是基本存储的地方\nMAR    : 存储器地址寄存器\n\n反应存储单元的个数\n\n\nMDR    : 存储器数据寄存器\n\n反应存储字长\n\n\n\n\n控制器的基本组成\n\n\\text{完成一条指令}\r\n\\begin{cases}\r\n \\text{取指令} \\qquad \\quad PC \\\\\r\n\\text{分析指令} \\qquad IR     \\\\\r\n\\text{执行指令}\\qquad CU\r\n\\end{cases}\n\nProgramming Counter(PC) 程序计数器\n\n存放当前欲执行指令的地址,具有计数功能 (PC + 1) \\to PC\n\n\nInstruction Register(IR) 指令寄存器\n\n存放当前欲执行的指令\n\n\nCounter Unit(CU) 控制单元\n\n\nCPU进行一次一次取数指令进行的操作\n\n\n1.4 计算机的工作步骤\n1.4.1 上机前的准备\n在上机经常运算之前,我们一般都会进行如下工作\n\n确定数学原理\n选取数学方法\n编写程序\n\n\n好困,这种课真的有人能够坚持下去吗\n\n1.5 计算机硬件的主要技术指标\n\n机器字长: CPU 一次能够处理的位数\n运行速度\n\n主频\n吉普森法\nMIPS:每秒执行百万条指令\nCPI:执行一条指令所需要的时钟周期\nFLOPS:每秒浮点运算次数\n\n\n存储容量\n\n主存容量 RAM → 内存\n辅存容量 ROM → 硬盘\n\n\n"},"归档/计算机组成原理/课上笔记/2.计算机的发展及应用":{"slug":"归档/计算机组成原理/课上笔记/2.计算机的发展及应用","filePath":"归档/计算机组成原理/课上笔记/2.计算机的发展及应用.md","title":"2.计算机的发展及应用","links":[],"tags":[],"content":"\n这一节的内容不是很重要,我们选择跳过\n"},"归档/计算机组成原理/课上笔记/3.系统总线":{"slug":"归档/计算机组成原理/课上笔记/3.系统总线","filePath":"归档/计算机组成原理/课上笔记/3.系统总线.md","title":"3.系统总线","links":[],"tags":[],"content":"3.1总线的基本概念\n3.1.1什么是总线\n总线是链接各个部件的连接线,是各个介质共享的连接线\n3.1.2 总线的分类\n\n片内总线\n\n指芯片内部的总线\n\n系统总线\n\n系统总线是计算机各个部件之间的信息传输线\n\n数据总线: 双向 与机器字长,存储字长有关系\n地址总线: 单向 与储存地址,I/O地址有关\n控制总线: 有出有入\n\n\n通信总线\n\n用于 计算机系统之间 或 计算机系统与其他系统之间的通信\n\\text{传输方式}\r\n\\begin{cases}\r\n\\text{串行通信总线} \\\\\r\n\\text{并行通信总线}\r\n\\end{cases}\n1.3.3"},"归档/计算机组成原理/课上笔记/4.数据的表示":{"slug":"归档/计算机组成原理/课上笔记/4.数据的表示","filePath":"归档/计算机组成原理/课上笔记/4.数据的表示.md","title":"4.数据的表示","links":[],"tags":[],"content":""},"归档/高数历年试卷":{"slug":"归档/高数历年试卷","filePath":"归档/高数历年试卷.md","title":"高数历年试卷","links":[],"tags":[],"content":"哈尔滨理工大学 2023-2024 学年第二学期高等数学期末考试试题 A卷\n一、选择题（1-5小题，每小题4分，共20分）\n\n\n曲线x = t, y = 2t, z = t^2在点(1, 2, 1)处的切线方程为（ ）\n(A)\\frac{x-1}{1} = \\frac{y-2}{2} = \\frac{z-1}{2}\n(B)\\frac{x-1}{1} = \\frac{y-2}{2} = \\frac{z-1}{3}\n(C)\\frac{x-1}{1} = \\frac{y-2}{2} = \\frac{z-1}{1}\n(D)\\frac{x-1}{1} = \\frac{y-2}{2} = \\frac{z}{1}\n\n\n设区域\\Omega为0 \\leq z \\leq \\sqrt{1 - x^2 - y^2}，则\\iiint_\\Omega [y(x^2 + z^2) + 6] \\, dx\\,dy\\,dz =（）\n(A)2\\pi\n(B)4\\pi\n(C)6\\pi\n(D)12\\pi\n\n\n级数\\sum_{n=1}^\\infty \\frac{5^n}{n^{2}} x^n的收敛域为（ ）\n(A)(-\\frac{1}{5},\\frac{1}{5})\n(B)(- \\frac{1}{5}, \\frac{1}{5}]\n(C)[-\\frac{1}{5},\\frac{1}{5}]\n(D)[-\\frac{1}{5},\\frac{1}{5})\n\n\n设\\Omega为平面x + y + z = 1与三个坐标面围成的闭区域，则\\iiint_\\Omega y \\, dx\\,dy\\,dz =（ ）\n(A)\\frac{1}{24}\n(B)2\n(C)24\n(D)\\frac{1}{2}\n\n\n可降阶微分方程y&#039;&#039;&#039; = e^x的通解为（ ）\n(A)y = e^x + C_1 x + C_2\n(B)y = e^x + C_1 x^2 + C_2\n(C)y = C_1 e^x + C_1 x^2 + C_3\n(D)y = e^x + C_1 x^2 + C_2 x + C_3\n\n\n\n二、填空题（6-10小题，每小题4分，共20分）\n\n\n过点M(1, -3, 2)且垂直于直线\\frac{x+2}{1} = \\frac{y+3}{2} = \\frac{z-2}{3}的平面方程为\n\n\n若曲线积分\\int_L (\\arctan x + 2xy) \\, dx + (kx^2 + \\sin y) \\, dy在单连通区域G内与路径无关，则k =\n\n\n函数f(x) = \\frac{\\mathrm{d}}{\\mathrm{d}x}(e^{x^{2}}-1)在x = 0处展开成幂级数为\n\n\n曲线积分\\oint_L (|x| + |y|) \\, ds，其中L: |x| + |y| = 1，结果为\n\n\n已知f(x)是以2\\pi为周期的周期函数，且\n\n\n    f(x) = \n    \\begin{cases} \n    x + \\pi, &amp; -\\pi \\leq x &lt; 0 \\\\\n    \\pi - x, &amp; 0 \\leq x &lt; \\pi \n    \\end{cases}\n设其傅里叶级数的和函数为$S(x)$，则$S\\left(\\frac{9\\pi}{2}\\right) + S(0) =$\n\n\n三、计算解答题（11-16小题，每小题8分，共48分）\n\n\n设向量\\vec{a} = \\{1, 2, 1\\},\\vec{b} = \\{k, 1, 3\\}，且\\vec{a} \\cdot \\vec{b} = 5，求k和\\vec{a} \\times \\vec{b}。\n\n\n设z = u^2 + v^2,u = x + y,v = 2x - 4y，求\\frac{\\partial z}{\\partial x},\\frac{\\partial z}{\\partial y},dz。\n\n\n计算二重积分\\iint_D xy \\, dx\\,dy，其中D由直线y = 2,x = 2,y = 2x围成的有界闭区域。\n\n\n设L为y = \\sin x上从点O(0, 0)到点M(\\pi, 0)的一段弧，计算曲线积分：\n\n\n\\int_L (x + 3y) \\, dx + (y^2 - x) \\, dy\n\n\n求一阶线性微分方程\\frac{dy}{dx} - y = 3e^x，初始条件y|_{x=0} = 1的解。\n\n\n求二阶常系数微分方程y&#039;&#039; - 3y&#039; + 2y = 6的通解。\n\n\n\n四、综合题（17小题，8分）\n\n某工厂要用钢板制作一个容积为a^3立方米的无盖长方体容器，若不计钢板厚度，当长、宽和高各取何尺寸时，才能使制作材料最省？\n\n\n五、证明题（18小题，4分）\n\n证明：级数\\sum_{n=1}^\\infty (-1)^n \\frac{n + 2024}{n(n+1)} \\cos\\left(\\frac{n\\pi}{3}\\right)绝对收敛。\n\n哈尔滨理工大学 2023-2024 学年第二学期高等数学期末考试试题 B卷\n一、选择题（1-5小题，每小题4分，共20分）\n\n\n向量\\vec{a} = (2,1,1)，\\vec{b} = (1,0,1)，则\\text{Prj}_{\\vec{b}} \\vec{a} =（ ）\n(A)2\n(B)2\\sqrt{2}\n(C)\\frac{2}{3}\n(D)3\n\n\n设闭区域\\Omega由0 \\leq z \\leq \\sqrt{1 - x^2 - y^2}确定，则\\iiint_\\Omega 2 \\, dx\\,dy\\,dz =（ ）\n(A)2\\pi\n(B)\\frac{4\\pi}{3}\n(C){6\\pi}\n(D)12\\pi\n\n\n级数\\sum_{n=1}^\\infty \\frac{x^n}{3^n \\cdot 3^{n}} x^n的收敛半径为（ ）\n(A)\\frac{1}{3}\n(B)3\n(C)6\n(D)\\frac{1}{6}\n\n\n设\\Omega为平面x + y + z = 1与三个坐标面围成的有界闭区域，则\\iiint_\\Omega x \\, dx\\,dy\\,dz =（ ）\n(A)\\frac{1}{24}\n(B)2\n(C)24\n(D)\\frac{1}{2}\n\n\n可降阶微分方程y&#039;&#039;&#039; = x的通解为（ ）\n(A)y = \\frac{1}{24}x^4 + C_1x^2 + C_2x + C_3\n(B)y = \\frac{1}{6}x^4 + C_1x^2 + C_2x + C_3\n(C)y = C_1x^2 + C_2x + C_3\n(D)y = C_1x^3 + C_2x^2 + C_3x + C_4\n\n\n\n二、填空题（6-10小题，每小题4分，共20分）\n\n\n过点M(1, -3, 2)和N(1, 1, 1)的直线方程为\n\n\n若正项级数\\sum_{n=1}^\\infty \\frac{1}{n^p}收敛，则常数p的取值范围为\n\n\n曲线积分\\oint_L (x^2 + y^2) \\, ds，其中L为圆周x^2 + y^2 = 1，结果为\n\n\n设f(x, y, z)在空间闭区域\\Omega = \\{x^2 + y^2 + z^2 \\leq r^2\\}上连续，且f(0,0,0) = 3，则\n\n\n   \\lim_{r \\to 0^+} \\frac{1}{\\frac{4}{3}\\pi r^3} \\iiint_\\Omega f(x,y,z) \\, dx\\,dy\\,dz = \\ ?\n\n设f(x, y) = y^2 + x^2y，则\\frac{\\partial f}{\\partial x} \\bigg|_{x=1, y=1} =\n\n\n三、计算解答题（11-16小题，每小题8分，共48分）\n\n\n设\\vec{a} = (1, 2, 1)，\\vec{b} = (1, 1, 1)，求(\\vec{a} + 2\\vec{b}) \\cdot \\vec{a}和\\vec{a} \\times \\vec{b}。\n\n\n设u = x + y，v = x + yv，z = u^2 + v^2，求\\frac{\\partial z}{\\partial x}，\\frac{\\partial z}{\\partial y}，dz。\n\n\n计算二重积分\\iint_D xy \\, dx\\,dy，其中D由两坐标轴及直线x + y = 1围成的闭区域。\n\n\n设L为正向圆周x^2 + y^2 = 1，利用格林公式计算\n\n\n    \\oint_L (2xy - 4y) \\, dx + x^2 \\, dy\n\n\n求一阶线性微分方程y&#039; - \\frac{y}{x} = xe^x的通解。\n\n\n求二阶常系数微分方程y&#039;&#039; - 3y&#039; + 2y = 12的通解。\n\n\n\n四、综合题（17小题，8分）\n\n某工厂生产两种商品的产量分别为x、y，成本函数为f(x, y) = 12x^2 - 8xy + y^2，在约束条件x + 2y - 4 = 0下求成本的最小值。\n\n\n五、证明题（18小题，4分）\n\n证明：级数\\sum_{n=1}^\\infty \\frac{1}{n^2} \\tan\\left(\\frac{1}{n}\\right)收敛。\n\n哈尔滨理工大学 2022-2023 学年第二学期高等数学期末考试试题 A卷\n一、选择题（1-5小题，每小题4分，共20分）\n\n\n方程y&#039; = e^{y - x^2}，初始条件y(0) = 0的解为（ ）\n(A)e^y = \\frac{x^2}{2} + 1\n(B)e^y = \\frac{x^2}{2} + Ce^x\n(C)e^y - e^x = 2\n(D)e^y = \\frac{x^2}{2} + C\n\n\n设区域D: x^2 + y^2 \\leq 1，则积分\\iint_D (xy + 3)^2 \\, d\\sigma =（ ）\n(A)2\\pi\n(B)\\pi\n(C)2\n(D)0\n\n\n已知直线L过原点，且在平面（过三点P_0(0,0,0)、P_1(2,2,0)、P_2(0,1,-2)）上，与直线L_1: \\frac{x+1}{3} = \\frac{y-1}{2} = \\frac{z}{1}垂直，则直线L的方程为（ ）\n(A)\\frac{x-2}{2} = \\frac{y+3}{-4} = \\frac{z-1}{1}\n(B)\\frac{x}{0} = \\frac{y}{1} = \\frac{z}{-2}\n(C)\\frac{x}{1} = \\frac{y}{2} = \\frac{z}{3}\n(D)\\frac{x+1}{-3} = \\frac{y}{1} = \\frac{z}{2}\n\n\n曲线x = t^2, y = -t^2, z = t^3 + 1在点(1, -1, 2)处的切向量为（ ）\n(A)\\{1, -2, 6\\}\n(B)\\{-1, 2, 6\\}\n(C)\\{2, -1, 6\\}\n(D)\\{1, -2, 6\\}\n\n\n下列曲线积分中，与路径无关的是（ ）\n(A)\\int_L 3x^2y^3 \\, dx + 3x^3y^2 \\, dy\n(B)\\int_L x \\, dy - y \\, dx\n(C)\\int_L x^2y^3 \\, dx + y^2 \\, dy\n(D)\\int_L 3x^2y \\, dx + x^3 \\, dy\n\n\n\n二、填空题（6-10小题，每小题4分，共20分）\n\n\n二阶常系数微分方程y&#039;&#039; - y&#039; - 6y = 0的通解为\n\n\n函数z = x^2 - 3xy + 3y在点(1, 0)处沿方向\\vec{l} = \\{1, 1\\}的方向导数为\n\n\n已知f(x)是以2\\pi为周期的函数，且\n\n\n f(x) = \n \\begin{cases} \n x + 1, &amp; -1 \\leq x &lt; 0 \\\\\n 1 - x, &amp; 0 \\leq x &lt; 1 \n \\end{cases}\n设其傅里叶级数的和函数为s(x)，则s\\left(\\frac{9}{2}\\right) =\n\n\n已知向量\\vec{a}, \\vec{b}满足\\|\\vec{a}\\| = 2, \\|\\vec{b}\\| = 2, \\vec{a} \\cdot \\vec{b} = 2，则\\|\\vec{a} \\times \\vec{b}\\| =\n\n\n设L为下半圆周y = -\\sqrt{1 - x^2}，则\\int_L (x^2 + y^2) \\, ds =\n\n\n\n三、计算解答题（11-16小题，每小题8分，共48分）\n\n\n计算二重积分\\iint_D (x + y)^2 \\, dx\\,dy，其中D是由两坐标轴及直线x + y = 2围成的闭区域。\n\n\n设L为正向圆周x^2 + y^2 = a^2，计算曲线积分：\n\n\n \\oint_L \\frac{(x + y) \\, dx - (x - y) \\, dy}{x^2 + y^2}\n\n\n求一阶线性微分方程y&#039; - 2xy = 4x e^{x^2}的通解。\n\n\n求过点A(1, 2, 1)且垂直于平面\\pi_1: 2x - y + 3z + 1 = 0和平面\\pi_2: x - 2y - 2z + 4 = 0的平面方程。\n\n\n求级数\\sum_{n=1}^\\infty \\frac{(x - 1)^n}{n \\cdot 2^n}的收敛域。\n\n\n计算三重积分\\iiint_\\Omega z^2 \\, dx\\,dy\\,dz，其中\\Omega为单位球体x^2 + y^2 + z^2 \\leq 1。\n\n\n\n四、综合题（17小题，8分）\n\n设长方体的长、宽、高分别为x, y, z，求在约束条件x + y + z = 12下，使得体积V = xyz最大。\n\n\n五、证明题（18小题，4分）\n\n证明：级数\\sum_{n=1}^\\infty (-1)^n \\frac{\\sin\\left(\\frac{n\\pi}{3}\\right)}{n^3}绝对收敛。\n\n哈尔滨理工大学 2022-2023 学年第二学期高等数学期末考试试题 B卷\n一、选择题（1-5小题，每小题4分，共20分）\n\n\n方程y&#039; = e^{y - x}，初始条件y(0) = 0的解为（ ）\n(A)e^y = x + 1\n(B)e^y = \\frac{x^2}{2} + C\n(C)e^y - e^x = 0\n(D)e^y = \\frac{x^2}{2} + C e^x\n\n\n设区域D: x^2 + y^2 \\leq 1，则积分\\iint_D (\\arcsin(xy))^2 \\, d\\sigma =（ ）\n(A)2\\pi\n(B)\\pi\n(C)2\n(D)0\n\n\n若\\lim_{n \\to \\infty} u_n = 0，则级数\\sum_{n=1}^\\infty u_n的敛散性为（ ）\n(A) 绝对收敛\n(B) 发散\n(C) 条件收敛\n(D) 敛散性无法判定\n\n\n曲线x = t, y = -t^2, z = t + 1在点(1, -1, 2)处的切向量为（ ）\n(A)\\{1, 1, 4\\}\n(B)\\{1, 6\\}\n(C)\\{1, -4, 1\\}\n(D)\\{1, -1, 4\\}\n\n\n下列曲线积分中，与路径无关的是（ ）\n(A)\\int_L 3x^2y^3 \\, dx + 3x^3y^2 \\, dy\n(B)\\int_L x \\, dy - y \\, dx\n(C)\\int_L x^2y^2 \\, dx + y^3 \\, dy\n(D)\\int_L \\frac{2x}{y^3} \\, dx + \\frac{3x^2}{y^4} \\, dy\n\n\n\n二、填空题（6-10小题，每小题4分，共20分）\n\n\n二阶常系数微分方程y&#039;&#039; + 3y&#039; - 4y = 0的通解为\n\n\n函数u = x^2yz在点(1, 1, 1)处沿方向\\vec{l} = \\{2, -3, 1\\}的方向导数为\n\n\n已知函数f(x)以2\\pi为周期，且\n\n\n  f(x) = \n  \\begin{cases} \n  x, &amp; -\\pi \\leq x &lt; 0 \\\\\n  0, &amp; 0 \\leq x &lt; \\pi \n  \\end{cases}\n则其傅里叶级数的系数a_0 =\n\n\n向量\\vec{a} = (1, -1, 2)，\\vec{b} = (-1, 4, 2)，则\\vec{a}在\\vec{b}上的投影为\n\n\n设L为圆周x^2 + y^2 = 1上从点(-1, 0)到(1, 0)的上半弧段，则\\int_L 2 \\, ds =\n\n\n\n三、计算解答题（11-16小题，每小题8分，共48分）\n\n\n计算二重积分\\iint_D xy^2 \\, dx\\,dy，其中D是由直线x + 2y = 2与坐标轴围成的闭区域。\n\n\n设L为正向圆周x^2 + y^2 = a^2，计算曲线积分：\n\n\n  \\int_L \\frac{x \\, dy - y \\, dx}{x^2 + y^2}\n\n\n求一阶线性微分方程y&#039; + 3y = e^{2x}的通解。\n\n\n求过点A(1, 1, 3)且垂直于平面\\pi_1: 2x - y + 3z + 1 = 0和平面\\pi_2: x - 2y - z + 4 = 0的平面方程。\n\n\n求级数\\sum_{n=1}^\\infty \\frac{(x - 2)^{2n}}{n \\cdot 2^{2n}}的收敛域。\n\n\n计算三重积分\\iiint_\\Omega z \\, dx\\,dy\\,dz，其中\\Omega由抛物面z = x^2 + y^2与平面z = 1围成。\n\n\n\n四、综合题（17小题，8分）\n\n利用拉格朗日乘数法将正数 12 分成三个正数，使得u = 3x^2yz取得最大值。\n\n\n五、证明题（18小题，4分）\n\n证明：级数\\sum_{n=1}^\\infty \\sin\\left(\\frac{1}{n^2}\\right)收敛。\n"},"杂项/Latex/Latex初学":{"slug":"杂项/Latex/Latex初学","filePath":"杂项/Latex/Latex初学.md","title":"Latex初学","links":[],"tags":[],"content":""},"杂项/Latex/未命名":{"slug":"杂项/Latex/未命名","filePath":"杂项/Latex/未命名.md","title":"未命名","links":[],"tags":[],"content":""},"杂项/SSH":{"slug":"杂项/SSH","filePath":"杂项/SSH.md","title":"SSH","links":[],"tags":[],"content":"ssh是一个命令行远程软件，可以非常方便的将一个设备上的命令行几乎无损的 “移植” 到另外一个设备上，对于ssh而言，我们可以做到两个电脑之间的链接，甚至是电脑到平板上的链接\n\nssh的链接有点类似于远程桌面，但是只会链接命令行和文件，所以对网络要求极低，遇到不稳定的场景也可以稳定链接\n\nssh在win上和linux上均有版本，因为笔者工具链都在wsl上，所以本文以linux(wsl)上的配置来讲述，同时也会演示用vscode来链接ssh\n\n演示的设备为：arch for wsl\nWindows 11 23H2\n\n首先对于一般linux发行版而言，都会内置ssh sever,当然也可以手动下载\nsudo pacman -S openssh\n然后打开sshd服务进程\nsudo systemctl enable sshd.service\n用管理员模式打开pwsh，映射端口\nnetsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=2222 connectaddress=127.0.0.1 connectport=22\n如果你有vps或者公网ip，你可以\nssh User@xxx.xxx.xx -p 2222\n来链接你的shell，这里xxx是ip地址，User是你链接wsl的用户名\n如果你没有vps，可以选择更加廉价的方法来设置\n我们选择frp，内网穿透工具(sakurafrp)\n这里我们需要在frp配置工具中设置一个隧道，其映射端口为 2222 ，记得一定要设置密码\n然后在frp工具的日志界面，会有使用\n&gt;&gt;frp-bus.com:xxxxx&lt;&lt; 连接你的隧道\n这时候在需要链接的电脑浏览器页面输入\nfrp-bus.com:xxxx 来进入你的密码认证界面，此时我们可以回到终端工具来链接ssh\n在终端里，通过输入：ssh -p xxxxx User@frp-bus.com,其中xxxxx是frp给你的端口，User是你链接的用户名\n链接后会让你输入一次密码，这个密码是你链接设备的密码\n对于vscode，我们可以在\n\n位置链接ssh\n对于安卓设备，我们可以用Termux来模拟终端，可以使用\npkg install openssh\n来下载ssh工具并且链接"},"杂项/systemd问题":{"slug":"杂项/systemd问题","filePath":"杂项/systemd问题.md","title":"systemd问题","links":[],"tags":[],"content":"今天在使用 manjaro for wsl 时候本来为了安装数据库系统的数据库管理软件在wsl里,显然对于这种数据库管理软件而言是依靠 serve 服务来运行的,这种运行依靠一个名字叫做 systemd 的服务管理器进行的.其 PID=1\n今天尝试使用 PostgreSQL 时候,在启动服务应该输入\nsudo systemctl start postgersql\n时候报出:\nSystem has not been booted with systemd as init system (PID 1). \nCan&#039;t operate. Failed to connect to system scope bus via local transport: Host is down\n查看PID1发现被 init(Manjaro) 占用\n根据网络大部分教程说明在 \\etc\\wsl.conf 里添加 systemd=true,但事实是在打开后我就发现这玩意已经存在了\n回想在使用这个社区发行版wsl的时候曾经有过使用docker的经历,但是那个时候对于一个docker镜像有cgrub问题. 但是对于 systemd 是可以打开docker的,但是现在什么都打不开了QAQ\n现在正在寻思要不要换一个官方支持的发行版比如arch或者nixos,但我觉得nixos应该没有wsl版本(?)\n\n好吧其实是有的,但是感觉会很麻烦,所以决定换成官方的arch,但是这样所有配置的软件都要搞一遍了呜呜呜\n"},"杂项/正则表达式":{"slug":"杂项/正则表达式","filePath":"杂项/正则表达式.md","title":"正则表达式","links":[],"tags":[],"content":""},"杂项/短路运算符":{"slug":"杂项/短路运算符","filePath":"杂项/短路运算符.md","title":"短路运算符","links":[],"tags":[],"content":"我们可以这样理解短路运算符\n\n短路运算符一般是用于判断的二元运算符\n当二元运算符的前项可以直接决定整个表达式的结果时候，二元运算符就会直接忽略后项\n\n// 在c++中， &amp;&amp; || 是短路运算符\nint check = 0;\nif( 0 &amp;&amp; check++ )\n{\n\t//code\n}\ncout &lt;&lt; check &lt;&lt; &#039; &#039;;\n这时候 check 的输出会是 0\n// 对 || 而言\nint check = 1;\nif( 1 || check-- )\n{\n\t// code\n}\ncout &lt;&lt; check &lt;&lt; &#039; &#039;;\n这时候 check 的输出会是 1"},"模板/笔记属性":{"slug":"模板/笔记属性","filePath":"模板/笔记属性.md","title":"笔记属性","links":[],"tags":[],"content":""},"编程语言/C++/STL/Deque-双向队列":{"slug":"编程语言/C++/STL/Deque-双向队列","filePath":"编程语言/C++/STL/Deque 双向队列.md","title":"Deque 双向队列","links":["tags/STL","tags/容器","tags/队列","编程语言/C++/STL/Vector","编程语言/C++/STL/Queue-队列"],"tags":["STL","容器","队列"],"content":"STL 容器 队列\ndeque 双向队列\n\n作用： deque可以作为一个双向队列，在队首队尾以及任意位置实现元素的插入和删除\n定义： 和*Vector*一致\n有和Queue 队列几乎一样的功能，但双端可操作，是经常\n\n成员函数：\n    push_back()     //在队列的尾部插入元素。\n    emplace_front() //与push_front()的作用一样\n    push_front()    //在队列的头部插入元素。\n    emplace_back()  //与push_back()的作用一样\n    pop_back()      //删除队列尾部的元素。\n    pop_front()     //删除队列头部的元素。\n    back()          //返回队列尾部元素的引用。\n    front()         //返回队列头部元素的引用。\n    clear()         //清空队列中的所有元素。\n    empty()         //判断队列是否为空。\n    size()          //返回队列中元素的个数。\n    begin()         //返回头位置的迭代器\n    end()           //返回尾+1位置的迭代器\n    rbegin()        //返回逆头位置的迭代器\n    rend()          //返回逆尾-1位置的迭代器\n    insert()        //在指定位置插入元素\n    erase()         //在指定位置删除元素"},"编程语言/C++/STL/List-列表":{"slug":"编程语言/C++/STL/List-列表","filePath":"编程语言/C++/STL/List 列表.md","title":"List 列表","links":["tags/STl","tags/容器"],"tags":["STl","容器"],"content":"STl 容器\n1.9 列表list\n构造\nlist&lt;类型&gt; lt\n1.9.1 优势与适用范围\nlist容器插入和删除元素的效率较高，时间复杂度为常数级别,其底层为带头双向循环链表\n1.9.2 常用方法\n\n\n定义:\n\n构造空list() / 含有n个元素的类型容器list / 拷贝某个类型容器的复制品\n\nlist&lt;int&gt; lt1; //构造int类型的空容器\nlist&lt;int&gt; lt2(10,2); //构造含有10个2的int类型容器\nlist&lt;int&gt; lt3(lt2); //拷贝构造int类型的lt2容器的复制品\nlist&lt;int&gt; lt4{ 1,2,3,4,5 };  // 直接使用花括号进行构造---C++11允许\n\n迭代器复制字符内容\n\nstring s(&quot;hello world&quot;);\nlist&lt;char&gt; lt5(s.begin(),s.end()); //构造string对象某段迭代器区间的内容\n\n\n1.9.3 list的遍历及迭代器的操作\n\n迭代器\n正向迭代器\n\nint arr[] = {1,1,4,5,1,4}; //构造数组\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0])); //copy数组到list\nfor(list&lt;int&gt;::iterator it = lt.begin();it != lt.end();++it)\n{\n    cout &lt;&lt; *it &lt;&lt;endl;\n}\n\n反向遍历器(抽象)[防止你不知道]\n\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\nfor(list&lt;int&gt;::reverse_iterator it = lt.rbegin();it != lt.rend();++it)\n{\n    cout &lt;&lt; *it &lt;&lt;endl;\n}\n\n范围for(好用)\n\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n\n\n\n常见容器操作\n\n\n.size():返回容器中有效元素的个数\n\n\n.resize():调整容器的有效元素大小(size)\n\n\n.empty():判断容器是否为空\n\n\n.clear():用于清空容器,清空后容器的size为0, 但是头结点(哨兵位)不会被清除\n\n\n\n\n\n\n\n**.resize(a,b)**有两个参数:\n\na:将list大小变为(a)\nb:若list新大小大于原大小,则新增的大小用b填充\n\n\n\n\n1.9.4 list容器的常见访问操作\n\n.front():访问list头元素[返回list的第一个元素]\n.back():访问list尾元素[返回list的最后一个元素]\n\n1.9.5 list 容器的常见修改操作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数(接口)名称函数(接口)说明.push_front()在list首元素前插入元素.pop_front()删除list首元素.push_back()在list尾部插入元素.pop_back()删除list最后一个元素.insert()在list&lt;int&gt;::iterator it 前插入元素.erase()在list&lt;int&gt;::iterator it 前删除元素.swap()交换两个元素\n\n\n                  \n                  Important\n                  \n                \n\n\n\n\n有关**insert()**的操作:[^7]\n\n\ninsert共有三种形式：\n\ninsert(iterator, value);\ninsert(iterator, num, value);\ninsert(iterator, iterator1, iterator2);\n\n\n\n\ninstert的所有操作都由迭代器位置确定,不存在lt[2]这类的中括号表操作\n\n\n\n对insert(iterator, value);(会返回一个新迭代器指向插入的元素)\n\n\n\n\n\n//创立一个数组\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\ncout &lt;&lt; &quot;befor&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n//创立一个迭代器指向lt的头元素\nlist&lt;int&gt;::iterator it = lt.begin();\n//迭代器向后移动2位,指向4\nadvance(it,2);\n//在4的迭代器前,插入元素3\nauto itnew = lt.insert(it,3);\ncout &lt;&lt; &quot;after&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\ncout &lt;&lt; &quot;new iterator = &quot; &lt;&lt; *itnew &lt;&lt;endl;\nreturn 0;```\n&gt; ![[Pasted image 20250123210215.png]]\n&gt;\n&gt; - 对 `insert(iterator, num, value);`(会返回一个新迭代器指向插入的第一个元素)\n&gt;\n```cpp\n//创立一个数组\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\ncout &lt;&lt; &quot;befor&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n//创立一个迭代器指向lt的头元素\nlist&lt;int&gt;::iterator it = lt.begin();\n//迭代器向后移动2位,指向4\nadvance(it,2);\n//在4的迭代器前,插入元素3个3\nauto itnew = lt.insert(it,3,3);\ncout &lt;&lt; &quot;after&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n//新迭代器的位置在第一个3\ncout &lt;&lt; &quot;new iterator = &quot; &lt;&lt; *itnew &lt;&lt;endl;\nreturn 0;\n\n\n\n\n对 insert(iterator, iterator1, iterator2); \n\n//创立一个数组\nint arr[] = {1,1,4,5,1,4};\nlist&lt;int&gt; lt(arr,arr+sizeof(arr)/sizeof(arr[0]));\ncout &lt;&lt; &quot;befor&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\n//创立一个迭代器指向lt的头元素\nlist&lt;int&gt;::iterator it = lt.begin();\n//迭代器向后移动2位,指向4\nadvance(it,2);\n//建立新的list或(vector);\nvector&lt;int&gt; lt2 = {1,9,1,9,8,1,0};\n//确定迭代器位置\nauto it1 = lt2.begin();\nauto it2 = lt2.end();\n//在4的迭代器前,插入迭代器it1 - it2 这之间的数\n//会返回插入的数的第一个元素的迭代器\nauto itnew  = lt.insert(it,it1,it2);\ncout &lt;&lt; &quot;after&quot; &lt;&lt; endl;\nfor (auto &amp;i : lt)\n{\n    cout &lt;&lt; i &lt;&lt;endl;\n}\ncout &lt;&lt; &quot;new iterator = &quot; &lt;&lt; *itnew;\nreturn 0;\n\n\n\n**.erase()**用法和 **.insert()**差不多,只是从添加元素变为删除元素删除的为迭代器指向的元素或两个迭代器之间(包括本身)的元素\n\n\n1.9.6 list容器常用的操作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数声明接口说明splice将元素从列表转移到其它列表remove删除具有特定值的元素remove_if删除满足条件的元素unique删除重复值sort(慢)容器中的元素排序merge合并排序列表reverse反转元素的顺序\n\n.splice()一共有四种形式\n\nsplice(iterator_pos, otherList) : 将otherList中的所有元素移动到iterator_pos指向元素之前\n\n\n\nlist&lt;int&gt; ls1 ={1,2,3,4,5};\nlist&lt;int&gt; ls2 ={10,20,30,40,50};\nls2.splice(ls1.begin(),ls2); //和ls1.splice(ls1.begin(),ls2); 等价\n \nfor(auto &amp;p : ls1)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}\n//输出 10 20 30 40 50 1 2 3 4 5\n//此时ls2的情况: 空\n\nsplice(iterator_pos, otherList, iter1): 从 otherList转移 iter1 指向的元素到当前list。元素被插入到 iterator_pos指向的元素之前。\n\nlist&lt;int&gt; ls3 ={10,20,30};\nlist&lt;int&gt; ls4 ={3,5,7,8};\nauto it = ls3.begin();\nadvance(it,1);\nls3.splice(it,ls4,ls4.begin());\nfor(auto &amp;p : ls3)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}    \ncout &lt;&lt;endl;\n//ls4\nfor(auto &amp;p : ls4)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}\n//输出:\n//10 3 20 30\n//5 7 8\n\nsplice(iterator_pos, otherList, iter_start, iter_end) : 从 otherList转移范围 [iter_start, iter_end) 中的元素到 当前列表。元素被插入到 iterator_pos指向的元素之前。\n\nlist&lt;int&gt; ls5 ={1,2,3,4,5};\nlist&lt;int&gt; ls6 ={10,20,30,40,50};\nauto it2 = ls6.begin();\nadvance(it2,2); \nauto it3 = ls5.begin();\nauto it4 = ls5.end();\nadvance(it3,1); \nadvance(it4,-2); \nls6.splice(it2,ls5,it3,it4);\nfor(auto &amp;p : ls6)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n//ls5\nfor(auto &amp;p : ls5)\n{\n    cout &lt;&lt; p &lt;&lt; &quot; &quot;;\n}\ncout &lt;&lt; endl;\n//输出: \n// 10 20 2 3 30 40 50 \n// 1 4 5"},"编程语言/C++/STL/Map-映射":{"slug":"编程语言/C++/STL/Map-映射","filePath":"编程语言/C++/STL/Map 映射.md","title":"Map 映射","links":["tags/STL","tags/容器","tags/哈希"],"tags":["STL","容器","哈希"],"content":"STL 容器 哈希\n1.6 映射 map\ninclude &lt;map&gt;\n\n提供对数时间的有序键值对结构[任意类型的映射];\n\nmap&lt;string,int&gt; a;\na[&quot;qaq&quot;] = 1;\na[&quot;abc&quot;] = 2;\na[&quot;mmp&quot;] = 3;\n\nkey[键]:的概念\n\na[key] = value;\nkey 在映射中处于中括号内,表示提示map的元素\n\n性质\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n性质解释mapmultimapunordered_map互异性一个键仅可以在映射中出现一次✔❌（任意次）✔无序性键是没有顺序的❌（从小到大）❌（从小到大）✔\n1.6.1 构造及常用操作\nmap&lt;key,value&gt; mp;\n\n\n增/改:map[0] = 1\n\n\n\n倘若没有定义就直接访问map,就会返回一个初值(默认为0)\n\n\n\n查找元素[找的是 key]:mp.find()\\to返回这个元素的迭代器,若找不到,返回mp.end(尾迭代器)\n\n\n删除: mp.erase(元素)\n\n\n查找[找的是 key]:mp.count()\\to 返回的是元素数量\n\n\n清空判空同上\n\n\n1.6.2 遍历\n\n萌新式遍历[适合&lt;int int&gt;型]\n\nmap&lt;int , int&gt; mp;\nmp[6] = 3;\nmp[5] = 1;\nmp[7] = 3;\nmp[9] = 666;\nfor (size_t i = 0; i &lt; mp.size(); i++)\n{\n    cout &lt;&lt; mp[i] &lt;&lt;endl;\n}\n\n缺点很明显,给个图就明白了\n\n\n\n迭代器式遍历\n\nstring a;\nmap&lt;string , int&gt; mp;\nmp[&quot;aaa&quot;] = 1;\nmp[&quot;bbb&quot;] = 5;\nmp[&quot;tsts&quot;] = 3;\nfor (map&lt;string , int&gt;::iterator it = mp.begin() ;it != mp.end() ; it++)\n{\n    cout &lt;&lt; it-&gt;second &lt;&lt;endl;\n}\n\n这个遍历器指向一个键对,所以得用 it-&gt;first或 it-&gt;second来判断指向的哪一个\n\n\nauto范围遍历\n\nstring a;\nmap&lt;string , int&gt; mp;\nmp[&quot;aaa&quot;] = 1;\nmp[&quot;bbb&quot;] = 5;\nmp[&quot;tsts&quot;] = 3;\nfor(auto &amp;el:mp)\n{\n    cout &lt;&lt; el.first &lt;&lt; &quot; &quot; &lt;&lt;el.second&lt;&lt;endl;\n}\n1.6.3 适用范围\n\n维护特殊的映射[string \\to int]\n\n\n统计输入的字符串组中每个字符串出现的次数\n\nmap&lt;string ,int&gt; mp;\nvector&lt;string&gt; vec;\nvec.push_back(&quot;aqa&quot;);\nvec.push_back(&quot;aqa&quot;);\nvec.push_back(&quot;qaq&quot;);\nvec.push_back(&quot;qaq&quot;);\nvec.push_back(&quot;wqw&quot;);\nvec.push_back(&quot;aqa&quot;);\nvec.push_back(&quot;qaq&quot;);\n \nfor (size_t i = 0; i &lt; vec.size(); i++)\n{\n    mp[vec[i]]++;\n}\nfor (auto &amp;el : mp)\n{\n    cout &lt;&lt; el.first &lt;&lt; &quot; &quot; &lt;&lt;el.second&lt;&lt;endl;\n}\n\n\n效果如此\n\n1.6.4 注意事项\n\n空map会返回一个默认值\n不能使用遍历器找下标\n\n\nunordered_map无序map 也称哈希表，我们可以随意的建立映射关系，时间复杂度是O(1)\n"},"编程语言/C++/STL/Pair-二元组":{"slug":"编程语言/C++/STL/Pair-二元组","filePath":"编程语言/C++/STL/Pair 二元组.md","title":"Pair 二元组","links":["tags/STL","tags/容器","编程语言/C++/STL/Map-映射","编程语言/C++/STL/Vector"],"tags":["STL","容器"],"content":"STL 容器\n1.8 二元组 pair\n构造\npair&lt;int, int&gt; pr;\n1.8.1 常用方法\n\n\n赋初值: pair&lt;int , int&gt; pr = {1,2}\n\n\n老式: pair&lt;int , int&gt; pr2 = make_pair(1,2)\n\n\n判同 : pr == pr2\n\n\n三元组曲线救国法:pair&lt;pair&lt;int,char&gt;,char&gt; p3;\n\n\n访问第一个值 .first\n\n\n访问第二个值 .second\n\n\n1.8.2 适用范围\n适用于所有需要二元组的场景,效率和自己定义结构体差不多\n1.8.3 临时拆分二元组\n我们可以使用语法 auto [f,s] = pr来将pair的两个元素起到临时拆分的作用，同时在范围for循环里也可以使用这个对由pair构成的容器进行拆分\n\n下面罗列一些我清楚的\nMap 映射 Vector构成的pair数组\n\nfor(auto &amp;&amp;[a,b] : mp){\n\t/*\n\t对 a 和 b 的操作\n\t*/\n}\n\n\n                  \n                   \n对 auto 拆分的pair而言，[a,b]内 a代表 .first b代表 .second ,而对于 map而言，a代表 key ， b代表值\n                  \n                \n"},"编程语言/C++/STL/Priority_queue-优先队列":{"slug":"编程语言/C++/STL/Priority_queue-优先队列","filePath":"编程语言/C++/STL/Priority_queue 优先队列.md","title":"Priority_queue 优先队列","links":["tags/STL","tags/队列"],"tags":["STL","队列"],"content":"STL 队列\n1.4 优先队列(堆) priority_queue\ninclude &lt;queue&gt;\n1.4.1 构造\npriority_queue&lt;类型,容器,比较器&gt;\n\n类型:要储存的数据类型\n容器:储存数据的底层容器,默认为 vector&lt;T&gt;,竞赛时保存默认即可\n比较器: 比较大小使用的比较器,默认为 less&lt;T&gt;,可以自定义\n\npriority_queue&lt;int&gt; pque1;\npriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pque2;//变小顶堆\n\n自定义比较器尽量不用,容易犯迷糊\n\n1.4.2 常用语法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例进堆.push(元素)que.push(1);出堆.pop()que.pop();取堆顶(最大值/最小值).top()int a = que.top();查看大小/判空和vector一致略\n\n\n                  \n                  Note\n                  \n                \n\n\n进出堆复杂度O(\\log n),取堆顶O(1)\n\n\n\n适用场景\n\n保持数据的有序性,每次向队列中插入大小不定的元素,或每次从队列取出最大/最小的元素,元素数量为n,插入操作数量为k\n\n使用快排:k\\cdot n \\log n\n使用优先队列:k\\cdot \\log n\n\n\n\n1.4.3 注意事项\n\n仅堆顶可读\n\ncout &lt;&lt; qpue[1] &lt;&lt;endl; //错误\n\n所有元素不可写\n\nqpue[1] = 2;\npque.top() = 1;\n//均为错误\n但如果要修改堆顶元素\nint tp = pque.top(); //保存堆顶\npque.pop(); //弹出堆顶\nqpue.push(tp + 1); //通过保存的堆顶修改堆顶"},"编程语言/C++/STL/Queue-队列":{"slug":"编程语言/C++/STL/Queue-队列","filePath":"编程语言/C++/STL/Queue 队列.md","title":"Queue 队列","links":["tags/容器","tags/STL","tags/队列","编程语言/C++/STL/Stark-栈","编程语言/C++/STL/Priority_queue-优先队列"],"tags":["容器","STL","队列"],"content":"容器 STL 队列\n1.3 队列 queue\n\nincloud &lt;queue&gt;\n\n通过二次封装双端队列，实现先进先出(双端获取)的数据结构\n1.3.1常用方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例构造queue&lt;类型&gt; quequeue&lt;int&gt; que进队que.push(元素)que.push(1)出队.pop()que.pop()取队首.front()int a = que.front()取队尾.banc()int a = que.back()查看大小.size()int a = que.size()清空.clear()que.clear()判空.empty()que.empty()\n1.3.2 注意事项\n不能访问内部元素! 示例同2.4 写栈的注意事项\n\n有一类特殊的队列容器Priority_queue 优先队列可以做到将队列内的元素以O(\\log n)的速度读入并排序\n"},"编程语言/C++/STL/STL":{"slug":"编程语言/C++/STL/STL","filePath":"编程语言/C++/STL/STL.md","title":"STL","links":["tags/STL","编程语言/C++/STL/迭代器","编程语言/C++/STL/STL算法函数"],"tags":["STL"],"content":"STL\nC++ STL（Standard Template Library，标准模板库）是C++编程语言的一部分，提供了丰富的数据结构和算法，旨在提高代码的复用性和效率。STL由容器、迭代器、算法和函数对象四个主要组件构成。\n\n容器：用于存储和管理一组对象的数据结构，如vector（动态数组）、list（双向链表）、set（有序集合）、map（键值对映射）等。\n迭代器：用于遍历容器中的元素，提供了一种统一的方式访问不同类型的容器。\n**STL算法函数：实现了许多常用的计算任务，如排序、搜索、复制等，这些算法可以独立于具体的容器类型工作。\n函数对象：也称为仿函数，是一种行为类似于函数的对象，可以用作算法的参数，从而实现更灵活的操作。\nSTL的设计理念是泛型编程，通过使用模板技术使得代码更加通用和高效。这种抽象层次的提升不仅简化了编程过程，还促进了代码的模块化和可维护性。\n\n\n优点：更加简短的代码语句，调试方便\n缺点：有些时候用更复杂的方式进行算法实现\n"},"编程语言/C++/STL/STL算法函数":{"slug":"编程语言/C++/STL/STL算法函数","filePath":"编程语言/C++/STL/STL算法函数.md","title":"STL算法函数","links":["tags/STL","tags/函数类"],"tags":["STL","函数类"],"content":"STL 函数类\n6.3 STL函数\n对容器操作类\n\nsort(iterator_begin,iterator_end,cmp) 快速排序\nfind：顺序查找。find(iterator_begin, iterator_end, value)，其中 value 为需要查找的值。\nreverse：翻转数组、字符串。reverse(iterator_begin, iterator_end()) 或 reverse(a + begin, a + end)。\nunique：去除容器中相邻的重复元素。unique(ForwardIterator first, ForwardIterator last)，返回值为指向 去重后 容器结尾的迭代器，原容器大小不变。与 sort 结合使用可以实现完整容器去重。\nmove:  可以高效赋值容器，当你确定某一个容器在后面不需要被使用时可以使用 move来降低时间复杂度，尤其是对vector&lt;pair&lt;int,int&gt;&gt; 这类复杂容器而言\n\n    for(auto &amp;&amp;i : f){\n        set&lt;int&gt; temp = dp;\n        for(auto &amp;&amp;j : dp){\n            temp.emplace(i+j);\n        }\n        dp = move(temp);\n    }\n\n这是一个求一个数组取任意个数个数字相加的板子，其中使用到 move(temp) 就起到了降低时间复杂度的作用\n\n对容器改动类\n\n().emplace()   ().emplace_back()\n\nemplace 是 C++11 引入的标准容器函数，用于直接在容器中构造对象，而不是先创建对象再插入。它适用于几乎所有 STL 容器（如 vector, set, map, deque 等），提供了比 insert 更高效的方式。\n例子：我们可以直接在 set&lt;pair&lt;int,int&gt;&gt; 后插入 (x,y)\n\n\n\n    set&lt;pair&lt;int,int&gt;&gt; st;\n    //传统办法\n    st.insert(make_pair(x,y));\n    //emplace办法\n    st.emplace(x,y);\n\n对 vector而言，emplace_back() 几乎可以完全代替 push_back()  而emplace 则能代替 insert\n\n    vector&lt;pair&lt;int,int&gt;&gt; v\n    v.push_back(make_pair(x,y)) == v.emplace_back(x,y);\n    v.insert(v.begin(), make_paie(x,y)) == v.emplace(v.begin(),x,y)"},"编程语言/C++/STL/Set-集合":{"slug":"编程语言/C++/STL/Set-集合","filePath":"编程语言/C++/STL/Set 集合.md","title":"Set 集合","links":["tags/STL","tags/容器"],"tags":["STL","容器"],"content":"STL 容器\n1.5 集合set\n提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n集合三要素解释setmultisetunordered_set确定性一个元素要么在集合中，要么不在✔✔✔互异性一个元素仅可以在集合中出现一次✔❌（任意次）✔无序性集合中的元素是没有顺序的❌（从小到大）❌（从小到大）✔\n1.5.1 常用操作\n\n\n函数构造 set&lt;类型,比较器&gt;\n\n\n插入元素 st.insert(元素)\n\n\n删除元素 st.erase(元素)\n\n\n查找元素 st.find(元素)\n\n\n查找元素个数 st.count\n\n\n1.5.2 遍历\n可以使用遍历器来遍历set数据:\nset&lt;int&gt; st;\nfor (set&lt;int&gt;::iterator it = st.begin() ; it != st.end();++it )\n{\n    cout &lt;&lt; *it &lt;&lt;endl;\n}\n基于范围的循环:\nfor(auto &amp;ele : st)\n{\n    cout &lt;&lt; ele &lt;&lt; endl;\n}\n1.5.3适用范围\n\n元素的去重 [1,1,2,3,3,5,7] \\to [1,2,3,5,7]\n元素顺序的维护 [1,6,8,4,1] \\to [1,4,6,8]\n元素大小很大但数量很少的情况(大小:[-10^18^,10^18^],数量10^6^)\n\n1.5.4 注意事项\n\nset数据不存在下标的说法,但可以用遍历器找数据:\n\nset&lt;int&gt;::iterator it = st.begin();\nadvance(it,2); //迭代器后面会讲\ncout &lt;&lt; *it &lt;&lt;endl;\n\n元素都是只读的,set迭代器提取的元素都是只读的(因为是const迭代器),不能够修改它的值,需要先erase再inset\n\ncout &lt;&lt; *st.begin() &lt;&lt;endl; //正确\n*st.begin() = 1; //错误,不可写\n\n不可用迭代器计算下标\n\nset 的迭代器不能像 vector 一样相减得到下标。下面是错误用法：\nauto it = st.find(2);      // 正确，返回2所在位置的迭代器。\nint idx = it - st.begin(); // 错误！不可相减得到下标。"},"编程语言/C++/STL/Stark-栈":{"slug":"编程语言/C++/STL/Stark-栈","filePath":"编程语言/C++/STL/Stark 栈.md","title":"Stark 栈","links":["tags/STL","tags/栈","tags/容器","ACM/算法/深度优先搜索-DFS"],"tags":["STL","栈","容器"],"content":"STL 栈 容器\n栈 stack\n头文件：&lt;stark&gt;\n2.1 构造方式\nstack&lt;double&gt; stk[stk是栈名]；\n2.2 进栈与出栈及取栈顶部\n\n进栈：stk.push(x);[将x放入栈中]\n出栈：stk.pop();[栈顶出栈]\n取栈顶：stk.top()[获取栈顶\n\n2.3 用vector模拟stack\n使用dp.back()取栈(容器)顶\n2.4 写栈的注意事项\n\n不能访问栈的内部元素 \n下面都是错误用法\n\nstack&lt;int&gt; stk;\nfor(int i = 1;i &lt; stk.size();i++)\n{\n    cout &lt;&lt; stk[i]&lt;&lt;endl;\n}\nfor(auto ele : stk)\n{\n    cout &lt;&lt; stk &lt;&lt;endl;\n}\n\n2.5 与 vector 相比 stack的优势是什么？\n\nstack效率是高于vector的\nstack的内存占用更低\n在某些算法实现下(如深度优先搜索 DFS)，stack可能是更自然的选择\n"},"编程语言/C++/STL/String-字符串":{"slug":"编程语言/C++/STL/String-字符串","filePath":"编程语言/C++/STL/String 字符串.md","title":"String 字符串","links":["tags/STL","tags/容器","tags/字符串"],"tags":["STL","容器","字符串"],"content":"STL 容器 字符串\n1.7 字符串string\n1.7.1 常用方法\n\n\n构造: string str;\n\n\n输入: cin &gt;&gt; str;\n\n\n输出:cout &lt;&lt; str;\n\n\nstring 的初值构造 string str(100,&#039;0&#039;)\n\n\n赋值 str = &quot;awa&quot;;\n\n\n判断相等 str1 == str2\n\n\n修改字符 str[0] = &quot;a&quot;\n\n\n连接字符串 str1 + str2;\n\n\n字符串尾接 str1 += &quot;awa&quot;;\n\n\n取子串:\n\n\nstring s1 = &quot;123123123&quot;;\ncout &lt;&lt; s1.substr(3) &lt;&lt;endl; //从第三位开始输出到末尾\ncout &lt;&lt; s1.substr(3,4) &lt;&lt;endl; //从第三位输出,输出4位 \n\n查找函数 : find(字串)  \\to 返回字串起始点的下标[若找不到,则会返回一个 string::npos]\n对上面一条：返回的是下标，是size_t类型的数字!\n\n6.1.7.2 string 转化\n\n\nstr \\to int : int x = stoi(str)\n\n\nstr \\to long long : long long x =stoll(str)\n\n\nstr \\to float : stof()\n\n\nstr \\to double : stod()\n\n\nstr \\to long double : stold()\n\n\nint \\to str : string str = to_string(x)\n\n\n6.1.7.3 注意事项\n\n尾接要用 += [使用 str = str + &quot;awa&quot;很慢]\n.substr()方法下,第一个参数传的是字串起点下标,第二个是字串长度\n.find()的实现是暴力枚举,复杂度是O(n^2)\n"},"编程语言/C++/STL/Vector":{"slug":"编程语言/C++/STL/Vector","filePath":"编程语言/C++/STL/Vector.md","title":"Vector","links":["tags/STL","tags/容器","编程语言/C++/STL/Pair-二元组"],"tags":["STL","容器"],"content":"STL 容器\n1 vector\n构造\n一维数组： vector&lt;类别&gt; dp(长度，初值) [^5]\n二维数组：vector&lt;vector&lt;int&gt;&gt; dp(行数,vector&lt;int&gt; (列数,初值)); \n三维数组：\n vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp3(3层,vector&lt;vector&lt;int&gt;&gt;(行数,vector&lt;int&gt; (列数,0)));\n等价于 int mat[][][]\n\n\n                  \n                  Note\n                  \n                \n\n\n我们也可以使用 vector&lt;vector&lt;int&gt;&gt; dp(100,vector&lt;int&gt;())来构建不指定列数的二维数组\n\n\n\n1.1 尾接与尾删\n\n尾接： dp.push_back(x)[解释：在dp数组末尾添加数字x]\n尾删：dp.pop_back(x)[解释：在dp数组末尾删除数字x]\n\n1.2 size函数\n\ndp.size()[解释：获取dp数组的长度(数组内有多少个数)]\n\n1.3清空数组\n\ndp.clear()[清空数组内数据]\n\n1.4 empty函数\n使用dp.empty()判断数组是否为空，空返回true(1)，非空返回false(0)\n一般这个函数会放在if语句中\nif(dp.empty()) //如果数组为空，则执行语句\n{\n    //....\n}\n1.5  resize函数\n\ndp.resize(m,n)[m表示新大小，n表示：如果增加长度，多出来的位置的默认数字]\n注意resize函数改小的话，会将多出来的数据删除\n\n1.6 访问vector的数据\n\n使用dp[x],访问dp数组内x-1的数据\n\n1.7 vector的赋值与读取\n\n一维数组的赋值\n\n\n方法一(推荐)\n\nvector&lt;int&gt; dp(10,0);\nfor(int i = 0;i &lt; k; i++)\n{\n    int temp;\n    cin &gt;&gt; temp;\n    dp.pish_back(temp);\n}\n\n方法二(不推荐)\n\nvector&lt;int&gt; dp(10,0);\nfor(int i = 0;i &lt; k; i++)//k不能大于10(k &gt; 10 也可以读入dp,但是会有诡异的bug)\n{\n    cin &gt;&gt; dp[i];\n}\n\n\n                  \n                  Note\n                  \n                \n\n\n所以动态读写一套下来为：\n\n\n\n&gt; vector&lt;int&gt; dp(0,0);\n&gt; for (size_t i = 0; i &lt; 15; i++)\n&gt; {\n&gt;     int temp;\n&gt;     cin &gt;&gt; temp;\n&gt;     dp.push_back(temp);\n&gt; }\n&gt; \n&gt; for (size_t i = 0; i &lt; dp.size(); i++)\n&gt; {\n&gt;     cout &lt;&lt; dp[i] &lt;&lt;&quot; &quot;;\n&gt; }\n\n二维数组动态读写\n\n\n\n                  \n                  Note\n                  \n                \n\n&gt; vector &lt;vector&lt;int&gt;&gt; dp;\n&gt; vector&lt;int&gt; dp1;\n&gt; for (int i = 0; i &lt;k; i++)    \n&gt; {\n&gt;     for (int j = 0; j &lt;p; j++) //内部数组保存\n&gt;     {\n&gt;         int value;\n&gt;         cin &gt;&gt; value;\n&gt;         v.push_back(dp1); \n&gt;     }\n&gt;     dp.push_back(dp1); //保存dp1的每个元素到dp[i]中\n&gt;     dp1.clear(); //清空dp1内元素\n&gt; }\n&gt; \n&gt; for (int i = 0; i &lt;array.size(); i++)\n&gt; {\n&gt;     for (int j = 0; j &lt; p; j++)\n&gt;     {\n&gt;         cout &lt;&lt;array[i][j];\n&gt;     }\n&gt;     cout&lt;&lt;endl;\n&gt; }\n&gt; return 0;\n\n\n思路：先建立动态二维数组dp和动态临时一维数组dp1\ndp1负责保存单行数据\ndp负责保存dp1保存下来的行数据从而形成多数据\n记得clear dp1的元素\n\n\n1.8 vector的使用情况\n\n\n例：n\\times m 的矩阵，1\\leq n,m\\leq 10^6 且 n\\times m \\leq 10^6\n\n\n普通数组就是 int arr[100010][100010]，直接炸内存(MLE)\n\n\n动态数组就可以 vector&lt;vector&lt;int&gt;&gt; dp(n+10,vector&lt;int&gt; (m+10,0))\n\n\n在读取了m,n后再设立数组，解决了炸内存的尴尬\n\n\n虽然有时候我也会用 int arr[m+10][n+10] 来写数组(好孩子不要学)\n\n\nvector储存在堆空间，不会炸栈\n\n\n1.9 注意事项\n\n提前规定长度\nvector的push_back逻辑是，当超过长度时会消耗时间进行重分配\n\n// 优化前: 522ms\nvector&lt;int&gt; a;\nfor (int i = 0; i &lt; 1e8; i++)\n{\n    a.push_back(i);\n}\n// 优化后: 259ms\nvector&lt;int&gt; a(1e8);\nfor (int i = 0; i &lt; a.size(); i++)\n{\n\ta[i] = i;\n}\n\n小心size_t溢出\n\nvector 获取长度的方法 .size() 返回值类型为 size_t，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 [0,2^{32}).\nvector&lt;int&gt; a(65536);\nlong long a = a.size() * a.size(); // 直接溢出变成0了\n1.10 和其他容器的组合技\n\n和Pair 二元组\n\nvector&lt;pair&lt;int,int&gt;&gt; dp1(10);\npair&lt;int,int&gt; p1;\nfor (size_t i = 0; i &lt; 5; i++)\n{\n    cin &gt;&gt; p1.first &gt;&gt; p1.second;\n    dp1[i] = p1;\n}\nint k;\ncin &gt;&gt; k;\nfor (size_t i = 0; i &lt; dp1.size(); i++)\n{\n    if (k == dp1[i].first)\n    {\n        cout &lt;&lt; dp1[i].second;\n    }\n}\n\n\n                  \n                  Tip\n                  \n                \n\n\n**dp[i]**可以作为一个二元组绑死.first和.second\ndp容器可以起到结构体的作用\n\n\n"},"编程语言/C++/STL/迭代器":{"slug":"编程语言/C++/STL/迭代器","filePath":"编程语言/C++/STL/迭代器.md","title":"迭代器","links":["tags/STL","tags/迭代器"],"tags":["STL","迭代器"],"content":"STL 迭代器\n6.2 迭代器(遍历器)\n\n概念：迭代器是一种检查容器内元素并遍历元素的数据类型，通常用于对C++中各种容器内元素的访问，但不同的容器有不同的迭代器，初学者可以将迭代器理解为指针。\n迭代器可以干嘛？\n\nint main()\n{\n    vector&lt;int&gt; arr;\n    for (size_t i = 0; i &lt; 10; i++)\n    {\n        arr.push_back(i);\n    }\n    for(vector&lt;int&gt;::iterator it = arr.begin(); it != arr.end();it++)\n    {\n        cout &lt;&lt; *it &lt;&lt;endl;\n    }\n \n    return 0;\n}\n\n我们观察上面这个程序，这是它的输出结果\n\n\n\n不难发现，这个数组被遍历输出了\n\nfor(vector&lt;int&gt;::iterator it = arr.begin(); it != arr.end();it++)这一行\nvector&lt;int&gt;::iterator it = arr.begin(); \\to 创立了一个迭代器，vector&lt;int&gt;::iterator表明创立了一个vector迭代器 it是迭代器名称 arr.begin()是数组的头迭代器\n迭代器之间也可以用比较运算符 ==or !=\n迭代器也可以使用自增运算 \\to it++\n\n\n常用容器的迭代器\n\n==vector ——随机访问迭代器==\ndeque——随机访问迭代器\n==list —— 双向迭代器==\nset / multiset——双向迭代器\nmap / multimap——双向迭代器\nstack——不支持迭代器\nqueue——不支持迭代器\n\n下面主要讲解随机访问迭代器 双向迭代器\n\n双向迭代器\n\nvoid text()\n{\n\tlist&lt;int&gt; lst;\n\tfor (int i = 0; i &lt; 10; ++i)\n\t{\n\t\tlst.push_back(i);\n\t}\n\tlist&lt;int&gt;::iterator it;//创建list的迭代器\n\tcout &lt;&lt; &quot;遍历lst并打印: &quot;;\n\tfor (it = lst.begin(); it != lst.end(); ++it)//用 != 比较两个迭代器\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\t}\n\t//此时it=lst.end(),这个位置是最后一个元素的下一个位置，没有存储数据\n\t--it;//等价于it--，回到上一个位置\n\t//it -= 1; //报错,虽然都是-1，但这种方式是随机迭代器才有的功能\n\tcout &lt;&lt; &quot;\\nlst的最后一个元素为：&quot; &lt;&lt; *it &lt;&lt; endl;\n}\n\n随机迭代器\n\nvoid text()\n{\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 10; ++i)\n    {\n        v.push_back(i);\n    }\n    vector&lt;int&gt;::iterator it;\n    for (it = v.begin(); it != v.end(); ++it) //用 != 比较两个迭代器\n    {\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n    for (it = v.begin(); it &lt; v.end(); ++it) //用 &lt; 比较两个迭代器\n    {\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n    it = v.begin();//让迭代器重新指向首个元素的位置\n    while (it &lt; v.end())//间隔一个输出\n    { \n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n        it += 2; // 用 += 移动迭代器\n    }\n    cout &lt;&lt; endl;\n \n    it = v.begin();\n    cout &lt;&lt; it[5] &lt;&lt; endl; //用[]访问\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n\n对vector数组迭代器来说，迭代器可以用 +x来表示，但对双向迭代器如list，上述操作就不可取，可以用下面函数的方法来移动迭代器\n\n\n\n\n迭代器的辅助函数\nSTL 中有用于操作迭代器的三个函数模板，它们是：\n\n\nadvance(it, n)；使迭代器 it 向前或向后移动 n 个元素。\n\n\ndistance(it1, it2)；计算两个迭代器之间的距离，即迭代器 it1 经过多少次 + + 操作后和迭代器 it2相等。如果调用时 it1 已经指向 it2 的后面，则这个函数会陷入死循环。\n\n\niter_swap(it1, it2)；用于交换两个迭代器 it1、it2 指向的值。\n要使用上述模板，需要包含头文件\n\n\n#include&lt;algorithm&gt;"},"编程语言/C++/基础语法/C++语言入门":{"slug":"编程语言/C++/基础语法/C++语言入门","filePath":"编程语言/C++/基础语法/C++语言入门.md","title":"C++语言入门","links":["tags/define","编程语言/C++/基础语法/函数"],"tags":["define"],"content":"C++\nC++语言是一门广泛被使用的语言，学习C语言，可以使我们更加深入的了解到编程语言的运行方式和底层逻辑，下面，让我们从零开始，学习C++\n\n1 C++语言入门\n1.1 第一个C++程序\n我们利用C++输入 hello world\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main()\n{\n    cout &lt;&lt; &quot;hello world&quot;&lt;&lt; endl;\n \n    system(&quot;pause&quot;);\n    \n    return(0);\n}\n\n1.2 C++程序的注释\n\n单行注释\n\n使用//来注释一行代码\n\n\n多行注释\n\n使用/* ...... */来多行注释\n\n\n例子\n\n#include &lt;iostream&gt;     \n \n/* 这是一个头文件\n用于给定指定函数名称*/\n \nusing namespace std;    \nint main()\n{\n    cout &lt;&lt; &quot;hello world&quot;&lt;&lt; endl; //输出hello world\n \n    system(&quot;pause&quot;);\n    \n    return(0);\n}\n\n1.3 变量\n\n作用：给定一段指定的内存空间取名以方便我们操纵这段内存\n语法：数据类型 变量名 = 初始值(int a =10)\n实例\n\n#include &lt;iostream&gt;     \nusing namespace std;\nint main()\n{\n    int a = 10;\n    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n此时C++会输出“a=10”\n\n1.4 常量\n作用：用于记录程序中不可更改的数据\nC++有两种定义常量的方法\n\n\ndefine 宏常量：#define 常量名 = 常量值\n\n通常在代码文件上方定义,表示一个常量\n\n\n\nconst修饰的变量：const 数据类型 常量名 =常量值\n\n通常在变量定义加关键字const,修饰该变量为常量，不可更改\n\n\n\n示例1：\n#include &lt;iostream&gt;     \nusing namespace std;\n \n#define day 7\nint main()\n{\n    cout&lt;&lt;&quot;一周有&quot;&lt;&lt;day&lt;&lt;&quot;天&quot;&lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n如果我们强加的去修改day的值，C++则会报错,说明我们的改动不合规矩\n\n\n示例2：\n#include &lt;iostream&gt;     \nusing namespace std;\n \n#define day 7\nint main()\n{\n    const int year = 365;     //这里修饰了year，后面无法修改\n    cout&lt;&lt;&quot;一周有&quot;&lt;&lt;day&lt;&lt;&quot;天&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;一年有&quot;&lt;&lt;year&lt;&lt;&quot;天&quot;&lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n1.5 关键字\n\n关键字是C++内置的函数或字符名称，我们在创建变量时不用用关键字来给变量来命名\n\n1.6 标识符命名规则\nC++在对标识符(变量，常量)命名时有一套规则，具体如下：\n\n标识符不可以是关键字\n标识符只能由数字，字母，下划线构成\n第一个字符必须为字母或下划线\n标识符大小写敏感\n\n\n建议是标识符名称要通俗易懂，做到见名知意的效果\n\n"},"编程语言/C++/基础语法/函数":{"slug":"编程语言/C++/基础语法/函数","filePath":"编程语言/C++/基础语法/函数.md","title":"函数","links":[],"tags":[],"content":"6 函数\n6.1 概述\n作用： 将经常使用的一段代码封装起来，减少重复代码\n\n一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能\n\n6.2 函数的定义\n一般函数定义有5个主要步骤\n\n返回值类型\n函数名\n参数列表\n函数体语句\nreturn表达式\n\n语法\n//返回值类型 函数名(参数列表)\nint isprime(int n)\n{\n    //函数体语句\n    \n    //return表达式\n    return 0;\n}\n \n\n实例1\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint add(int a , int b) \n{\n    int sum = a+b;\n    return sum;\n}\n \nint main()\n{\n    int num1,num2;\n    scanf(&quot;%d %d&quot;,&amp;num1,&amp;num2);\n    printf(&quot;%d&quot;,add(num1,num2));\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n\na,b 我们可以称为形参，num1,num2 我们可以称为实参，函数调用本质是将实参传递给形参并进行函数运算，返回return值\n\n6.3 函数的调用\n功能： 使用定义好的函数\n语法：函数名(参数)\n6.4 值传递\n\n值传递就是函数调用时实参将数值转递给形参\n值传递时，形参发生变化，并不会影响实参\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nvoid swap(int a,int b) //在无需返回值时，可以输入viod类型\n{\n    int temp = a;\n    a = b;\n    b =temp;\n    cout &lt;&lt; &quot;交换后:&quot;&lt;&lt;a &lt;&lt;&quot; &quot;&lt;&lt;b &lt;&lt;endl;\n    return;\n}\n \nint main()\n{\n    int i1 = 4;\n    int i2 = 5;\n    cout &lt;&lt;&quot;交换前:&quot;&lt;&lt;i1&lt;&lt;&quot; &quot;&lt;&lt;i2&lt;&lt;endl;\n    swap(4,5);\n}\n\n\n                  \n                  Note\n                  \n                \n\n\n在值传递的时候，为实参和形参分别分配内存空间，将实参的内存传递给形参，进而使用形参的内存去执行函数，实参的内存不会发生改变\n\n\n\n6.5 函数的常见样式\n\n无参无返\n有参无返\n无参有返\n有参有返\n\n\n实例\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \n//1.无参无返\nvoid test_01()\n{\n    cout &lt;&lt; &quot;跟你爆了&quot;&lt;&lt;endl;\n    return;\n}\n \n//2.有参无返\nvoid test_02(int a)\n{\n    cout &lt;&lt; a*a &lt;&lt;endl;\n    return;\n}\n \n//3.无参有返\nint test_03()\n{\n    return 1000;\n}\n \n//4.有参有返\nint test_04(int k)\n{\n    return (k*2)+k;\n}\n \nint main()\n{\n    test_01();\n    test_02(4);\n    int num1 = test_03();\n    cout&lt;&lt;num1&lt;&lt;endl;\n    int m = test_04(4);\n    cout &lt;&lt;m &lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n6.6 函数的声明\n作用： 告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义\n\n函数可以声明多次，但函数的定义只能有一次\n\n示例：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \n//声明\nint max01(int a,int b);\n \nint main()\n{\n    int t = max01(5,6);\n    cout &lt;&lt; t &lt;&lt; endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n \n//定义\nint max01(int a,int b)\n{\n    return a&gt;b ? a : b;\n}\n6.7 函数的分文件填写\n作用： 让代码结构更加清晰\n函数分文件编写一般有4个步骤\n\n创建后缀名为.h的头文件\n创建后缀名为.cpp的源文件\n在头文件中书写函数的声明\n在源文件中书写函数的定义\n\n示例\n//head.h\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nvoid swap(int a,int b);\n//fun.cpp\n#include&lt;bits/stdc++.h&gt;\n#include &quot;head.h&quot;\nusing namespace std;\n \nvoid swap(int a,int b)\n{\n    int temp = a;\n    a = b;\n    b = temp;\n    cout &lt;&lt; a &lt;&lt;&quot; &quot;&lt;&lt;b &lt;&lt; endl;\n}\n//test.cpp\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#include &quot;head.h&quot;\n \nint main()\n{\n    swap(4,5);\n    return(0);\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n在VScode中，C++编译只对test.cpp中的main函数进行编译，无法连接到我们的fun.cpp文件\n\n==解决方法:将头文件的文件目录复制到 .vscode目录下的tasks.json的”args”: 的”${file}“下面即可==\n注意复制的单斜杠要改为多斜杠\n\n\n\n\n"},"编程语言/C++/基础语法/指针":{"slug":"编程语言/C++/基础语法/指针","filePath":"编程语言/C++/基础语法/指针.md","title":"指针","links":[],"tags":[],"content":"7 指针\n7.1 指针的基本概念\n指针的作用： 用于间接访问内存\n\n指针的编号是从0开始计数的，一般用16进制表示\n可以利用指针变量保存地址\n\n7.2 指针的定义和操控\n\n定义：数据类型 * 指针变量名\nint *p;(定义了个指针)\np = &amp;a(调用了指针)\n使用：可以使用解引用的方式来找到指针指向的内存\n*p(表示解引用)\n\nint main()\n{\n    int a = 10;\n    //创立指针\n    int *p;\n    //记录变量a的地址\n    p = &amp;a;\n    //解引用\n    cout &lt;&lt; *p&lt;&lt;endl;\n    *p = 1000; //指针也可以修改内存\n    cout &lt;&lt; a;\n    \n    return 0;\n}\n7.3 指针所占的内存空间\n\n在32位操作系统下，指针占用4字节\n\nint main()\n{\n   //指针的第二种写法\n   int a = 10;\n   int *p = &amp;a;\n \n   cout &lt;&lt; &quot;*p所占的内存为&quot;&lt;&lt;sizeof(int *); //我这里似乎是64位系统，所以输出结果是8\n   \n   return 0;\n}\n7.4 空指针与野指针\n\n\n**空指针 ：**指向内存中位0位的指针\n\n\n**野指针：**初始化指针\n\n\n空指针指向的的内存是无法被访问的\n\n\n**野指针：**指针指向非法的内存空间\n\n在没有申请内存的情况使用指针访问这串内存\n\n\n\n7.5 const修饰指针\n有三种情况：\n\nconst修饰指针\\to 常量指针\n\n\n指针的指向可以更改，但指针指向的值不可以改\n\n\n\n7.6 数组与指针的关系[原创]\n\n对于一个数组而言，我们可以把它理解为一段内存地址 + 一个指针: 其中，指针名就是指向第一个内存地址的指针\n\n\ta         [内存地址1][内存地址2][内存地址3].....\n|-&gt; 指针名字|-&gt;地址1\n|-----------------------&gt; 地址2\n重新审视数组定义：\nint arr[n] --&gt; 数组大小 *1\n | \t |--&gt; 数组名称 \t\t*2\n |-&gt; 数组类型\t\t\t*3\n再来审视一下指针定义\nint *p = NULL --&gt; 指针指向的变量\n |  |-&gt;指针名称\n |-&gt;指针类型\n\n那对于一个数组而言，我们不妨把数组名字当作一个指针名，而 [ ] 当作一个解指针+指针运算的方式\n\n*(p + 0) == p[0] \n\n\n                  \n                  Tip\n                  \n                \n\n\n\n注意: [ ]是确实存在的，并且不仅是数组可以使用，但是注意在定义指针数组的时候，int *p[a]这类的操作下[ ]的含义又变得不同\n\n\n\n\n那对一个二维数组而言，其本质就是一个二重指针，里层的指针指向元素，外层的指针指向里层的指针，两次[ ][ ]表示运算两次指针+解两次指针\n指针数组与数组指针"},"编程语言/C++/基础语法/数据类型":{"slug":"编程语言/C++/基础语法/数据类型","filePath":"编程语言/C++/基础语法/数据类型.md","title":"数据类型","links":[],"tags":[],"content":"C++规定在创建一个标识符的时候必须指定其数据类型，否则无法对该标识符分配内存\n2.1 整型\nint 作用：整型变量表示的是整数类型的数据\nC++共有4种表示整型的方式，他们的区别在于占用空间的不同\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据类型占用空间取值范围short(短整型)2字节(-2^15^—2^15^-1)int(整型)4字节(-2^31^—2^31^-1)long(长整型)windows为4字节，Linux为4字节(32x)或8字节(64x)(-2^31^~2^31^-1)long long(长长整型)8字节(-2^63^~2^63^-1)\n2.2 sizeof 关键字\n作用： 利用sizeof关键字可以统计数据所占的内存大小\n语法：sizeof( 数据类型/变量 )\n示例:\n#include &lt;iostream&gt;     \nusing namespace std;\n \nint main()\n{\n    //可以利用sizeof求出数据类型占用多少内存空间\n    short num1 =10;\n    cout&lt;&lt;&quot;short占用的内存为&quot;&lt;&lt;sizeof(num1)&lt;&lt;endl;\n    int num2 = 10;\n    cout&lt;&lt;&quot;int占用的内存为&quot;&lt;&lt;sizeof(num2)&lt;&lt;endl;\n    long long num3 =10;\n    cout&lt;&lt;&quot;long long 占用的内存为&quot;&lt;&lt;sizeof(num3)&lt;&lt;endl;\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n此时输出的结果如下\n\n\n2.3实型（浮点型）\n**作用：**用于表示小数\n浮点型变量分为两种：\n\n单精度float\n双精度double\n\n两者的区别在于精度和占用内存不同\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据类型占用大小精度float4字节7位有效数字double8字节15~16位有效数字\n\n\n                  \n                  NOTE\n                  \n                \n\n\n在使用float时要注意语法float num1 = 3.14f,只有带上f后才会被认定为float类型，否则会按照默认的doubt类型赋值\n\n\n\n\n表示小数时也可以用科学计数法\n\nfloat f3 = 3e2;//3*10^2\ncout&lt;&lt;f3&lt;&lt;endl;\nfloat f4 = 3e-2;//3*10^-2\ncout&lt;&lt;f4&lt;&lt;endl;\n此时输出的结果便为：\n\n2.4 字符型\n\n\n作用 字符型变量用于显示单个字符\n\n\n语法: char ch = &#039;a&#039;\n\n\n\ntips1: 显示字符型变量的时候只能用单引号，不能用双引号\ntips2:单引号内只能有一个字符，不可以是字符串\n\n\n字符型变量只占用1字节\n字符型变量将变量以ASCII码的形式储存在内存里\n\n如何查看字符型变量的ASCII码\ncout &lt;&lt; (int)[变量名] &lt;&lt; endl\n\n常用ASCII码：a-97  A-65\n\n2.5 转义字符\n作用: 表示一些不能显示出来的ASCII字符\n常用的转义字符有：\\n \\\\ \\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n转义字符作用ASCII码\\n换行符010\\\\转义一个\\092\\t水平制表符(占8个位置)009\n2.6 字符串型\n\n作用: 用于表示一串字符\n\n两种风格\n\nC语言风格：char 变量名[]= &quot;字符串值&quot;\nC++风格：string 变量名=&quot;字符串值&quot;\n\nint main()\n{\n    char str/*字符串名*/[] = &quot;hello world&quot;; //tips1:字符串名后要加[]\n    cout &lt;&lt; str &lt;&lt;endl;\n    \n    string str2 = &quot;114514&quot;;   //要包含一个头文件#include &lt;string&gt; \n    cout&lt;&lt;str2&lt;&lt;endl;\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n\n\n                  \n                  IMPORTANT\n                  \n                \n\n\nC++风格字符串需要在开头加入头文件#include\n\n\n\n2.7 布尔类型(bool)\n**作用：**作用于条件判断，代表真或假\n\nbool类型只有两个值\nTrue——真(1)\nFalse——假(0)\nbool 占用1字节的内存空间\n\n示例：\nint main()\n{\n    bool flag = true ; //true代表真，本质上是&quot;1&quot;\n    cout&lt;&lt;flag&lt;&lt;endl;\n    bool flag2 = false ;//false代表假，本质是&quot;0&quot;\n    cout &lt;&lt; flag2&lt;&lt;endl;\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n而这块代码的输出结果\n\n2.8 数据的输入\n**作用：**从键盘上获取数据\n语法：cin &gt;&gt; 变量\n示例：\nint main()\n{\n    //整型\n    int a = 0;\n    cout &lt;&lt; &quot;请键入整型变量a的值&quot;&lt;&lt;endl;\n    cin &gt;&gt; a;\n    cout &lt;&lt;a&lt;&lt;endl;\n    //浮点型\n    float f =1.14f;\n    cout&lt;&lt;&quot;请给浮点型f赋值&quot;&lt;&lt;endl;\n    cin &gt;&gt; f;\n    cout &lt;&lt;f&lt;&lt;endl;\n    //字符串型\n    string str = &quot;hello world&quot;;\n    cout&lt;&lt;&quot;输入你的字符串值&quot;&lt;&lt;endl;\n    cin &gt;&gt; str;\n    cout&lt;&lt;str&lt;&lt;endl;\n \n     \n    system(&quot;pause&quot;);\n \n    return(0);\n}\n输出结果为:\n"},"编程语言/C++/基础语法/数组":{"slug":"编程语言/C++/基础语法/数组","filePath":"编程语言/C++/基础语法/数组.md","title":"数组","links":[],"tags":[],"content":"5 数组\n5.1 概述\n数组就是一个集合，里面存放了相同类型的数据元素\n\n**特点1：**数组中每个数据元素都是相同的数据类型\n**特点2：**数组是连续的内存位置组成的\n\n5.2 一维数组\n5.2.1 一维数组的定义方式：\n一维数组有三种定义方式：\n\n数据类型 数组名[ 数组长度 ]\n数据类型 数组名[ 数组长度 ]={ 值1,值2,…}\n数据类型 数组名[]={ 值1,值2,…}\n\n示例1：\nint main()\n{\n    // 1. `数据类型 数组名[ 数组长度 ]`\n    int arr[5];\n    arr[0] = 10;\n    arr[1] = 20;\n    arr[2] = 30;\n    arr[3] = 40;\n    arr[4] = 50;\n    int a = 3;\n    cout &lt;&lt; arr[3] &lt;&lt; endl;//这个访问的是 40 \n    cout &lt;&lt; arr[ a ] &lt;&lt; endl; //数组的下标可以通过变量来索引\n    system(&quot;pause&quot;);\n    return(0);  \n}\n示例2：\nint main()\n{\n    //2.数据类型 数组名[ 数组长度 ]={ 值1,值2,…}\n    int arr2[5] = {10,20,30,40,50};\n    for (int i = 0; i &lt; 5; i++) // i &lt; 5 中，5表示数组长度\n    {\n        cout &lt;&lt; arr2[i] &lt;&lt; endl;\n    }\n    //若初始没有补齐数据，会用0来填充空余数据\n    system(&quot;pause&quot;);\n    return(0);  \n}\n示例3：\nint main()\n{\n    //3.数据类型 数组名[]={ 值1,值2,…}\n    //定义数组时必须要给定初始长度\n    int arr3[] = {1,1,4,5,1,4};\n    for (int i = 0; i &lt; 6; i++)\n    {\n        cout &lt;&lt; arr3[i]&lt;&lt;endl;\n    }\n    system(&quot;pause&quot;);\n    return(0);  \n}\n\n数组中的数据是从0开始标记(索引)下标\n我们可以通过下标来访问数组中的元素\n\n5.2.2 一维数组数组名\n用途：\n\n可以统计整个数组在内存中所占的长度\n可以获取数组在内存中的首地址\n\n\n对1：sizeof(数组名)\n我们可以用 `sizeof(arr)/sizeof(arr[0])来获取内存的长度\n\n\n对2：cout &lt;&lt; arr &lt;&lt;endl;\n一般该地址为16进制地址\n\nint main()\n{\n    //1。查询数组所占内存大小\n    int arr[6]={1,1,4,5,1,4};\n    cout &lt;&lt; &quot;数组大小为&quot;&lt;&lt; sizeof(arr)&lt;&lt;endl;\n    cout &lt;&lt; &quot;数组长度为&quot;&lt;&lt; sizeof(arr)/sizeof(arr[0])&lt;&lt;endl;\n    //2.查看首地址\n    cout &lt;&lt;&quot;内存地址&quot;&lt;&lt; arr &lt;&lt; endl;//16进制\n    cout &lt;&lt; (long long)arr &lt;&lt;endl;//强转10进制\n    cout &lt;&lt; &amp;arr[0]&lt;&lt;endl;//数组中某个元素的内存地址\n    cout &lt;&lt; (long long)&amp;arr[0] &lt;&lt;endl;//数组中某个元素的10进制内存地址\n    //使用 long long 包容16进制精度问题\n    cout &lt;&lt; &amp;arr[1]&lt;&lt;endl;//第二个元素位置\n    cout &lt;&lt; (long long)&amp;arr[1] &lt;&lt;endl;//10进制\n    //第二个与第一个相差4字节\n    //数组名是常量，不能修改赋值\n    system(&quot;pause&quot;);\n    return(0);  \n}\n练习案例1：\n\n\n在一个数组中记录了5个数据，arr[5] ={10,30,20,70,60}\n\n\n找出这个数组中最大数\n\n\nint main()\n{\n    int arr[5]= {10,30,60,40,20};\n    int max = 0; //假设某一最大值\n    for (int i = 0; i &lt; 5; i++)//访问数组中的每一个数\n    {\n        if (arr[i] &gt; arr[max]) //比较假设值和访问值大小\n        {\n            max = i ; //若大于，则替换假设最大值\n        }\n    }\n    //循环结束时，最大值以确定\n    cout &lt;&lt; &quot;最大的数是&quot; &lt;&lt; arr[max]&lt;&lt;endl; //输出\n    \n    system(&quot;pause&quot;);\n    return(0);  \n}\n\n\n                  \n                  Note\n                  \n                \n\n\n在上面代码中，for循环内部也可以使用三目运算来找最大值\nmax = (arr[max] &gt; arr[i] ? max : i ); //使用三目运算符\n\n\n\n\n**练习案例2：**数组元素逆置\n\n声明一个5个元素的数组，并将其逆置\n示例 : 原数组 {1,3,4,2,3}  ⇒ 输出{3,2,4,3,1}\n输出逆置\n\nint main()\n{\n    int arr[5] = {1,3,4,2,3};\n    for (int i = 0; i &lt; 5; i++)\n    {\n        cout &lt;&lt; arr[4-i] ; \n    }\n    cout &lt;&lt; endl;\n \n    system(&quot;pause&quot;);\n    return(0);  \n}\n\n创立逆置数组\n\nint main()\n{\n    int arr[5] = {1,3,4,2,3};\n    int arrt[5];\n    int t; //建立逆置变量\n    for (int i = 0; i &lt; 5; i++) \n    {\n        t = (sizeof(arr)/sizeof(arr[0]))-1-i; //实现逆置变量\n        arrt[i] = arr[t]; //实现原数组向逆置数组的赋值\n    }\n    //逆置数组建立完成，以下为检查\n    for (int i2 = 0; i2 &lt; 5; i2++)\n    {\n        cout &lt;&lt; arrt[i2] &lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n原数组的逆置\n\nint main()\n{\n    int arr[5] = {1,3,4,2,3};\n    int sta = 0;\n    int end = sizeof(arr)/sizeof(arr[0])-1;\n    int temp = 0;\n    //核心\n    for ( ; sta &lt; end ; )       //当起始值位置大于末尾值位置时停止\n    {\n        temp = arr[sta];        //初始值赋值至临时内存\n        arr[sta] = arr[end];    //末尾值赋值至初始值\n        arr[end] = temp;        //初始值(临时)赋值至末尾值\n        sta++;                  //初始值后移一位\n        end--;                  //末尾值前移一位\n    }\n    //数组倒置结束\n    for (int i2 = 0; i2 &lt; 5; i2++)\n    {\n        cout &lt;&lt; arr[i2]&lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n5.2.3 冒泡排序\n**作用：**最常用的排序算法，对数组内的元素进行排序\n\n比较相邻的元素，如果第一个比第二个大，就交换他们\n对每一对相邻元素做同样工作，执行完毕后，找到第一个最大值\n重复以上步骤，每次比较次数-1，直到不需要比较\n\n示例： 将数组{4,2,3,0,5,7,1,3,9}升序排列\nint main()\n{\n    int arr[9] = {4,2,3,0,5,7,1,3,9};\n    for (int i = 0; i &lt; (sizeof(arr)/sizeof(arr[0])-1); i++)//排序的总轮数=元素个数-1\n    {  \n        for (int j = 0; j &lt;(sizeof(arr)/sizeof(arr[0])-1)-i ; j++) //每轮排序的次数 = 元素个数 -1 -当前轮数\n        {\n            if (arr[j] &gt; arr[j+1] ) //判断相邻的两个数的大小\n            {\n                //实现交换\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    //输出验证\n    for (int i2 = 0; i2 &lt; 9; i2++)\n    {\n        cout &lt;&lt; arr[i2]&lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n利用遍历实现数据筛查\n题目来源洛谷P1085 [NOIP2004 普及组] 不高兴的津津\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint main()\n{\n\tint a,b,t;\n    int m =0; \n    int arr[7];\n    for (int i = 0; i &lt; 7; i++)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        int k =a +b;\n        arr[i] = k; //将获得的数据记入数组\n    }\n     //对数组遍历，找出最大的那个数\n    for (int j = 0; j &lt; 7; j++) //假设一个最大值 arr[0]，让arr[0]和下一个数比较，若大于，则将m赋值为j\n    {\n        if (arr[m] &lt; arr[j]) \n        {\n            m = j; \n            t = arr[j];\n        }\n    }\n    if ( t &gt; 8)\n    {\n        cout &lt;&lt; m+1 &lt;&lt;endl;\n    }\n    else\n    {\n        cout &lt;&lt; 0 &lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n5.3 二维数组\n5.3.1 二维数组的定义方式：\n\n数据类型 + 数组名[行数][列数];\n数据类型 + 数组名[行数][列数] = {数据1，数据2}，{数据3，数据4};[^2]\n数据类型 + 数组名[行数][列数] = {数据1，数据2，数据3，数据4};\n数据类型 + 数组名[][列数] = {数据1，数据2，数据3，数据4};\n第三和第四组会自动区分行列数(即从第一个数据开始计数，记到列数自动换行)\n\n\n5.3.2 二维数组的赋值方式\n\narr[0][0] = 元素;\narr[0][1] = 元素;\n……\n\n如何输出一个二维数组？\n\n写一个嵌套循环，外层打印行数，内层打印列数\n\nfor (int i = 0;i &lt; count ; i++)\n{\n    for(int j = 0;j &lt; count ; j++)\n    {\n        cout &lt;&lt; arr[i][j];\n    }\n    cout &lt;&lt; endl;\n}\n\n\n                  \n                  Note\n                  \n                \n\n\n\n直观表示一个二维数组 ：int arr[3][3];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n列\\行0列1列2列0行arr[0][0]arr[0][1]arr[0][2]1行arr[1][0]arr[1][1]arr[1][2]2行arr[2][0]arr[2][1]arr[2][2]\n行列式行列式，先行后列\n\n\n\n5.3.3 二维数组数组名\n\n查看二维数组所占内存空间\n获取二维数组首地址\n具体如下\n\nint main()\n{\n    int arr[3][3] =\n    {\n        {1,1,4},\n        {5,1,4}\n    };\n    //1.查看占用内存空间大小\n    cout &lt;&lt; sizeof(arr) &lt;&lt;endl; // out : 36 (6*6)\n    cout &lt;&lt; sizeof(arr[0][0]) &lt;&lt;&quot; &quot;&lt;&lt;sizeof(arr[0])&lt;&lt;endl; //out : 4 12(单个元素 第一行)\n    //我们可以通过以上数据获得行数与列数\n    sizeof(arr)/sizeof(arr[0]); //列数\n    sizeof(arr[0])/sizeof(arr[0][0]); //列数\n    \n    //2.查看首地址\n    cout &lt;&lt; (long long)arr &lt;&lt;endl;  //out : 6422000\n    cout &lt;&lt; (long long)arr[0] &lt;&lt;endl; //二维数组地址与arr[0][0]首地址重合\n    cout &lt;&lt; (long long)arr[1] &lt;&lt;endl; //out : 6422012 差12(3*4)\n    cout &lt;&lt; (long long)&amp;arr[0][0] &lt;&lt;endl; //二维数组地址与arr[0][0]首地址重合\n    cout &lt;&lt; (long long)&amp;arr[0][1] &lt;&lt;endl; //out : 6422004 与[0][0]差4\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n5.3.3 二维数组应用案例\n考试成绩统计\n\n有三名同学(A,B,C)，在一次考试中成绩分别如下，请输出三名同学的总成绩\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n语文数学英语A100100100B9050100C607080\nint main()\n{\n    \n    int arr[3][3] =\n    {\n        {100,100,100},\n        {90,50,100},\n        {60,70,80}\n    };\n    \n    for (int i = 0; i &lt; 3; i++)\n    {\n        int temp = 0;\n        for (int j = 0; j &lt; 3; j++)\n        {\n            temp += arr[i][j];\n        }\n        cout &lt;&lt; temp &lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n5.3.4 二维数组排序\n\n核心思路：冒泡排序\n\nint main()\n{\n    int l,m;\n    cin &gt;&gt; l &gt;&gt; m;\n    int arr[m][2];\n    for (size_t i = 0; i &lt; m; i++)\n    {\n        for (size_t j= 0; j &lt; 2; j++)\n        {\n          cin &gt;&gt; arr[i][j];\n        } \n    }\n \n    for (size_t i2 = 0; i2 &lt; m-1; i2++)\n    {\n        for (size_t j = 0; j &lt; m-i2-1; j++)\n        {\n            if (arr[j][0] &gt; arr[j+1][0])\n            {\n                int temp1 = arr[j][0];\n                int temp2 = arr[j][1];\n                arr[j][0] = arr[j+1][0];\n                arr[j][1] = arr[j+1][1];\n                arr[j+1][0] = temp1;\n                arr[j+1][1] = temp2;\n            }\n        }\n    }\n \n    for (size_t i = 0; i &lt; m; i++)\n    {\n        for (size_t ij = 0; ij &lt; 2; ij++)\n        {\n            cout &lt;&lt; arr[i][ij]&lt;&lt;&quot; &quot;;\n        }\n        cout &lt;&lt;endl;\n    }\n       \n    \n    return 0;\n}\n"},"编程语言/C++/基础语法/程序结构流程":{"slug":"编程语言/C++/基础语法/程序结构流程","filePath":"编程语言/C++/基础语法/程序结构流程.md","title":"程序结构流程","links":[],"tags":[],"content":"4 程序流程结构\nC/C++支持的三种程序运行结构：顺序结构，选择结构，循环结构\n\n顺序结构:类似于Python的运行结构，程序按顺序执行，不发生跳转\n选择结构:依据条件是否满足，有选择的执行相应功能\n循环结构:依据条件是否满足，循环多次执行某段代码\n\n4.1 选择结构\n4.1.1 if语句\n作用: 执行满足条件的语句\n其主要有三种形式：\n\n单行格式if语句\n多行格式if语句\n多条件的if语句\n\n\n单行格式if语句:if(条件){ 条件满足执行的语句 }\n\n\n示例:\nint main()\n{\n    //单行if结构\n    //让用户输入一个分数，如果大于600，则输出&quot;恭喜&quot;\n    //1. 用户输入分数\n    int score = 0;\n    cout &lt;&lt; &quot;请输入一个分数&quot;&lt;&lt;endl;\n    cin &gt;&gt; score ;\n    //2. 打印用户分数\n    cout &lt;&lt; &quot;您的分数为:&quot;&lt;&lt;score&lt;&lt;endl;\n    //3.判断\n    if(score &gt; 600) //if条件语法后没有分号！！！\n    {\n        cout&lt;&lt;&quot;恭喜&quot;&lt;&lt;endl;\n    }\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n\n                  \n                  Important\n                  \n                \n\n\nif条件后面不要加分号\n\n\n\n\n多行格式if语句：if(条件){ 条件为真执行的语句 }else{ 条件不满足执行的语句 }\n\n\n示例:\nint main()\n{\n    //多行格式if\n    //提示用户输入分数，如果分数大于600，则输出&quot;恭喜&quot;，若没有大于600，则输出&quot;别放弃&quot;\n    int score = 0;\n    cout &lt;&lt;&quot;请输入一个分数&quot;&lt;&lt;endl;\n    cin &gt;&gt; score;\n    cout &lt;&lt; &quot;您的分数为&quot;&lt;&lt; score &lt;&lt;endl;\n    //执行判断\n    if(score &gt; 600) //大于600的情况\n    {\n        cout &lt;&lt; &quot;恭喜&quot;&lt;&lt;endl;\n    }\n    else //小于600的情况\n    {\n        cout &lt;&lt; &quot;别放弃&quot;&lt;&lt;endl;\n    }\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n多条件的if语句:if(条件1){满足条件1执行的语句}else if(条件2){满足条件2执行的语句}... else{都不满足执行的语句}\n\n\nint main()\n{\n    //多条件的if语句\n    //1.输入分数\n    int score = 0;\n    cout &lt;&lt; &quot;请输入一个分数&quot;&lt;&lt;endl;\n    cin &gt;&gt; score;\n    cout &lt;&lt; &quot;您的分数是&quot; &lt;&lt; score &lt;&lt; endl;\n    //2.条件判断(大于600)\n    if (score &gt;= 600)\n    {\n        cout &lt;&lt; &quot;恭喜&quot;&lt;&lt;endl;\n    }\n    else if (score &gt;= 500)//这里不能写(500 &lt; score &lt; 600)\n    {\n        cout &lt;&lt; &quot;别放弃&quot;&lt;&lt;endl;\n    }\n    else if (score &gt;= 400)\n    {\n        cout &lt;&lt; &quot;还可以&quot;&lt;&lt;endl;\n    }\n    else\n    {\n        cout &lt;&lt; &quot;别摆烂辣！&quot;&lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n嵌套if语句：在if语句中再嵌套一个if语句\n案例要求:\n\n在上个代码的基础上，根据分数再细化\n大于700为特等，大于650为一等，大于600为优秀\n\nint main()\n{\n    //多条件的if语句\n    //1.输入分数\n    int score = 0;\n    cout &lt;&lt; &quot;请输入一个分数&quot;&lt;&lt;endl;\n    cin &gt;&gt; score;\n    cout &lt;&lt; &quot;您的分数是&quot; &lt;&lt; score &lt;&lt; endl;\n    if (score &gt;= 600)\n    {\n        cout &lt;&lt; &quot;恭喜&quot;&lt;&lt;endl;\n        if (score &gt;= 700) //嵌套的if语句\n        {\n            cout &lt;&lt; &quot;特等&quot;&lt;&lt;endl;\n        }\n        else if (score &gt;= 650)\n        {\n            cout &lt;&lt; &quot;一等&quot;&lt;&lt;endl;\n        }\n        else\n        {\n            cout &lt;&lt; &quot;优秀&quot;&lt;&lt;endl;\n        }\n    }\n    else if (score &gt;= 500)//这里不能写(500 &lt; score &lt; 600)\n    {\n        cout &lt;&lt; &quot;别放弃&quot;&lt;&lt;endl;\n    }\n    else if (score &gt;= 400)\n    {\n        cout &lt;&lt; &quot;还可以&quot;&lt;&lt;endl;\n    }\n    else\n    {\n        cout &lt;&lt; &quot;别摆烂辣！&quot;&lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n4.1.2 三目运算符\n**作用:**通过三目运算符实现简单的判断\n语法：表达式1 ? 表达式2 : 表达式3\n解释：\n如果表达式1的值为真，执行表达式2，并返回表达式2的结果；\n如果表达式1的值为假，执行表达式3，并返回表达式3的结果；\n示例:\nint main()\n{\n    //三目运算符\n    int a =30;\n    int b =20;\n    int c =0;\n    c=(a &gt; b ? a : b);\n    cout &lt;&lt; c &lt;&lt;endl;\n \n    //在C++中，三目运算符返回的是变量，可以继续赋值\n    (a &gt; b ? a:b)=100; //a和b做大小比较，较大的变量被赋值为100\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n4.1.3 switch语句\n执行多条件分支语句\n语法：\nswitch(表达式)\n    \n{\n    case 结果1 : 执行语句;break;\n        \n    case 结果2 : 执行语句;break;\n        \n    ...\n        \n\tdefault : 执行语句;break;\n}    \n示例:\nint main()\n{\n    //给电影评分\n    //9-10 经典\n    //7-8 非常好\n    //5-6 不错\n    // &lt;5 不好\n \n    cout &lt;&lt; &quot;请给电影打分&quot;&lt;&lt;endl;\n    int score = 0;\n    cin &gt;&gt; score ;\n    cout &lt;&lt; &quot;您的打分为&quot;&lt;&lt;score&lt;&lt;endl;\n    switch (score)\n    {\n    case 10 :\n        cout &lt;&lt; &quot;经典&quot;&lt;&lt;endl;\n        break; //退出当前分支\n    case 9 :\n        cout &lt;&lt; &quot;经典&quot;&lt;&lt;endl;\n        break;\n    case 8 :\n        cout &lt;&lt; &quot;非常好&quot;&lt;&lt;endl;\n        break;\n    case 7 :\n        cout &lt;&lt; &quot;非常好&quot;&lt;&lt;endl;\n        break;\n    case 6 :\n        cout &lt;&lt; &quot;一般&quot;&lt;&lt;endl;\n        break;\n    case 5 :\n        cout &lt;&lt; &quot;一般&quot;&lt;&lt;endl;\n        break;\n    default:\n        cout &lt;&lt; &quot;不好&quot;&lt;&lt;endl;\n        break;\n    }\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n\n记得要写break;\n\n\n缺点:switch判断的时候只能是整型或字符型，不可以是一个区间\n\n\n优点:结构清晰，执行效率高(速度快)\n\n4.2 循环结构\n4.2.1 while循环语句\n**作用:**满足循环条件，执行循环语句\n语法:while(循环条件){循环语句}\n\n解释:只要循环条件为真，就执行循环语句\n示例:\nint main()\n{\n    //在屏幕中打印0-9这10个数字\n    \n    int num = 0;\n    while (num &lt; 10)\n    {\n        cout &lt;&lt; num &lt;&lt;endl;\n        num++;\n    }\n    system(&quot;pause&quot;);\n \n    return(0);\n}\n\n如果while 后条件为(1)，则为无限循环，要避免死循环的出现\n\n练习:猜数游戏\nint main()\n{\n    //添加随机数种子\n    srand((unsigned int)time(NULL));    \n    int num2 = rand()%100 + 1 ; \n    //cout &lt;&lt; num22 &lt;&lt;endl;\n    int val = 0;\n    cout &lt;&lt; &quot;请输入一个数开始猜数游戏&quot;&lt;&lt;endl;\n    while (val != num2)\n    {\n        cin &gt;&gt; val ;\n        if (val &gt; num2 )\n        {\n            cout &lt;&lt; &quot;猜大辣，再来一次吧&quot;&lt;&lt;endl;\n        }\n        else if (val &lt; num2)\n        {\n            cout &lt;&lt; &quot;猜小辣，再来一次吧&quot;&lt;&lt;endl;\n        }\n        \n    }\n    cout &lt;&lt; &quot;厉害，对辣&quot;&lt;&lt;endl;\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n4.2.2 do…while循环\n**作用：**满足循环条件，执行循环语句\n语法：do{循环语句}while(循环条件);\n\n\n                  \n                  Note\n                  \n                \n\n\n与while不同的是，do…while会先执行一次循环语句，再判断循环条件\n\n\n\n\n示例：\nint main()\n{\n    //do while 循环\n    int num =0;\n    do\n    {\n        cout &lt;&lt; num &lt;&lt;endl;\n        num++;\n    } while (num &lt; 10);\n    system(&quot;pause&quot;);\n    return(0);\n \n}\n**练习案例：**水仙花数\n\n水仙花数是一个三位数，它的每个位上的三次幂之和等于它本身\n例：1^3^+5^3^+3^3^=153\n\n//注意：要有#include&lt;cmath&gt;\nint main()\n{\n    //定义初始值，其中fnum3,2,1分别代表百十个位，这个三位数要和初始值fnum相等\n    int fnum1 = 0;\n    int fnum2 = 0;\n    int fnum3 = 1;\n    float fnumt = 0;\n    int fnum = 100;\n    do\n    {\n        \n        fnum++;\n        fnum1++;\n        //三位数输出，个十百位分别输出\n        if (fnum1 - 1  == 9)\n        {\n        fnum1 = 0;\n        fnum2++;\n        }\n        if (fnum2 - 1 == 9)\n        {\n        fnum2 = 0;\n        fnum3++;\n        }\n        if (fnum3 - 1 == 9)\n        {\n            fnum3 = 0;\n        }\n        \n        fnumt = pow(fnum1,3) + pow(fnum2,3) + pow(fnum3,3);\n        if ( fnumt == fnum)\n        {\n            cout &lt;&lt;&quot;水仙花&quot;&lt;&lt; fnum &lt;&lt; endl;\n        }\n        // cout &lt;&lt; fnum &lt;&lt; endl;\n        // cout &lt;&lt; fnumt &lt;&lt; endl;\n        // cout &lt;&lt;&quot;个位&quot;&lt;&lt; fnum1 &lt;&lt; endl;\n        // cout &lt;&lt;&quot;十位&quot; &lt;&lt;fnum2 &lt;&lt; endl;\n        // cout &lt;&lt;&quot;百位&quot; &lt;&lt;fnum3 &lt;&lt; endl;\n     \n    } while (fnum &lt; 1000);\n    system(&quot;pause&quot;);\n    return(0);\n \n}\n\n\n                  \n                  Important\n                  \n                \n\n\n如何获取一个三位数的个十百位？\n\n例:153\n个位:153%10 = 3    对数字取模于10可以获得个位\n十位:153/10 = 15 \\to15 % 10 = 5  C++中整除只留整数部分即 (153/10)%10\n百位:153/100 = 1\n\n\n\n\n示例：\nint main()\n{\n    int num = 100;\n    do{\n        num++;\n        if(num == pow(num%10,3)+pow((num/10)%10,3)+pow(num/100,3))\n        {\n            cout &lt;&lt; num &lt;&lt;endl;\n        }\n    }while(num &lt; 999);\n \n    system(&quot;pause&quot;);\n    return(0);\n}\n4.2.3 for 循环\n**作用：**满足循环条件，执行循环语句\n语法：for(起始表达式;条件表达式;末尾循环体){循环语句;}\n\n起始表达式不参加循环\n条件表达式确定循环条件\n一次循环执行后执行末尾循环体\n\n示例：\nint main()\n{\n    for (int i = 0; i &lt; 10; i++)\n    {\n        cout &lt;&lt; i &lt;&lt;endl;\n    }\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n\n                  \n                  Note\n                  \n                \n\n\n对for(a;b;c){d}来看，执行顺序如下\n\n先执行一次 a\n判断 b\n若b为真，重复2，3，4，5；否则退出循环\n执行 d\n执行 c\n\n\n\n\n\nfor 循环结构简单，比较常用\n\n**练习案例：**敲桌子\n\n输出1~100，若该数个位含有7，或10位含有7，或该数字是7的倍数，则我们输出敲桌子，其余数字直接打印\n\nint main()\n{\n    for (int i = 0; i &lt; 100; i++)\n    {\n        if (i%10 == 7)\n        {\n            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt;endl;\n        }\n        else if ((i/10)%10 == 7)\n        {\n            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt;endl;\n        }\n        else if ( i%7 == 0 )\n        {\n            cout &lt;&lt; &quot;敲桌子&quot; &lt;&lt;endl;\n        }\n        else\n        {\n            cout &lt;&lt; i &lt;&lt;endl;\n        }        \n    }\n}\n\n\n                  \n                  Note\n                  \n                \n\n\nif比较语句中我们可以用逻辑运算符来提高if语句的精确性\n比如上面的示例中多个if便可以写成if(i % 10 == 7 || i%7==0 || (i/10)%10==7 )\n\n\n\n4.2.4 嵌套循环\n\n在循环体中再次嵌套循环，用于解决实际问题\n\n示例\nint main()\n{\n    for (int i = 0; i &lt; 10 ; i++) //外层循环\n    {\n        for (int j = 0; j &lt; 10; j++) //内层循环\n        {\n            cout &lt;&lt; &quot;*&quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n // 外层走一次，内层走一周   \n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n**案例：**乘法口诀表\n\n打印九九乘法表\n\nint main()\n{\n    //九九乘法表，实际上就是 行 X 列 = 数字，即将行和列表示出来即可\n    for (int i = 0; i &lt; 10; i++) // i 代表 行\n    {\n        for (int j = 1; j &lt; i+1 ; j++) // j 代表 列 \n        {\n            cout &lt;&lt; j &lt;&lt;&quot;X&quot;&lt;&lt; i &lt;&lt;&quot;=&quot;&lt;&lt;i*j&lt;&lt;&quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }   \n    system(&quot;pause&quot;);\n    return(0);\n}\n输出呈现：\n\n\n4.3 跳转语句\n4.3.1 break 语句\n**作用：**跳出选择结构或循环结构\nbreak使用的时机：\n\n出现在switch语句中，终止case并跳出switch\n出现在循环语句中，作用是跳出当前循环语句\n出现在嵌套循环中，作用是跳出最近的内层循环语句\n\n示例1：\nint main()\n{\n    for (int i = 0; i &lt; 10 ; i++)\n    {\n        cout &lt;&lt; i &lt;&lt; endl;\n        if (i == 5)\n        {\n            break;\n        }\n        \n    } \n    system(&quot;pause&quot;);\n    return(0);  \n}\n示例2\nint main()\n{\n    for (int i = 0; i &lt; 10 ; i++)\n    {\n        for (int j = 0; j &lt; 10; j++)\n        {\n            if (j == 5)\n            {\n                break;\n            }\n            cout &lt;&lt; &quot;*&quot;;\n        }\n        cout&lt;&lt; endl; \n    } \n    system(&quot;pause&quot;);\n    return(0);  \n}\n4.3.2 countinue 语句\n**作用:**在循环语句中，跳过本次循环中余下的未执行的代码，继续执行下一次循环\n示例：\nint main()\n{\n    for (int i = 0; i &lt;= 100; i++)\n    {\n        if (i%2 == 0)\n        {\n            continue;\n        }\n        \n        cout &lt;&lt; i &lt;&lt; endl;\n    }\n    system(&quot;pause&quot;);\n    return(0);  \n}\n\n实现了0~100奇数的输出\n\n4.3.3 goto 语句\n**作用：**可以无条件跳转语句\n语法：goto 标记\n\n标记一般用纯大写英文表示\ngoto 语法尽量不要经常使用，以免造成代码逻辑混乱\n标记定义 T：\n\n"},"编程语言/C++/基础语法/类":{"slug":"编程语言/C++/基础语法/类","filePath":"编程语言/C++/基础语法/类.md","title":"类","links":[],"tags":[],"content":"9 类\n\n在面向对象编程（OOP）中，对象就是类的实例，也就是变量\n\nclass Class_Name\n{\npublic:\n    string str;\n    int adds;\n    void add_age(int add_s)\n    {\n        //..../\n    } // 内联函数\n    void getval();\nprivate:\n    int age;\n};\n\n对内联函数，也可以使用 inline 来在类的外部写\ninline \n"},"编程语言/C++/基础语法/结构体与链表":{"slug":"编程语言/C++/基础语法/结构体与链表","filePath":"编程语言/C++/基础语法/结构体与链表.md","title":"结构体与链表","links":[],"tags":[],"content":"8 结构体\n自定义的数据类型，允许用户储存不同的数据类型\n8.1 结构体的定义\n语法：struct 结构体名{结构体成员列表};\n\n\n有三种创建变量的方式:\n\nstruct 结构体名 变量名\nstruct 结构体名 变量名 = {成员1 ， 成员2 ， ……}\n定义结构体时顺便创建变量\n例：\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &#039;\nusing namespace std;  \n// 创建数据类型  \nstruct QAQ {  \n    string s1;  \n    int n1;  \n    int n2;  \n    // 下面是定义时候定义  \n} k3;  \nint main()  \n{  \n    // 定义结构体数据 1  \n    QAQ k1;  \n    k1.s1 = &quot;aaa&quot;;  \n    // 定义结构体数据 2  \n    QAQ k2 = { &quot;114&quot;, 5, 1 };  \n    k3.s1 = &quot;1919&quot;;  \n    k3.n1 = 810;  \n    return 0;  \n}\n \n\n\n8.2 结构体数组\n定义结构体放入数组方便维护\n\n语法：struct 结构体名 数组名[元素个数] = {}\n\n#include &lt;bits/stdc++.h&gt;\n#define endl &#039;\n&#039;\nusing namespace std;\n// 创建数据类型\nstruct QAQ {\n    string s1;\n    int n1;\n    int n2;\n} s[10];\nint main()\n{\n    s[1] = { &quot;QAQ&quot;, 1, 2 };\n    cout &lt;&lt; s[1].s1;\n    // 或者\n    QAQ kk[5]; //第二种方法构建\n    cin &gt;&gt; kk[3].s1;\n    cout &lt;&lt; kk[3].s1;\n    return 0;\n}\n8.3 数组结构体\n\n\n结构体可以用数组表示，数组当然也可以放在结构体中\nint a[n]类型\nstruct test1\n{\n    string s;\n    int a[9];\n};\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    test1 st[t];\n    for (size_t i = 0; i &lt; t; i++) {\n        cin &gt;&gt; st[i].s;\n        for (size_t j = 0; j &lt; 9; j++) {\n            cin &gt;&gt; st[i].a[j];\n        }\n    }\n    return 0;\n}\n注意上述 int a[n]中的 n 为一个确定常数\nvector&lt;int&gt;类型\nstruct test1\n{\n    string s;\n    vector&lt;int&gt; a;\n};\nsigned main()\n{\n    //ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    test1 st[t];\n    for (size_t i = 0; i &lt; t; i++) {\n        cin &gt;&gt; st[i].s;\n        for (size_t j = 0; j &lt; 3; j++) {\n            int p;\n            cin &gt;&gt; p;\n            st[i].a.push_back(p);\n        }\n    }\n    for (auto &amp;&amp;i : st) {\n        cout &lt;&lt; i.s &lt;&lt; &quot; &quot;;\n        for (auto &amp;&amp;j : i.a) {\n            cout &lt;&lt; j &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n在上述构造方法中都没有对结构体里的数组进行初始化，下面是初始化的方法\n对 int a[n]而言：\n\n直接 结构体里int a[n] = {0};即可\n对 vectior&lt;int&gt;而言：\n采取显式调用即可\n\nvector&lt;int&gt; a = vector&lt;int&gt;(n,0);\n其中n为常数\n\n\n8.4结构体的构造函数\n结构体构造函数的形式与用法\n\n在 C++ 中，结构体（struct）的构造函数和类（class）的构造函数没有本质区别。构造函数是特殊的成员函数，用于在创建对象时初始化成员变量。构造函数的名称必须与结构体的名称相同。\n\n构造函数的形式\n1. 默认构造函数\n不带参数的构造函数，用于初始化成员变量为默认值。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n std::string name;\n int age;\n \n // 默认构造函数\n Person() : name(&quot;unknown&quot;), age(0) {}  // 使用初始化列表\n};\n \nint main() {\n Person p;  // 自动调用默认构造函数\n std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Age: &quot; &lt;&lt; p.age &lt;&lt; &quot;\n&quot;;\n return 0;\n}\n2. 带参数的构造函数\n构造函数可以接受参数，用于动态初始化成员变量。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n std::string name;\n int age;\n \n // 带参数的构造函数\n Person(const std::string&amp; n, int a) : name(n), age(a) {}\n};\n \nint main() {\n Person p(&quot;Alice&quot;, 25);  // 调用带参数的构造函数\n std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Age: &quot; &lt;&lt; p.age &lt;&lt; &quot;\n&quot;;\n return 0;\n}\n3. 构造函数重载\n^9f688f\n通过不同的参数列表定义多个构造函数，满足不同的初始化需求。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n std::string name;\n int age;\n \n // 默认构造函数\n Person() : name(&quot;unknown&quot;), age(0) {}\n \n // 带参数的构造函数\n Person(const std::string&amp; n, int a) : name(n), age(a) {}\n \n // 只初始化名字\n Person(const std::string&amp; n) : name(n), age(18) {}  // 默认年龄为18\n};\n \nint main() {\n Person p1;                      // 默认构造\n Person p2(&quot;Bob&quot;, 30);           // 带参数\n Person p3(&quot;Charlie&quot;);           // 只提供名字\n \n std::cout &lt;&lt; p1.name &lt;&lt; &quot;, &quot; &lt;&lt; p1.age &lt;&lt; &quot;\n&quot;;\n std::cout &lt;&lt; p2.name &lt;&lt; &quot;, &quot; &lt;&lt; p2.age &lt;&lt; &quot;\n&quot;;\n std::cout &lt;&lt; p3.name &lt;&lt; &quot;, &quot; &lt;&lt; p3.age &lt;&lt; &quot;\n&quot;;\n \n return 0;\n}\n输出\nunknown, 0\nBob, 30\nCharlie, 18\n\n4. 使用初始化列表\n初始化列表用于直接初始化成员变量，避免在构造函数体内赋值。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n std::string name;\n int age;\n \n // 使用初始化列表\n Person(const std::string&amp; n, int a) : name(n), age(a) {}\n};\n \nint main() {\n Person p(&quot;Diana&quot;, 22);  // 初始化时直接调用\n std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Age: &quot; &lt;&lt; p.age &lt;&lt; &quot;\n&quot;;\n return 0;\n}\n初始化列表的优点：\n\n提高效率：避免默认构造后再赋值。\n支持 const 和引用类型的初始化。\n\n特殊形式\n1. 委托构造函数（C++11 起支持）\n一个构造函数可以委托给另一个构造函数以复用初始化逻辑。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nstruct Person {\n    std::string name;\n    int age;\n \n    // 默认构造函数\n    Person() : Person(&quot;unknown&quot;, 0) {}  // 委托到另一个构造函数\n \n    // 带参数的构造函数\n    Person(const std::string&amp; n, int a) : name(n), age(a) {}\n};\n \nint main() {\n    Person p1;              // 默认构造\n    Person p2(&quot;Eve&quot;, 28);   // 带参数构造\n \n    std::cout &lt;&lt; p1.name &lt;&lt; &quot;, &quot; &lt;&lt; p1.age &lt;&lt; &quot;\n&quot;;\n    std::cout &lt;&lt; p2.name &lt;&lt; &quot;, &quot; &lt;&lt; p2.age &lt;&lt; &quot;\n&quot;;\n \n    return 0;\n}\n2. 删除的构造函数（C++11 起支持）\n可以显式删除某些构造函数，防止被意外调用。\n#include &lt;iostream&gt;\n \nstruct Person {\n    int age;\n \n    // 禁止隐式转换或默认构造\n    Person() = delete;  // 删除默认构造函数\n    Person(int a) : age(a) {}\n};\n \nint main() {\n    // Person p1;  // 编译错误：默认构造函数被删除\n    Person p2(30);  // 必须传入参数\n    std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; p2.age &lt;&lt; &quot;\n&quot;;\n    return 0;\n}\n构造函数的应用场景\n\n初始化成员变量\n\n为结构体或类的成员变量赋初始值，避免对象处于未定义状态。\n\n\n动态控制初始化\n\n可以根据参数灵活地初始化不同状态的对象。\n\n\n封装复杂逻辑\n\n在构造函数中封装一些初始化逻辑，简化外部代码。\n\n\n提高代码安全性\n\n使用委托构造或删除某些构造函数可以避免意外使用。\n\n\n\n总结\n\n构造函数是结构体中用来初始化成员变量的核心工具。\n通过默认构造、参数化构造、初始化列表等形式，可以满足多样化的初始化需求。\n推荐使用 初始化列表，特别是在初始化复杂类型（如 std::vector、引用、const 变量）时，效率更高。\n\n链表\n\n什么是链表：\n\n链表是一种用于存储数据的数据结构，通过如链条一般的指针来连接元素。它的特点是插入与删除数据十分方便，但寻找与读取数据的表现欠佳。\n\n\n链表的优势：对数据的处理：插入，删除  ——&gt; O(1) 但也因为这样，寻找、读取数据的效率不如数组高，在随机访问数据中的操作次数是 O(n)\n\n\n与数组相反的是，数组在随机访问数据下时间复杂度为O(1)，但插入删除数据为O(n)\n\n单向链表与双向链表的创建\n\n单向链表：单向链表包括两大数据类型，即数据域和指针域\n\nstruct Node\n{\n    int value;\n    Node *next; // 定义了一个指向该结构体(链表单位)的一个指针\n    Node(int val) : value(val), next(nullptr){}\n};\n这个结构体函数做了什么？\n\n\n初始化了一个新创建的结点，这个结点传入的参数默认赋值给了value，同时将结构体指针域默认赋值为了nullptr,表示其暂时不指向任何其他结点\n\n\n\n双向链表\n\n\n双向链表：也同样是数据域+指针域，但不同的是，指针域有左右(或上下)之分，用来链接上一个结点，当前结点，下一个结点\n\n\nstruct Node {\n    int value;\n    Node *left;\n    Node *right;\n    Node(int val) : value(val) , left(nullptr) , right(nullptr){}\n};\n\n向链表里写入与删去数据\n流程大致如下\n\n初始化待插入的数据 node；\n将 node 的 next 指针指向 p 的下一个结点；\n将 p 的 next 指针指向 node。\n但在这之前，我们要创建一个链表头\nNode *head = nullptr\n我们的操作都会在这个头链表上开始\n\n在头部插入数据\n时间复杂度O(1)\nvoid insert_head_node(Node *newnode, Node *&amp;head)\n{\n    newnode-&gt;next = head;\n    head = newnode;\n}\n在某一个pos值上插入元素\nvoid insert_pos_node(Node *newnode, int pos, Node *&amp;head)\n{\n    if (pos == 0) {\n        newnode-&gt;next = head;\n        head = newnode;\n        return;\n    }\n    Node *current = head;\n    int currentposition = 0;\n    while (current != nullptr &amp;&amp; currentposition &lt; pos - 1) {\n        current = current-&gt;next;\n        currentposition++;\n    }\n    newnode-&gt;next = current-&gt;next;\n    current-&gt;next = newnode;\n}\n在尾部插入元素\n在单向链表尾部插入元素，时间复杂的O(n)\nvoid insert_end_node(Node *Newnode, Node *&amp;p)\n{\n    // Node *Newnode = new Node(i);\n    if (p == nullptr) {\n        p = Newnode;\n        return;\n    }\n    Node *current = p;\n    while (current-&gt;next != nullptr) {\n        current = current-&gt;next;\n    }\n    current-&gt;next = Newnode;\n}\n删除某一结点\n\n删除某一特定值的结点\n\nvoid delnode(int i, Node *&amp;p)\n{\n    //链表为空\n    if (p == nullptr) return;\n    //头结点为目标值\n    while (p != nullptr &amp;&amp; p-&gt;val == i) {\n        Node *temp = p;\n        p = p-&gt;next;\n        delete temp;\n        t--;\n    }\n    //中间或尾部结点为目标\n    Node *current = p;\n    while (current != nullptr &amp;&amp; current-&gt;next != nullptr) {\n        if (current-&gt;next-&gt;val == i) {\n            Node *temp = current-&gt;next;\n            current-&gt;next = current-&gt;next-&gt;next;\n            delete temp;\n            t--;\n        }\n        else {\n            current = current-&gt;next;\n        }\n    }\n}\n\n删除某一位置的结点\n\nvoid posdel(int pos, Node *&amp;head)\n{\n    if (head == nullptr || pos &lt; 0) return;\n    if (pos == 0) {\n        Node *temp = head;\n        head = head-&gt;next;\n        delete temp;\n        return;\n    }\n    Node *current = head;\n    for (int i = 0; i &lt; pos &amp;&amp; current != nullptr; i++) {\n        current = current-&gt;next;\n    }\n    if (current == nullptr || current-&gt;next == nullptr) return;\n    Node *temp = current-&gt;next;\n    current-&gt;next = current-&gt;next-&gt;next;\n    delete temp;\n}"},"编程语言/C++/基础语法/运算符":{"slug":"编程语言/C++/基础语法/运算符","filePath":"编程语言/C++/基础语法/运算符.md","title":"运算符","links":[],"tags":[],"content":"3 运算符\n**作用：**用于执行代码的计算\n主要有一下几种运算符：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符类型作用算术运算符用于处理四则运算赋值运算符用于将表达式的值赋给变量比较运算符用于表达式的比较，返回一个真值或假值逻辑运算符用于根据表达式的值返回真值或假值\n\n3.1 算术运算符\n**作用：**用于处理四则运算\n包括一下符号：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符术语示例结果+正数+3+3-负数-4-4+加号4+59-减号6-33*乘号6*742/[^1]除号94/713%取模(取余)10%31++前置递增a=2 b=++aa=3 b=3++后置递增a=2 b=a++a=3 b=2—前置递减a=2 b=—aa=1 b=1—后置递减a=2 b=a—a=1 b=2\n示例1四则运算的示例\nint main()\n{\n    int a1 = 10;\n    int b1 = 7;\n    cout&lt;&lt;a1 + b1 &lt;&lt;endl;\n    cout&lt;&lt;a1 - b1 &lt;&lt;endl;\n    cout&lt;&lt;a1 * b1 &lt;&lt;endl;\n    cout&lt;&lt;a1 / b1 &lt;&lt;endl; //这里为整除运算，结果也会为整数\n \n    float a2 ;\n    float b2 ;\n    cout&lt;&lt;&quot;请输入两个浮点数&quot;&lt;&lt;endl;\n    cin &gt;&gt; a2;\n    cin &gt;&gt; b2;\n    cout&lt;&lt; &quot;a2除以b2的值为&quot;&lt;&lt;a2 / b2&lt;&lt;endl; //这里是非整除\n    \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n取模运算本质就是取余数\n两个小数之间不能做取模运算\n\n前置递增与后置递增\n\n前置，后置递增都是使变量进行加一的操作\n前置递增:先对变量进行递增，再进行表达式运算\n后置递增:先进行表达式的运算，再对变量递增\n\nint main()\n{\n    //前置运算\n    int a = 10;\n    int b = 3;\n    int r1 = ++a * b; \n    cout&lt;&lt;&quot;r1=&quot;&lt;&lt; r1 &lt;&lt;endl; \n \n    //后置运算\n    int a2 = 10;\n    int b2 = 3;\n    int r2 = a2++ * b2; \n    cout&lt;&lt;&quot;r2=&quot;&lt;&lt; r2 &lt;&lt;endl;\n    cout&lt;&lt;&quot;a2=&quot;&lt;&lt;a2&lt;&lt;endl; \n \n    system(&quot;pause&quot;);\n    return(0);\n}\n\n\n\n我们不难发现，在上述代码运算过程中我们的”a”变量先被加1再参与到了运算之中，而我们的”a2”变量则是再运算结束后才被加1\n\n\n\n3.2赋值运算符\n**作用：**将表达式的值赋给变量\n主要包括以下几个符号：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符术语示例结果=赋值a=10a=10+=加等于a=10 a+=2a=12-=减等于a=10 a-=2a=8*=乘等于a=10 a*=2a=20/=除等于a=10 a/=2a=5%=取模等于a=10 a%=2a=0\n3.3 比较运算符\n**作用：**用于比较表达式的真假，并返回一个真值或假值\n主要有以下的符号：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符术语示例结果==相等于4 == 30!=不等于4 != 31&lt;小于4 &lt; 30&gt;大于4 &gt; 31⇐小于等于4 ⇐ 30&gt;=大于等于4 &gt;= 31\ntips：再代码中由于有优先级的影响，我们可以这么提升运算优先级 cout &lt;&lt; (a == b)&lt;&lt; denl;\n3.4 逻辑运算符\n**作用：**用于根据表达式的值返回真值或假值\n主要有以下符号:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符术语示例结果！非!a如果a为假，则!a为真；如果a为真，则!a为假&amp;&amp;与a&amp;&amp;b如果a和b都为真，则结果为真，否则为假||或a||b如果a和b中有一个为真，则结果为真，二者都为假的时候，结果为假\n3.4.1 逻辑非\nint main()\n{\n    //逻辑非\n    int a= 10 ;\n    cout &lt;&lt; !a &lt;&lt; endl;\n    //运算结果为 0 (解释:在C++中，只要结果不为0，都视为真，故输出结果为假)\n    cout &lt;&lt; !!a &lt;&lt; endl;\n    //结果为1，取了两次反（从真变假再变真）\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n总结:真变假，假变真\n\n3.4.2 逻辑与\nint main()\n{\n    // 逻辑与\n    int a = 10;\n    int b =10;\n    cout &lt;&lt; (a&amp;&amp;b) &lt;&lt; endl; //此处也要优先运算\n    //运算结果为 1 (真)\n    a = 10;\n    b = 0;\n    cout &lt;&lt; (a&amp;&amp;b) &lt;&lt; endl;\n    //运算结果为 0 (假)\n    a = 0;\n    b = 0;\n    cout &lt;&lt; (a&amp;&amp;b)&lt;&lt;endl;\n    //运算结果为 0 (假)\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n总结: 同真为真，其余为假\n\n3.4.3 逻辑或\nint main()\n{\n    //逻辑或\n    int a = 10;\n    int b = 10;\n    cout &lt;&lt; (a||b)&lt;&lt;endl;\n    //结果为1\n \n    a = 0;\n    b = 10;\n    cout &lt;&lt; (a||b)&lt;&lt;endl;\n    //结果仍为1\n    a=0;\n    b=0;\n    cout &lt;&lt; (a||b)&lt;&lt;endl;\n    //结果为0\n    system(&quot;pause&quot;);\n    return(0);\n}\n\n总结: 同假为假，其余为真\n\n"},"编程语言/Java/0.入门":{"slug":"编程语言/Java/0.入门","filePath":"编程语言/Java/0.入门.md","title":"0.入门","links":[],"tags":[],"content":"\n很诡异的一门课,编程实力并不等价于考试分数,考试还是很老套的手写卷\n\n\n但是老师很好\n"},"编程语言/Java/1.基本语法速通":{"slug":"编程语言/Java/1.基本语法速通","filePath":"编程语言/Java/1.基本语法速通.md","title":"1.基本语法速通","links":[],"tags":[],"content":""},"编程语言/Python/CS61A/1.Introduce":{"slug":"编程语言/Python/CS61A/1.Introduce","filePath":"编程语言/Python/CS61A/1.Introduce.md","title":"1.Introduce","links":["Linux/折腾/最好的linux发行版——WSL2的使用","编程语言/C++/基础语法/C++语言入门","基础入门/MIT-Missing-Semester/前言"],"tags":[],"content":"\n在开始前必须明确，本课程在不说明的情况下所有的程序运行均在 manjaro for wsl2 下执行，一些不涉及大型项目的操作与作业程序也均在上述操作系统下进行\n\n1.0.导论\n在学习这个课程之前，建议先修课程\n\n程序设计基础\nMIT-Missing-Semester (可选)\n\n为了定义计算过程，我们需要一种被人们广泛使用和各类电脑广泛接受的编程语言，在本课程中，我们将主要使用 Python 语言。\n因为这一门课程都会使用Python作为编程语言，所以必须好好配置我们的编程环境\n我这里选择 Visual Studio Code + wsl2 进行编写代码\n由于Linux的原因，我们可以非常轻松的配置环境，所以我们不必要纠结过多在环境配置与下载上\n1.1.开始\n1.1.1 交互式会话\n要启动python的交互式会话，我们可以在终端中输入 python 如何你看到这样的提示说明你已经进入\nPython 3.13.5 (main, Jun 21 2025, 09:35:00) [GCC 15.1.1 20250425] on linux\nType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.\n&gt;&gt;&gt;\n我们可以输入一些示例来展示\n&gt;&gt;&gt; 2 + 2\n4\n\n在交互式会话中，我们可以使用方向键上下控制输入的历史记录\n\n\n第一个例子\n\n\n                  \n                  Note\n                  \n                \n\n\n课程中的Python脚本几乎都是使用交互语言书写的，但是在课程中我们会结合文件式的编程一起结合来看\n\n\n\nfrom urllib.request import urlopen\n \nshakespeare = urlopen(&#039;www.composingprograms.com/shakespeare.txt&#039;)\n \nwords = set(shakespeare.read().decode().split())\n \n# 这是一个从互联网上下载莎士比亚的文本文件，并将其中的单词存储在一个集合中的代码。\n \nfor w in words :\n    if len(w) == 6 and w[0] == &#039;a&#039; and w[-1] == &#039;e&#039;:\n        print(w)\n我们用多种语言特性来介绍 Python ，我们可以将这一章看作是即将到来的功能的一个预览，在下一节课我们从头开始逐步了解整个语言\npy内置了一些常见的编程功能，例如处理文本，显示图像以及通过互联网进行通讯\n&gt;&gt;&gt; form urllib.request import urlopen\n这是一个 improt 语句，会导入一个 “访问互联网” 的功能，这个功能提供了一个函数 urlopen 可以访问到某个网址上的内容\n语句与表达式\nPython代码由表达式和语句构成，进一步的：计算机程序由以下指令组成：\n\n计算一些值\n执行一些操作\n这些语句通常会描述操作，Python解释器每执行一条语句，计算机就会执行相应的操作，这也是Python与C++的不同之处\n\n下面的赋值语句\n&gt;&gt;&gt; shakespeare = urlopen(&#039;www.composingprograms.com/shakespeare.txt&#039;)\n将 shakespeare 用 = 与后面一大串东西链接在一起,代表后面函数的返回值将被赋值给前面的变量，这个数据的转化可能会很复杂，但我们不需要关心这些，我们只需要理解函数的转化\n函数：封装一系列操作数据的逻辑。在例子中 urlopen 就是一个函数，封装了将 网址数据 → 文字数据 这一系列的操作\n另外一个赋值语句\n&gt;&gt;&gt; words = set(shakespeare.read().decode().split())\n这个语句将 words 与 莎士比亚剧本中33721个单词的集合相连，其命令链条调用了 read,decode,split ，每个函数都会操作一个中间的计算实体：\n\n从 URL 中 read（读取）数据，然后将数据 decode (解码)为文本，最后将文本 split (拆分)为单词放在一个 set 中\n\n对象： set 就是一种对象，支持如交集并集之类的集合运算。对象整合了数据以及操作这个数据的逻辑，并且隐藏了两者的复杂性\n最后这个表达式:\n&gt;&gt;&gt; {w for w in words if len(w) == 6 and w[::-1] in words}\n{&#039;redder&#039;, &#039;drawer&#039;, &#039;reward&#039;, &#039;diaper&#039;, &#039;repaid&#039;}\n是一个符合表达式，这个计算结果是反转后也为莎士比亚单词里的单词的集合表达式。神秘符号 w[::-1] 表示反向枚举w的每一个字母\n最后，我们会发现所有这些核心概念都是紧密相关的：函数是对象，对象是函数，解释器是二者的实例。但是，清楚地理解每一个概念及其在组织代码中的作用对于掌握编程艺术至关重要\n\n1.2.错误\n与所有编程语言一样，哪怕是出现一个单词的拼写错误也会导致整个程序的错误与失效\n我们必须学习一些解释错误和找到错误的技巧，我们称之为 调试\n关于调试的一些指导性原则\n\n增量测试\n隔离错误\n检查我们的假设\n咨询他人\n"},"编程语言/Python/CS61A/2.Functions":{"slug":"编程语言/Python/CS61A/2.Functions","filePath":"编程语言/Python/CS61A/2.Functions.md","title":"2.Functions","links":["编程语言/Python/CS61A/1.Introduce","编程语言/Python/CS61A/Something/Python同名函数传参","编程语言/Python/CS61A/Something/语言类型与转换"],"tags":[],"content":"2.1.编程要素\n编程语言不仅是一种指挥计算机执行任务的手段，它应该成为一种框架，使我们能够在其中组织我们的有关计算过程的思想。\n同时，程序也在编程社区中传递想法，所以，编程语言必须是人类可以阅读的并且恰巧可以被机器执行\n\n2.1.1表达式\n在上一节中我们解释的Python的解释器，下面我们将重新开始，一步步讲解Python语言\n我们先从最基本的表达式开始 数字 number\n&gt;&gt;&gt; 42\n42\n&gt;&gt;&gt; pi\nTraceback (most recent call last):\n  File &quot;&lt;python-input-1&gt;&quot;, line 1, in &lt;module&gt;\n    pi\nNameError: name &#039;pi&#039; is not defined\n&gt;&gt;&gt; from math import pi\n&gt;&gt;&gt; pi\n3.141592653589793\n在上面这个例子上我们发现，Python认识我们输入的数字，在导入库后也认识了一些常数，而这些基本表达式可以在一些操作符和运算符之间进行运算\n2.1.2.调用表达式\n我们可以将一些表达式与变量调用到函数的参数上，在Python中函数的应用方式与传统数学相同\n&gt;&gt;&gt; max(pi,(14/3+5*0.13)/2*pi)\n8.351400470792868\n&gt;&gt;&gt; from math import sin\n&gt;&gt;&gt; sin(pi/2)\n1.0\n在这个例子中我们展示了两个函数 max 和 sin\n\n对 max 函数，他接受两个变量并且支持接受表达式\n对 sin 函数，他只接受一个表达式\n这两个例子都在说明我们调用表达式的时候，可以在表达式内添加一个子表达式\n\n在调用表达式的时候，参数的顺序也是很重要的，比如当我们调用 pow 函数的时候，它的第二个参数是第一个参数的幂\n&gt;&gt;&gt; pow(2,3)\n8\n&gt;&gt;&gt; pow(2,3,4)\n0\n\n注意到第四行奇怪的地方了吗？第一眼看上去可能认为这是和C++一样的 函数重载 但是其实并非这么一回事\n在 Python同名函数传参 这里我们会详细探讨一下这种情况\n\n2.1.3.导入库函数\n在Python中实际上定义了大量的函数，但是我们不能直接使用他们，我们需要导入他们的库函数才能实现对他们的调用。\n例如在math中提供了许多熟悉的数学函数\n&gt;&gt;&gt; from math import sqrt\n&gt;&gt;&gt; sqrt(256)\n16.0\n\nimprot 语句需要指定模块名称(例如 math 或 operator)，然后列出要导入这个模块的具体名称\n当我们尝试将整个库都导入时候，我们就可以直接输入 import [库名] ，在我们调用这个库中的函数的时候就需要在函数名字之前添加库的名称 math.pow()\n我们也可以使用 as 语法为库名添加别名\n\nimport operator as op\nop.add(1,2) # same as a + b\n2.1.4.名称与环境\n编程语言的一个要素就是使用名称来引用计算对象，如果一个值被赋予了名称，就说名称被绑定到了这个值上\n在Python中，我们使用赋值语句来建立新的绑定，即 = 左边的是名称右边的是值\n&gt;&gt;&gt; radius = 10\n&gt;&gt;&gt; radius\n10\n&gt;&gt;&gt; 2 * radius\n20\n\n在Python中 = 被称为 赋值 符号，与C++不同的是，C++属于强类型语言， = 两边的类型至少应该相似，但是python具有多态特性， = 是 Python里最简单的 抽象 方法，在此我们不讨论过多，感兴趣可以看看我写的 语言类型与转换\n\n同时，将名称与值绑定，之后通过名称检索可能的值，就意味着解释器必须维护某种内存来记录名称、值和绑定，这种内存就是环境\n你甚至可以将名称与函数绑定\n&gt;&gt;&gt; max\n&lt;built-in function max&gt;\n&gt;&gt;&gt; f = max\n&gt;&gt;&gt; f\n&lt;built-in function max&gt;\n&gt;&gt;&gt; f(1,2,5)\n5\n&gt;&gt;&gt; max = 7\n&gt;&gt;&gt; max\n7\n&gt;&gt;&gt; f(1,2,max)\n7\n&gt;&gt;&gt; max(1,2)\nTraceback (most recent call last):\n  File &quot;&lt;python-input-12&gt;&quot;, line 1, in &lt;module&gt;\n    max(1,2)\n    ~~~^^^^^\nTypeError: &#039;int&#039; object is not callable\n&gt;&gt;&gt; max = f\n&gt;&gt;&gt; max(1,2)\n2\n在上面的例子中我们发现，不仅可以将 f 赋值为 max ,也可以将 max 变成其他东西，但是当我们将 max 变为其他东西的时候， max 就失去了作为函数的能力\n与C++类似的是，Python在执行赋值语句的时候会先求解右侧的表达式，再将结果与左侧的名称绑定\n对于多重赋值，所有 = 右边的表达式都会先求值，然后再与左边的名称绑定。\n&gt;&gt;&gt; x,y = 3,4.5\n&gt;&gt;&gt; y,x = x,y\n&gt;&gt;&gt; x\n4.5\n&gt;&gt;&gt; y\n3\nPython中还有一种允许我们创建名称的方法，即 创建新函数\n&gt;&gt;&gt; def name(参数):\n...     return 返回值\n例如：\n&gt;&gt;&gt; def square(x):\n...     return x*x\n...\n&gt;&gt;&gt; square\n&lt;function square at 0x7ca186cd2840&gt;\n&gt;&gt;&gt; square(7)\n49\n&gt;&gt;&gt; square(7+9)\n256\n&gt;&gt;&gt; square(square(3))\n81\n这就是自定函数的操作\n我们也可以将自定函数写入另外一个自定函数中，同时，我们也可以构造一个无参数的函数用于返回值\n&gt;&gt;&gt; r = 10\n&gt;&gt;&gt; from math import pi\n&gt;&gt;&gt; def area():\n...     return pi * r * r\n...\n&gt;&gt;&gt; area()\n314.1592653589793\n&gt;&gt;&gt; r = 20\n&gt;&gt;&gt; area()\n1256.6370614359173\n我们发现在上述过程中我们更新 r 的值后重新调用 area() 函数也会更新\n下面我们来深入讲解一下定义函数\n2.2.定义函数\n定义函数是我们在学习和使用Python中最重要的一件事情，这是一种更加强大的抽象方式，将一系列简单或复杂的事物抽象成一个函数名使我们在调用的时候无需关系具体的实现过程\n定义一个新函数的语法是\ndef &lt;name&gt;(&lt;formal parameters&gt;)\n\treturn &lt;return expression&gt;\n第一行中 &lt;name&gt; ... 被称为函数声明，他定义了函数名称以及需要调用的参数\n第二行中 return ... 告诉函数应该返回什么\n对于函数，在我们编写函数整体的时候，实际上没有进行任何操作，我们只是将规则编写下来并且保存到我们的环境中，只有真正调用的时候才会执行函数中编写的内容，这一点上与 C++ 是类似的\n\n2.2.1 环境\n虽然现在我们对Python的了解已经足够复杂，但是程序的意义并不是很明显。如果特定形参与内部函数同名那么我们应该怎么办？\n在Python中，求解表达式的环境由帧构成,每个帧都包含了一些 绑定 而全局帧只有一个。同时，赋值和导入语句会将条目添加到当前环境的第一帧\n\n下面有一段 html 嵌入代码向我们展示了可视化的栈帧生成以及返回的流程，我们也可以在Online Python Tutor 自己尝试\n\n \n我们可以发现这个环境图上 `Global frame` 储存了两个变量，其都是存储在全局的栈帧上的，而当我们导入函数或者创建函数后都会有新的对象出现，示例如下\n\n\n现在我们可以给出一个递归的例子来辅助我们了解栈帧这一概念\n \n我们主要这个函数 f ，它在其函数体内调用了本身，构成了一个 自己调用自己 的场景\n\n每当函数 f 调用新的函数 f 时候，都会额外开出一个栈帧用来进行新函数 f 的运行\n当这个 f 运行结束返回值的时候，这个返回值会在这个栈里自下而上的进行直到回到全局栈帧\n\n2.2.2 调用用户定义的函数"},"编程语言/Python/CS61A/Something/Python同名函数传参":{"slug":"编程语言/Python/CS61A/Something/Python同名函数传参","filePath":"编程语言/Python/CS61A/Something/Python同名函数传参.md","title":"Python同名函数传参","links":[],"tags":[],"content":"在Python中没有像C++那样直接的函数重载(Function Overloading), C++ 允许你定义多个同名函数，只要它们的参数列表(参数类型、参数数量或参数顺序)不同即可。\n编译器会根据传入的参数类型自动选择正确的函数版本。\nPython 采取了一种不同的方式来处理类似的需求：\n1.默认参数\n在 Python 中你可以给函数的参数设置默认值，这样在调用函数时就可以选择性地省略这些参数\ndef pow(base, exp , mod = None):\n    &quot;&quot;&quot;\n    计算模下的base的exp次幂,如果mod不为None,则计算模mod的结果。\n    &quot;&quot;&quot;\n    if mod == None:\n        return base ** exp\n    else:\n        return (base ** exp) % mod\nprint(pow(1,2))\nprint(pow(2,3,5))\n这里就为我们展示了默认参数的例子\n2.可变参数\nPython可以使用 *arge 来接受任意数量的位置参数使用,**kwargs 来接受任意数量的关键字参数\ndef my_function(*args):\n    if len(args) == 1:\n        print(f&quot;一个参数: {args[0]}&quot;)\n    elif len(args) == 2 and isinstance(args[0], int) and isinstance(args[1], int):\n        print(f&quot;两个整数参数: {args[0]} 和 {args[1]}&quot;)\n    elif len(args) &gt; 2:\n        print(f&quot;多个参数: {args}&quot;)\n    else:\n        print(&quot;没有参数&quot;)\n \nmy_function()\nmy_function(10)\nmy_function(1, 2)\nmy_function(&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;)\n3.多态\nPython 的一大特性是多态。由于 Python 是动态类型语言，函数在被调用时并不关心参数的具体类型，只要对象支持所需的操作即可。例如，你可以定义一个函数来处理任何可迭代对象\ndef process_data(data):\n    for item in data:\n        print(item)\n \nprocess_data([1, 2, 3])      # 列表\nprocess_data(&quot;hello&quot;)       # 字符串\nprocess_data((4, 5, 6))     # 元组"},"编程语言/Python/CS61A/Something/语言类型与转换":{"slug":"编程语言/Python/CS61A/Something/语言类型与转换","filePath":"编程语言/Python/CS61A/Something/语言类型与转换.md","title":"语言类型与转换","links":[],"tags":[],"content":"我们可以这样说明\nC++类需要显式说明某一个变量名称是什么类型的语言我们将其称为静态语言\npy类无需显式说明的我们称之为动态语言\n在Python中\na = 114\na = &quot;514&quot;\nb = 1919\nb = a\n这一系列操作的都是合法的，Python的变量本身并不绑定一个特定的类型，而是 引用 一个值。当我们进行赋值时，变量只是指向内存中一个对象的标签。这个对象可以是任何类型，并且这个标签可以随时被重新指向另一个不同类型的对象。"}}