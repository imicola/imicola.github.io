<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>曦&#039;s Blog</title>
      <link>https://imicola.github.io</link>
      <description>最近的10条笔记 on 曦&#039;s Blog</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>BFS 广度优先搜索</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2</guid>
    <description><![CDATA[ 搜索 递归与递推 BFS 广度优先搜索 在前面我们介绍过深度优先搜索 DFS，深搜的核心思想是一条路走到底，直到得到符合的结果或者超出边界情况结束 而广度优先搜索则是从起始位置出发，每一次向外增加一圈，或执行完一大个操作之后再将计数变量增加 广搜一般适用于求最短路径，求最少操作次数的这些操作，因为广搜本身便是向外扩散式的一种搜索 广搜一般使用STL中的Queue 队列作为承接模板，通过其先进先出的特点实现广搜 例题：洛谷P1135 奇怪的电梯 signed main() { int n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; vector&lt... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>Boyer-Moore 投票算法</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Boyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Boyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95</guid>
    <description><![CDATA[ 模拟 模板 Boyer-Moore 投票算法 背景：数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素，若不存在，输出 -1 一般我们习惯想到的方法是利用unordered_map 来存储每个数出现的次数，当发现有数字超过一半的时候，输出该数字，没有则在最后输出 -1 上述方法时间复杂度和空间复杂度均为 O(n) ,而接下来介绍的算法，可以让空间复杂度降低到 O(1) Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等 如果数组为空，则数组不存在主要元素 如果数... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>区间DP</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP</guid>
    <description><![CDATA[ 引入 给定一堆长度为 n 的石子，每个石子有其重量 a_i ,你需要做的是不断的合并相邻石子，每次合并i,j两堆石子需要付出 a_i + a_j的代价，你必须不断合并直到所有石子均被合并完成。你需要知道你付出的最小代价是多少 特点 区间dp的特点我们一般认为有以下 在某一个序列上的一个区间进行操作,如(合并) 可以利用子区间的最优解来构造全局的最优解 dp含义以及状态转移 状态定义： 区间状态，我们定义dp[\,i \,][\,j\,]表示从位置 i 到位置 j 的最优解(最小代价，最大收益等) 对于每一个 dp[\,i\,][\,j\,] 我们都应该保证其状态能从子区间转移而来 状态转移： ... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>背包DP</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP</guid>
    <description><![CDATA[ 背包问题 动态规划 背包DP 两个特点： 一个物体有 大小 + 价值 有一个背包只能容纳某一个特定大小 要求：找最大价值 一般性转移方程——&gt; 设背包大小为 N,有 Y 个物品 , 物品价值为 val_i 物品大小为 size_j 设dp[i][j] 表示任取 0\to i 个物品在j时间下取得的\sum a_k的最大值 初始化见下： vector&lt;vector&lt;int&gt;&gt; dp(Y,vector&lt;int&gt;(N+1,0)); //对[0]行的初始 for (size_t i = size[0]; i &lt;= N; i++) { dp[0][i] =... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>Ranges库</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Ranges%E5%BA%93</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Ranges%E5%BA%93</guid>
    <description><![CDATA[ 语法 range::find(v,‘1’); 在容器 v 内查找传入的第二个参数，返回值是第一个找到的参数的迭代器，如果没找到，则返回v.end() range::minmax(v) 以一个pair形式返回容器中的最大值和最小值 //常用接收形式 auto [s1,s2] = ranges::minmax(v) ranges::max_element(v) 如果不进行二次传参，则返回范围内最大的一个元素的迭代器 如果进行二次传参，则可以创建一个映射关系，返回映射关系下最大的那个元素的迭代器，例如： vector&lt;string&gt; v = {&quot;12&quot;,&quot;1... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>Readme</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Readme</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Readme</guid>
    <description><![CDATA[ 如何优雅地食用这个 C++ 语法笔记仓库？ 确保你拥有 git 并掌握一定的git知识 确保你使用的笔记软件是 obsidian 确保你会使用github的基础功能 准备工作完毕，现在开始食用吧 同步更新使用如下 fork这个仓库 到你fork好的仓库里，用git克隆下来这个仓库 用 obsidian 打开这个仓库如下的路径： D:\Code film\C++\memo\C++语法(新) 定期用git同步fork的仓库即可 非同步更新如下： 使用git克隆这个仓库 git clone github.com/imicola/Questions-and-Impressions.git 用 obsi... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>stringstream</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/stringstream</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/stringstream</guid>
    <description><![CDATA[ 语法 字符串 C++针对字符串的读写有一套专门的方法，即stringstream 语法规则： stringstream ss(str) str是你想进行操作的字符串 场景： 读取字符串中的数据：你可以通过 stringstream 从字符串中提取整数、浮动数、字符等。 将数据写入字符串：可以将不同类型的数据输出到一个字符串中。 main(){ //读入 std::stringstream ss(str); int num1, num2; ss &gt;&gt; num1 &gt;&gt; num2; // 从stringstream读取数据 std::cout &lt;&lt; &quot;n... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>二分</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86</guid>
    <description><![CDATA[ 二分 二分 二分是一个经典思想，包含二分查找和二分答案 1 二分查找 在一串升序排列的数字中，找到某一个数字 k 思路： 维护一个左右边界 l,r，其中初始时, l = \min(a_n)|_n , r= \max(a_n)|_n (即最大值和最小值的下标) 进行循环，直到 l &gt; r,在每个循环做如下操作 维护一个mid, 其为mid = (l + r + 1)/2 判断a_{mid} = k 是否成立 如果a_{mid} &lt; k 则让 l = mid + 1； 如果a_{mid} &gt; k 则让 r = mid - 1; 跳出循环，此时mid即为数k的下标 2 二分答案 二... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>二进制</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/%E4%BA%8C%E8%BF%9B%E5%88%B6</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/%E4%BA%8C%E8%BF%9B%E5%88%B6</guid>
    <description><![CDATA[ 数学 二进制 位运算 快速获取某一个数的二进制 法一: 从原理上获取 一个数的二进制的计算可以通过将这个数反复整除2且取模2来获得其位数，直到这个数变为0 #include &lt;iostream&gt; #include &lt;vector&gt; std::string decimalToBinary(int n) { if (n == 0) return &quot;0&quot;; std::string binary; while (n &gt; 0) { binary = (n % 2 == 0 ? &quot;0&quot; : &quot;1&quot;) + binary... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>位运算</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97</guid>
    <description><![CDATA[ 位运算 二进制 数学 两数之间的运算符 两数的运算符有 「与，或，异或」三种运算方式，它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。 运算运算符数学符号解释与&amp;\And,and只有两个对应位都为 1 时才为 1或|\mid,or只要两个对应位中有一个 1 时就为 1异或^\oplus,xor只有两个对应位不同时才为 1 一些总结经验： 对或(|)运算而言，有如下性质： a \mid b = b \mid a \left( a \mid b \right) \mid c = \left( b \mid c \right) \mid a a \mid 0 = a a \m... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item>
    </channel>
  </rss>