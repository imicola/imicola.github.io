<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>imicola&#039;s Blog</title>
      <link>https://imicola.github.io</link>
      <description>最近的10条笔记 on imicola&#039;s Blog</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>数位DP</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP</guid>
    <description><![CDATA[  ]]></description>
    <pubDate>Sat, 19 Jul 2025 16:00:00 GMT</pubDate>
  </item><item>
    <title>数据整理</title>
    <link>https://imicola.github.io/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/MIT-Missing-Semester/%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86</link>
    <guid>https://imicola.github.io/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/MIT-Missing-Semester/%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86</guid>
    <description><![CDATA[ 当我们试图在输出很多的地方(系统日志,长文本)中找到自己需要的东西的时候,我们就需要进行数据的整理 在之前的学习中,我们就已经接触过一些数据整理的基本技术.比如当我们使用 | 管道运算符向 grep 发送东西的时候,实际上就是一种数据整理,例如 history | grep &quot;grep&quot; 就是在我输入过的命令中寻找 grep 如何进行数据整理 例如当我们试图在系统日志中找到imicola. ]]></description>
    <pubDate>Sat, 19 Jul 2025 16:00:00 GMT</pubDate>
  </item><item>
    <title>杂项练习笔记1</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B01</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B01</guid>
    <description><![CDATA[ 杂项练习 0 点子王 万能头文件 #include&lt;bits/stdc++.h&gt;(可以解决大部分头文件问题) 使用 printf(&quot;%.2f&quot;,[输出])来输出保留两位的小数 小写字母的ASCII码是大写字母的ASCII + 32 在处理时间问题时，我们不妨全部转化为最小的时间单位，再用循环回复时间格式 字符串/字符 进行比较的时候要用stramp(a,b) 当 str1 &lt; str2 时，返回为负数(-1)； 当 str1 == str2 时，返回值= 0； 当 str1 &gt; str2 时，返回正数(1)。 Tip 更新：对字符串来说也可以用 ==... ]]></description>
    <pubDate>Fri, 18 Jul 2025 03:33:54 GMT</pubDate>
  </item><item>
    <title>BFS 广度优先搜索</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2</guid>
    <description><![CDATA[ 搜索 递归与递推 BFS 广度优先搜索 在前面我们介绍过深度优先搜索 DFS，深搜的核心思想是一条路走到底，直到得到符合的结果或者超出边界情况结束 而广度优先搜索则是从起始位置出发，每一次向外增加一圈，或执行完一大个操作之后再将计数变量增加 广搜一般适用于求最短路径，求最少操作次数的这些操作，因为广搜本身便是向外扩散式的一种搜索 广搜一般使用STL中的Queue 队列作为承接模板，通过其先进先出的特点实现广搜 例题：洛谷P1135 奇怪的电梯 signed main() { int n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; vector&lt... ]]></description>
    <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
  </item><item>
    <title>Boyer-Moore 投票算法</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Boyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Boyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95</guid>
    <description><![CDATA[ 模拟 模板 Boyer-Moore 投票算法 背景：数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素，若不存在，输出 -1 一般我们习惯想到的方法是利用unordered_map 来存储每个数出现的次数，当发现有数字超过一半的时候，输出该数字，没有则在最后输出 -1 上述方法时间复杂度和空间复杂度均为 O(n) ,而接下来介绍的算法，可以让空间复杂度降低到 O(1) Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等 如果数组为空，则数组不存在主要元素 如果数... ]]></description>
    <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
  </item><item>
    <title>区间DP</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP</guid>
    <description><![CDATA[ 引入 给定一堆长度为 n 的石子，每个石子有其重量 a_i ,你需要做的是不断的合并相邻石子，每次合并i,j两堆石子需要付出 a_i + a_j的代价，你必须不断合并直到所有石子均被合并完成。你需要知道你付出的最小代价是多少 特点 区间dp的特点我们一般认为有以下 在某一个序列上的一个区间进行操作,如(合并) 可以利用子区间的最优解来构造全局的最优解 dp含义以及状态转移 状态定义： 区间状态，我们定义dp[\,i \,][\,j\,]表示从位置 i 到位置 j 的最优解(最小代价，最大收益等) 对于每一个 dp[\,i\,][\,j\,] 我们都应该保证其状态能从子区间转移而来 状态转移： ... ]]></description>
    <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
  </item><item>
    <title>背包DP</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP</guid>
    <description><![CDATA[ 背包问题 动态规划 背包DP 两个特点： 一个物体有 大小 + 价值 有一个背包只能容纳某一个特定大小 要求：找最大价值 一般性转移方程——&gt; 设背包大小为 N,有 Y 个物品 , 物品价值为 val_i 物品大小为 size_j 设dp[i][j] 表示任取 0\to i 个物品在j时间下取得的\sum a_k的最大值 初始化见下： vector&lt;vector&lt;int&gt;&gt; dp(Y,vector&lt;int&gt;(N+1,0)); //对[0]行的初始 for (size_t i = size[0]; i &lt;= N; i++) { dp[0][i] =... ]]></description>
    <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
  </item><item>
    <title>Ranges库</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Ranges%E5%BA%93</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Ranges%E5%BA%93</guid>
    <description><![CDATA[ 语法 range::find(v,‘1’); 在容器 v 内查找传入的第二个参数，返回值是第一个找到的参数的迭代器，如果没找到，则返回v.end() range::minmax(v) 以一个pair形式返回容器中的最大值和最小值 //常用接收形式 auto [s1,s2] = ranges::minmax(v) ranges::max_element(v) 如果不进行二次传参，则返回范围内最大的一个元素的迭代器 如果进行二次传参，则可以创建一个映射关系，返回映射关系下最大的那个元素的迭代器，例如： vector&lt;string&gt; v = {&quot;12&quot;,&quot;1... ]]></description>
    <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
  </item><item>
    <title>Readme</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Readme</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/Readme</guid>
    <description><![CDATA[ 如何优雅地食用这个 C++ 语法笔记仓库？ 确保你拥有 git 并掌握一定的git知识 确保你使用的笔记软件是 obsidian 确保你会使用github的基础功能 准备工作完毕，现在开始食用吧 同步更新使用如下 fork这个仓库 到你fork好的仓库里，用git克隆下来这个仓库 用 obsidian 打开这个仓库如下的路径： D:\Code film\C++\memo\C++语法(新) 定期用git同步fork的仓库即可 非同步更新如下： 使用git克隆这个仓库 git clone github.com/imicola/Questions-and-Impressions.git 用 obsi... ]]></description>
    <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
  </item><item>
    <title>stringstream</title>
    <link>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/stringstream</link>
    <guid>https://imicola.github.io/ACM/%E7%AE%97%E6%B3%95/stringstream</guid>
    <description><![CDATA[ 语法 字符串 C++针对字符串的读写有一套专门的方法，即stringstream 语法规则： stringstream ss(str) str是你想进行操作的字符串 场景： 读取字符串中的数据：你可以通过 stringstream 从字符串中提取整数、浮动数、字符等。 将数据写入字符串：可以将不同类型的数据输出到一个字符串中。 main(){ //读入 std::stringstream ss(str); int num1, num2; ss &gt;&gt; num1 &gt;&gt; num2; // 从stringstream读取数据 std::cout &lt;&lt; &quot;n... ]]></description>
    <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
  </item>
    </channel>
  </rss>